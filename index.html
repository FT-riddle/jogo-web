<! DOCTYPE html>
<html data-init = "no-js">
<head>
<meta charset = "UTF-8" />
<title> FT-RIDDLE </title>
<meta name = "viewport" content = "width = device-width, initial-scale = 1" />
<! -

->
<script id = "script-libraries" type = "text / javascript">
if (document.head && document.addEventListener && document.querySelector && Object.create && Object.freeze && JSON) {document.documentElement.setAttribute ("data-init", "carregando");
/ *! @source http://purl.eligrey.com/github/classList.js/blob/1.2.20171210/classList.js * /
"document" em self && ("classList" em document.createElement ("_") && (! document.createElementNS || "classList" em document.createElementNS ("http://www.w3.org/2000/svg", "g")) ||! function (t) {"use strict"; if ("Element" in t) {var e = "classList", n = "prototype", i = t.Element [n], s = Object, r = String [n] .trim || function () {return this.replace (/ ^ \ s + | \ s + $ / g, "")}, o = Array [n] .indexOf || function ( t) {para (var e = 0, n = this.length; n> e; e ++) if (e neste && this [e] === t) return e; return-1}, c = function (t, e ) {this.name = t, this.code = DOMException [t], this.message = e}, a = function (t, e) {if ("" === e) throw new c ("SYNTAX_ERR", "O token não deve estar vazio."); If (/ \ s / .test (e)) lançar novo c ("INVALID_CHARACTER_ERR", "O token não deve conter caracteres de espaço. "); Return o.call (t, e)}, l = function (t) {for (var e = r.call (t.getAttribute (" class ") ||" " ), n = e? e.split (/ \ s + /): [], i = 0, s = n.length; s> i; i ++) this.push (n [i]); this._updateClassName = function () {t.setAttribute ("classe", this.toString ())}}, u = l [n] = [], h = função () {retornar novo l (este)}; if (c [n] = Erro [n], u.item = função (t) {retornar este [t] || nulo}, u.contains = função (t) {retornar ~ a (este, t + "")}, u.add = função () {var t, e = argumentos, n = 0, i = e.length, s =! 1; do t = e [n] + "", ~ a (this, t) || (this.push (t), s =! 0); while (++ n <i); s && this._updateClassName ()}, u.remove = function () {var t, e, n = arguments, i = 0, s = n .comprimento, r =! 1; fazer para (t = n [i] + "", e = a (este, t); ~ e;) esta.splice (e, 1), r =! 0, e = a (this, t); while (++ i <s); r && this._updateClassName ()}, u.toggle = function (t, e) {var n = this.contains (t), i = n? e!==! 0 && "remover": e! ==! 1 && "adicionar"; retornar i && this [i] (t), e ===! 0 || e ===! 1? E:! N}, u. substituir = função (t, e) {var n = a (t + ""); ~ n && (this.splice (n, 1, e), this._updateClassName ())}, u.toString = function () {return this.join ("")}, s.defineProperty) {var f = {get: h, enumerable:! 0, configurable:! 0}; tente {s.defineProperty (i, e, f)} catch (p) {void 0! == p.number && - 2146823252! == p.number || (f.enumerable =! 1, s.defineProperty (i, e, f))}} else s [n] .__ defineGetter __ && i .__ defineGetter __ ( e, h)}} (self), function () {"use strict"; var t = document.createElement ("_"); if (t.classList.add ("c1", "c2") ,! t .classList.contains ("c2")) {var e = function (t) {var e = DOMTokenList.prototype [t]; DOMTokenList.prototype [t] = function (t) {var n, i = arguments.length; para (n = 0; i> n; n ++) t = argumentos [n], e.chamar (this, t)}}; e ("adicionar"), e ("remover")} if (t.classList.toggle ("c3",! 1), t.classList.contains ("c3")) {var n = DOMTokenList.prototype.toggle; DOMTokenList.prototype.toggle = function (t, e) {retornar 1 em argumentos &&! this.contains (t) ==! e? e: n.call (this, t)} } "substituir" em document.createElement ("_"). classList || (DOMTokenList.prototype.replace = function (t, e) {var n = this.toString (). split (""), i = n. indexOf (t + ""); ~ i && (n = n.slice (i), this.remove.apply (this, n), this.add (e), this.add.apply (this, n.slice (1 )))}), t = nulo} ());t)}} "substituir" em document.createElement ("_"). classList || (DOMTokenList.prototype.replace = function (t, e) {var n = this.toString (). split (""), i = n.indexOf (t + ""); ~ i && (n = n.slice (i), this.remove.apply (this, n), this.add (e), this.add.apply (this, n. fatia (1)))}), t = nula} ());t)}} "substituir" em document.createElement ("_"). classList || (DOMTokenList.prototype.replace = function (t, e) {var n = this.toString (). split (""), i = n.indexOf (t + ""); ~ i && (n = n.slice (i), this.remove.apply (this, n), this.add (e), this.add.apply (this, n. fatia (1)))}), t = nula} ());
/ *!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 por contribuidores, Licença MIT
 * consulte https://github.com/es-shims/es5-shim/blob/v4.5.14/LICENSE
 * /
(function (t, r) {"use strict"; if (typeof define === "function" && define.amd) {define (r)} else if (typeof extensions === "object") {module.exports = r ()} else {t.returnExports = r ()}}) (this, function () {var t = Array; var r = t.prototype; var e = Object; var n = e.prototype; var i = Função; var a = i.prototype; var o = String; var f = o.prototype; var u = Number; var l = u.prototype; var s = r.slice; var c = r.splice; var v = r.push; var h = r.unshift; var p = r.concat; var y = r.join; var d = a.call; var g = a.apply; var w = Math.max; var b = Math .min; var T = n.toString; var m = typeof Symbol === "função" && typeof Symbol.toStringTag === "symbol"; var D; var S = Function.prototype.toString, x = / ^ \ s * class /, O = function isES6ClassFn (t) {try {var r = S.call (t); var e = r.replace (/ \ / \ /.* \ n / g, ""); var n = e.replace (/ \ / \ * [. \ s \ S] * \ * \ // g, ""); var i = n.replace (/ \ n / gm, "") .replace (/ {2} / g," "); return x.test (i)} catch (a) {return false}}, E = function tryFunctionObject (t) {try {if (O (t) ) {return false} S.call (t); return true} catch (r) {return false}}, j = "[object Function]", I = "[object GeneratorFunction]", D = function isCallable (t) {if (! t) {return false} if (typeof t! == "function" && typeof t! == "object") {return false} if (m) {return E (t)} if (O (t) ) {return false} var r = T.call (t); return r === j || r === I}; var M; var U = RegExp.prototype.exec, $ = function tryRegexExec (t) { tente {U.call (t); retornar verdadeiro} catch (r) {retornar falso}}, F = "[objeto RegExp]"; M = função isRegex (t) {if (typeof t! == "objeto") {return false} return m? $ (t): T.call (t) === F}; var N; var C = String.prototype.valueOf, k = function tryStringObject (t) {try {C.call ( t); retornar verdadeiro} catch (r) {retornar falso}}, A = "[String do objeto]";N = função isString (t) {if (typeof t === "string") {return true} if (typeof t! == "object") {return false} return m? K (t): T.call ( t) === A}; var R = e.defineProperty && function () {try {var t = {}; e.defineProperty (t, "x", {enumerable: false, value: t}); for (var r in t) {return false} return tx === t} catch (n) {return false}} (); var P = function (t) {var r; if (R) {r = function (t, r, n, i) {if (! i && r in t) {return} e.defineProperty (t, r, {configurable: true, enumerable: false, writable: true, value: n})}} else {r = function (t , r, e, n) {if (! n && r in t) {return} t [r] = e}} função de retorno defineProperties (e, n, i) {for (var a in n) {if (t.call (n, a)) {r (e, a, n [a], i)}}}} (n.hasOwnProperty); var J = função isPrimitive (t) {var r = typeof t; return t === null || r! == "object" && r! == "function"}; var Y = u.isNaN || function isActualNaN (t) {return t! == t}; var z = {ToInteger:função ToInteger (t) {var r = + t; if (Y (r)) {r = 0} else if (r! == 0 && r! == 1/0 && r! == - (1/0)) {r = (r> 0 || -1) * Math.floor (Math.abs (r))} return r}, ToPrimitive: function ToPrimitive (t) {var r, e, n; if (J (t)) { return t} e = t.valueOf; if (D (e)) {r = e.call (t); if (J (r)) {return r}} n = t.toString; if (D (n) ) {r = n.call (t); if (J (r)) {return r}} lançar novo TypeError}, ToObject: function (t) {if (t == null) {throw new TypeError ("pode ​​' t converter "+ t +" em objeto ")} retornar e (t)}, ToUint32: função ToUint32 (t) {retornar t >>> 0}}; var Z = função Vazia () {}; P (a, { vincular: vincular função (t) {var r = this; if (! D (r)) {lançar novo TypeError ("Function.prototype.bind chamado em incompatível" + r)} var n = s.call (argumentos, 1 ); var a; var o = função () {if (esta instância de a) {var i = g.call (r, this, p.call (n, s.call (argumentos))); if (e (i ) === i) {return i} return this} else {return g.call (r, t, p.call (n, s.chamar (argumentos)))}}; var f = w (0, r.length-n.length); var u = []; for (var l = 0; l <f; l ++) {v.call (u , "$" + l)} a = i ("binder", "return function (" + y.call (u, ",") + ") {return binder.apply (this, arguments);}") ( o); if (r.prototype) {Z.prototype = r.prototype; a.prototype = new Z; Z.prototype = null} return a}}); var G = d.bind (n.hasOwnProperty); var H = d.bind (n.toString); var W = d.bind (s); var B = g.bind (s); if (typeof document === "object" && document && document.documentElement) {try {W ( document.documentElement.childNodes)} catch (X) {var L = W; var q = B; W = função arraySliceIE (t) {var r = []; var e = t.length; while (e--> 0 ) {r [e] = t [e]} retornar q (r, L (argumentos, 1))}; B = função arraySliceApplyIE (t, r) {retornar q (W (t), r)}}} var K = d.bind (f.slice); var Q = d.bind (f.split); var V = d.bind (f.indexOf); var _ = d.bind (v); var tt = d. vincular (n.propertyIsEnumerable); var rt = d.bind (r.sort); var et = t.isArray || function isArray (t) {return H (t) === "[object Array]"}; var nt = [] .unshift (0)! == 1; P (r, {unshift: function () {h.apply (this, arguments); return this.length}}, nt); P (t, {isArray: et}) ; var it = e ("a"); var at = it [0]! == "a" ||! (0 nele); var ot = função corretamenteBoxed (t) {var r = true; var e = verdadeiro; var n = falso; if (t) {tente {t.call ("foo", função (t, e, n) {if (typeof n! == "objeto") {r = falso}}); t.call ([1], function () {"use strict"; e = typeof this === "string"}, "x")} catch (i) {n = true}} return !! t &&! n && r && e }; P (r, {forEach: function forEach (t) {var r = z.ToObject (this); var e = at && N (this)? Q (this, ""): r; var n = -1; var i = z.ToUint32 (e.length); var a; if (argumentos.length> 1) {a = argumentos [1]} if (! D (t)) {lance novo TypeError ("Array.prototype.forEach callback must be a function ")} while (++ n <i) {if (n in e) {if (typeof a ===" undefined ") {t (e [n], n, r) } else {t.call (a, e [n], n, r)}}}}} ,! ot (r.forEach)); P (r, {map: function map (r) {var e = z .ToObject (this); var n = at && N (this)? Q (this, ""): e; var i = z.ToUint32 (n.length); var a = t (i); var o; if (argumentos .length> 1) {o = argumentos [1]} if (! D (r)) {throw new TypeError ("Array.prototype.map callback must be a function")} for (var f = 0; f <i ; f ++) {if (f in n) {if (typeof o === "undefined") {a [f] = r (n [f], f, e)} else {a [f] = r.call (o, n [f], f, e)}}} retornar a}} ,! ot (r.map)); P (r, {filtro: filtro de função (t) {var r = z.ToObject (este ); var e = at && N (this)? Q (this, ""): r; var n = z.ToUint32 (e.length); var i = []; var a; var o; if (arguments.length> 1) {o = argumentos [1]} if (! D (t)) {lance novo TypeError ("Array.prototype.o retorno de chamada do filtro deve ser uma função ")} para (var f = 0; f <n; f ++) {if (f in e) {a = e [f]; if (typeof o ===" indefinido "? t ( a, f, r): t.call (o, a, f, r)) {_ (i, a)}}} return i}} ,! ot (r.filter)); P (r, {every : função every (t) {var r = z.ToObject (this); var e = at && N (this)? Q (this, ""): r; var n = z.ToUint32 (e.length); var i; if (arguments.length> 1) {i = arguments [1]} if (! D (t)) {throw new TypeError ("Array.prototype.every callback must be a function")} for (var a = 0; a <n; a ++) {if (a in e &&! (typeof i === "indefinido"? t (e [a], a, r): t.call (i, e [a], a, r) )) {return false}} return true}} ,! ot (r.every)); P (r, {some: function some (t) {var r = z.ToObject (this); var e = at && N (this) )? Q (this, ""): r; var n = z.ToUint32 (e.length); var i; if (argumentos.comprimento> 1) {i = argumentos [1]} if (! D (t) ) {lance novo TypeError ("Array.prototype.algum retorno de chamada deve ser uma função ")} para (var a = 0; a <n; a ++) {if (a in e && (typeof i ===" undefined "? t (e [a], a, r): t.call (i, e [a], a, r))) {return true}} return false}} ,! ot (r.some)); var ft = false; if (r.reduce) {ft = tipo de r.reduce.call ("es5", função (t, r, e, n) {retornar n}) === "objeto"} P (r, {reduzir: função reduzir (t) {var r = z .ToObject (this); var e = at && N (this)? Q (this, ""): r; var n = z.ToUint32 (e.length); if (! D (t)) {throw new TypeError (" O retorno de chamada Array.prototype.reduce deve ser uma função ")} if (n === 0 && arguments.length === 1) {throw new TypeError (" reduzir a matriz vazia sem valor inicial ")} var i = 0; var a; if (argumentos.comprimento> = 2) {a = argumentos [1]} else {fazer {se (i em e) {a = e [i ++]; quebrar} se (++ i> = n) {lançar new TypeError ("redução da matriz vazia sem valor inicial")}} while (true)} for (; i <n;i ++) {if (i in e) {a = t (a, e [i], i, r)}} return a}} ,! ft); var ut = false; if (r.reduceRight) {ut = typeof r.reduceRight.call ("es5", function (t, r, e, n) {return n}) === "object"} P (r, {reduceRight: function reduceRight (t) {var r = z .ToObject (this); var e = at && N (this)? Q (this, ""): r; var n = z.ToUint32 (e.length); if (! D (t)) {throw new TypeError (" O retorno de chamada Array.prototype.reduceRight deve ser uma função ")} if (n === 0 && arguments.length === 1) {throw new TypeError (" reduceRight de array vazio sem valor inicial ")} var i; var a = n-1; if (argument.length> = 2) {i = arguments [1]} else {do ​​{if (a in e) {i = e [a -]; break} if (- a <0 ) {lançar novo TypeError ("reduceRight de matriz vazia sem valor inicial")}} while (true)} if (a <0) {return i} fazer {if (a in e) {i = t (i, e [a], a, r)}} while (a -); return i}} ,! ut); var lt = r.indexOf && [0,1] .indexOf (1,2)!== - 1; P (r, {indexOf: função indexOf (t) {var r = at && N (este)? Q (este, ""): z.ToObject (este); var e = z.ToUint32 (r. comprimento); if (e === 0) {return-1} var n = 0; if (argumentos.comprimento> 1) {n = z.ToInteger (argumentos [1])} n = n> = 0? n : w (0, e + n); para (; n <e; n ++) {if (n in r && r [n] === t) {return n}} return-1}}, lt); var st = r.lastIndexOf && [0,1] .lastIndexOf (0, -3)! == - 1; P (r, {lastIndexOf: função lastIndexOf (t) {var r = at && N (this)? Q (this, "") : z.ToObject (this); var e = z.ToUint32 (r.length); if (e === 0) {return-1} var n = e-1; if (arguments.length> 1) {n = b (n, z.ToInteger (argumentos [1]))} n = n> = 0? n: e-Math.abs (n); para (; n> = 0; n -) {if (n in r && t === r [n]) {return n}} return-1}}, st); var ct = function () {var t = [1,2]; var r = t.splice (); return t.length === 2 && et (r) && r.length === 0} (); P (r, {splice: splice da função (t, r) {if (argumentos.comprimento === 0) {return []} else {return c.apply (this, argumentos)}}} ,! ct); var vt = function () {var t = {}; r.splice.call (t , 0,0,1); return t.length === 1} (); P (r, {splice: function splice (t, r) {if (arguments.length === 0) {return []} var e = argumentos; this.length = w (z.ToInteger (this.length), 0); if (argumentos.comprimento> 0 && typeof r! == "número") {e = W (argumentos); if (e. comprimento <2) {_ (e, this.length-t)} else {e [1] = z.ToInteger (r)}} return c.apply (this, e)}} ,! vt); var ht = function () {var r = new t (1e5); r [8] = "x"; r.splice (1,1); return r.indexOf ("x") === 7} (); var pt = function () {var t = 256; var r = []; r [t] = "a"; r.splice (t + 1,0, "b"); return r [t] === "a "} (); P (r, {splice: function splice (t, r) {var e = z.ToObject (this); var n = []; var i = z.ToUint32 (e.length); var a = z.ToInteger (t); var f = a <0? w (i + a, 0): b (a, i); var u = argumentos.comprimento === 0? 0: argumentos.comprimento === 1? Se:b (w (z.ToInteger (r), 0), se); var l = 0; var s; enquanto (l <u) {s = o (f + l); se (G (e, s)) {n [l] = e [s]} l + = 1} var c = W (argumentos, 2); var v = c.length; var h; se (v <u) {l = f; var p = iu ; enquanto (l <p) {s = o (l + u); h = o (l + v); se (G (e, s)) {e [h] = e [s]} else {excluir e [h]} l + = 1} l = i; var y = i-u + v; enquanto (l> y) {excluir e [l-1]; l- = 1}} else if (v> u) { l = iu; enquanto (l> f) {s = o (l + u-1); h = o (l + v-1); se (G (e, s)) {e [h] = e [ s]} else {delete e [h]} l- = 1}} l = f; for (var d = 0; d <c.length; ++ d) {e [l] = c [d]; l + = 1} e.length = i-u + v; retornar n}} ,! ht ||! Pt); var yt = r.join; var dt; tente {dt = Array.prototype.join.call ("123 ",", ")! ==" 1,2,3 "} catch (X) {dt = true} if (dt) {P (r, {join: function join (t) {var r = typeof t = == "undefined"? ",": t; return yt.call (N (this)? Q (this, ""): this, r)}}, dt)} var gt = [1,2] .join (undefined)! == "1,2"; if (gt) {P (r, {join: function join (t) {var r = typeof t === "undefined"? ",": t; return yt.call (this, r)}}, gt)} var wt = função push (t) {var r = z.ToObject (this); var e = z.ToUint32 (r. comprimento); var n = 0; enquanto (n <argumentos.comprimento) {r [e + n] = argumentos [n]; n + = 1} r.comprimento = e + n; retornar e + n}; var bt = function () {var t = {}; var r = Array.prototype.push.call (t, indefinido); return r! == 1 || t.length! == 1 || typeof t [0]! = = "indefinido" ||! G (t, 0)} (); P (r, {push: função push (t) {if (et (this)) {return v.apply (this, arguments)} return wt .aplicar (isto, argumentos)}}, bt); var Tt = function () {var t = []; var r = t.push (indefinido); retornar r! == 1 || t.length! == 1 || typeof t [0]! == "undefined" ||! G (t, 0)} (); P (r, {push: wt}, Tt); P (r, {slice: function (t , r) {var e = N (isto)? Q (isto, ""): isto; retornar B (e, argumentos)}}, em); var mt = função () {experimentar {[1,2]. sort (null)} catch (t) {try {[1,2] .sort ({})} catch (r) {return false}} return true} (); var Dt = function () {try {[1 , 2] .sort (/ a /);return false} catch (t) {} return true} (); var St = function () {try {[1,2] .sort (undefined); return true} catch (t) {} return false} (); P (r, {sort: function sort (t) {if (typeof t === "undefined") {return rt (this)} if (! D (t)) {throw new TypeError ("Array.prototype.sort o retorno de chamada deve ser uma função ")} return rt (this, t)}}, mt ||! St ||! Dt); var xt =! tt ({toString: null}," toString "); var Ot = tt (function () {}, "prototype"); var Et =! G ("x", "0"); var jt = function (t) {var r = t.constructor; return r && r.prototype === t }; var It = {$ applicationCache: true, $ console: true, $ external: true, $ frame: true, $ frameElement: true, $ frames: true, $ innerHeight: true, $ innerWidth: true, $ onmozfullscreenchange: true , $ onmozfullscreenerror: true, $ outerHeight: true, $ outerWidth: true, $ pageXOffset: true, $ pageYOffset: true, $ parent: true, $ scrollLeft: true, $ scrollTop: true, $ scrollX: true,$ scrollY: true, $ self: true, $ webkitIndexedDB: true, $ webkitStorageInfo: true, $ window: true, $ width: true, $ height: true, $ top: true, $ localStorage: true}; var Mt = function () {if (typeof window === "undefined") {return false} for (var t in window) {try {if (! It ["$" + t] && G (window, t) && window [t]! == null && typeof window [t] === "object") {jt (window [t])}} catch (r) {return true}} return false} (); var Ut = function (t) {if (typeof janela === "undefined" ||! Mt) {return jt (t)} try {return jt (t)} catch (r) {return false}}; var $ t = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]; var Ft = $ t.length; var Nt = function isArguments (t) {return H (t) === "[Argumentos do objeto ] "}; var Ct = function isArguments (t) {return t!== null && typeof t === "objeto" && typeof t.length === "número" && t.length> = 0 &&! et (t) && D (t.callee)}; var kt = Nt (argumentos)? Nt: Ct ; P (e, {keys: function keys (t) {var r = D (t); var e = kt (t); var n = t! == null && typeof t === "objeto"; var i = n && N (t); if (! n &&! r &&! e) {lançar novo TypeError ("Object.keys chamados em um não-objeto")} var a = []; var f = Ot && r; if (i && Et || e) { for (var u = 0; u <t.length; ++ u) {_ (a, o (u))}} if (! e) {for (var l in t) {if (! (f && l == = "protótipo") && G (t, l)) {_ (a, o (l))}}} if (xt) {var s = Ut (t); for (var c = 0; c <Ft; c ++ ) {var v = $ t [c]; if (! (s && v === "construtor") && G (t, v)) {_ (a, v)}}} return a}}); var At = e .keys && function () {return e.keys (argumentos) .length === 2} (1,2); var Rt = e.keys && function () {var t = e.keys (argumentos); retornar argumentos.length! == 1 || t.length! == 1 || t [0]! == 1} (1); var Pt = e.keys; P (e, {keys : teclas de função (t) {if (kt (t)) {return Pt (W (t))} else {return Pt (t)}}} ,! At || Rt); var Jt = new Date (-0xc782b5b342b24 ) .getUTCMonth ()! == 0; var Yt = new Date (-0x55d318d56a724); var zt = new Date (14496624e5); var Zt = Yt.toUTCString ()! == "Seg, 01 de janeiro -45875 11:59 : 59 GMT "; var Gt; var Ht; var Wt = Yt.getTimezoneOffset (); if (Wt <-720) {Gt = Yt.toDateString ()! ==" Tue Jan 02 -45875 "; Ht =! / ^ Qui, 10 de dezembro de 2015 \ d \ d: \ d \ d: \ d \ d GMT [- +] \ d \ d \ d \ d (?: | $) /. Test (String (zt))} else { Gt = Yt.toDateString ()! == "Seg 01 de janeiro -45875"; Ht =! / ^ Quarta, 09 de dezembro de 2015 \ d \ d: \ d \ d: \ d \ d GMT [- +] \ d \ d \ d \ d (?: | $) /. test (String (zt))} var Bt = d.bind (Date.prototype.getFullYear); var Xt = d.bind (Date.prototype.getMonth); var Lt = d.bind (Date.prototype.getDate); var qt = d.bind (Date.prototype.getUTCFullYear); var Kt = d.bind (Date.prototype.getUTCMonth); var Qt = d.bind (Date.prototype.getUTCDate); var Vt = d.bind (Date.prototype.getUTCDay); var _t = d.bind (Date.prototype.getUTCHours) ; var tr = d.bind (Date.prototype.getUTCMinutes); var rr = d.bind (Date.prototype.getUTCSeconds); var er = d.bind (Date.prototype.getUTCMilliseconds); var nr = ["Sol" , "Seg", "Ter", "Quarta", "Qui", "Sex", "Sáb"]; var ir = ["Jan", "Fev", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]; var ar = function daysInMonth (t, r) {return Lt (new Date (r, t, 0))}; P (Date.prototype, {getFullYear: function getFullYear () {if (! This ||! (This instanceof Date)) {throw new TypeError ("isto não é um objeto Date.")} Var t = Bt (este); se (t <0 &&Xt (this)> 11) {return t + 1} return t}, getMonth: function getMonth () {if (! This ||! (This instanceof Date)) {throw new TypeError ("este não é um objeto Date. ")} var t = Bt (este); var r = Xt (isto); if (t <0 && r> 11) {return 0} return r}, getDate: function getDate () {if (! this ||! ( esta instância de Date)) {lançar novo TypeError ("este não é um objeto Date.")} var t = Bt (isto); var r = Xt (isto); var e = Lt (isto); if (t <0 && r > 11) {if (r === 12) {return e} var n = ar (0, t + 1); return n-e + 1} return e}, getUTCFullYear: function getUTCFullYear () {if (! This ||! (esta instância de Data)) {lançar novo TypeError ("este não é um objeto de Data.")} var t = qt (este); if (t <0 && Kt (este)> 11) {return t + 1} return t}, getUTCMonth: function getUTCMonth () {if (! this ||! (this instanceof Date)) {throw new TypeError ("isto não é um objeto Date.")} var t = qt (this); var r = Kt (este);if (t <0 && r> 11) {return 0} return r}, getUTCDate: function getUTCDate () {if (! this ||! (this instanceof Date)) {throw new TypeError ("isto não é um objeto Date." )} var t = qt (isto); var r = Kt (isto); var e = Qt (isto); if (t <0 && r> 11) {if (r === 12) {return e} var n = ar (0, t + 1); return n-e + 1} return e}}, Jt); P (Date.prototype, {toUTCString: function toUTCString () {if (! this ||! (this instanceof Date) ) {throw new TypeError ("isto não é um objeto Date.")} var t = Vt (isto); var r = Qt (isto); var e = Kt (isto); var n = qt (isto); var i = _t (isto); var a = tr (isto); var o = rr (isto); devolver nr [t] + "," + (r <10? "0" + r: r) + "" + ir [e] + "" + n + "" + (i <10? "0" + i: i) + ":" + (a <10? "0" + a: a) + ":" + (o <10? "0" + o: o) + "GMT"}}, Jt || Zt); P (Date.prototype, {toDateString:function toDateString () {if (! this ||! (this instanceof Date)) {throw new TypeError ("este não é um objeto Date.")} var t = this.getDay (); var r = this.getDate ( ); var e = this.getMonth (); var n = this.getFullYear (); retornar nr [t] + "" + ir [e] + "" + (r <10? "0" + r: r) + "" + n}}, Jt || Gt); if (Jt || Ht) {Date.prototype.toString = function toString () {if (! this ||! (this instanceof Date)) {throw new TypeError ("este não é um objeto Date.")} var t = this.getDay (); var r = this.getDate (); var e = this.getMonth (); var n = this.getFullYear (); var i = this.getHours (); var a = this.getMinutes (); var o = this.getSeconds (); var f = this.getTimezoneOffset (); var u = Math.floor (Math.abs (f) / 60) ; var l = Math.floor (Math.abs (f)% 60); retornar nr [t] + "" + ir [e] + "" + (r <10? "0" + r: r) + " "+ n +" "+ (i <10?" 0 "+ i: i) +": "+ (a <10? "0" + a: a) + ":" + (o <10? "0" + o: o) + "GMT" + (f> 0? "-": "+") + (u <10? "0" + u: u) + (l <10? "0" + l: l)}; if (R) {e.defineProperty (Date.prototype, "toString", {configurável: verdadeiro, enumerável: falso, gravável: verdadeiro})}} var ou = -621987552e5; var fr = "- 000001"; var ur = Date.prototype.toISOString && new Date (ou) .toISOString (). indexOf (fr) == = -1; var lr = Date.prototype.toISOString && new Date (-1) .toISOString ()! == "1969-12-31T23: 59: 59.999Z"; var sr = d.bind (Date.prototype.getTime) ; P (Date.prototype, {toISOString: function toISOString () {if (! IsFinite (this) ||! IsFinite (sr (this))) {throw new RangeError ("Date.prototype.toISOString chamado em um valor não finito . ")} var t = qt (isto); var r = Kt (isto); t + = Math.floor (r / 12); r = (r% 12 + 12)% 12; var e = [r + 1 , Qt (isto), _ t (isto),tr (isto), rr (isto)]; t = (t <0? "-": t> 9999? "+": "") + K ("00000" + Math.abs (t), 0 <= t && t <= 9999? -4: -6); para (var n = 0; n <e.length; ++ n) {e [n] = K ("00" + e [n], - 2)} return t + "-" + W (e, 0,2) .join ("-") + "T" + W (e, 2) .join (":") + "." + K ("000" + er (this), - 3) + "Z"}}, ur || lr); var cr = function () {try {return Date.prototype.toJSON && new Date (NaN) .toJSON () === null && new Date ( ou) .toJSON (). indexOf (fr)! == - 1 && Date.prototype.toJSON.call ({toISOString: function () {return true}})} catch (t) {return false}} (); if ( ! cr) {Date.prototype.toJSON = function toJSON (t) {var r = e (this); var n = z.ToPrimitive (r); if (typeof n === "número" &&! isFinite (n) ) {return null} var i = r.toISOString; if (! D (i)) {throw new TypeError ("A propriedade toISOString não pode ser chamada ")} return i.call (r)}} var vr = Date.parse (" + 033658-09-27T01: 46: 40.000Z ") === 1e15; var hr =! isNaN (Data .parse ("2012-04-04T24: 00: 00.500Z")) ||! isNaN (Date.parse ("2012-11-31T23: 59: 59.000Z")) ||! isNaN (Date.parse (" 2012-12-31T23: 59: 60.000Z ")); var pr = isNaN (Date.parse (" 2000-01-01T00: 00: 00.000Z ")); if (pr || hr ||! Vr) { var yr = Math.pow (2,31) -1; var dr = Y (new Date (1970,0,1,0,0,0, yr + 1) .getTime ()); Date = function (t) {var r = função Data (e, n, i, a, f, u, l) {var s = argumentos.comprimento; var c; se (esta instância de t) {var v = u; var h = l; se (dr && s> = 7 && l> yr) {var p = Math.floor (l / yr) * yr; var y = Math.floor (p / 1e3); v + = y; h- = y * 1e3} c = s = == 1 && o (e) === e? Novo t (r.parse (e)): s> = 7? Novo t (e, n, i, a, f, v, h): s> = 6? novo t (e, n, i, a, f, v): s> = 5? novo t (e, n, i, a, f): s> = 4? novo t (e, n, i, a ): s> = 3? novo t (e, n, i): s>= 2? Novo t (e, n): s> = 1? Novo t (e instância de t? + E: e): novo t} else {c = t.aplicar (isto, argumentos)} if (! J ( c)) {P (c, {construtor: r}, verdadeiro)} retornar c}; var e = novo RegExp ("^" + "(\\ d {4} | [+ -] \\ d {6} ) "+" (?: - (\\ d {2}) "+" (?: - (\\ d {2}) "+" (?: "+" T (\\ d {2}) " + ": (\\ d {2})" + "(?:" + ": (\\ d {2})" + "(?: (\\. \\ d {1,}))?" + ")?" + "(" + "Z |" + "(?:" + "([- +])" + "(\\ d {2})" + ": (\\ d {2} ) "+") "+")?)?)?)? "+" $ "); var n = [0,31,59,90,120,151,181,212,243,273,334,365]; var i = função dayFromMonth (t, r) {var e = r> 1? 1: 0; retornar n [r] + Math.floor ((t-1969 + e) ​​/ 4) -Math.floor ((t-1901 + e) ​​/ 100) + Math.floor ((t -1601 + e) ​​/ 400) + 365 * (t-1970)}; var a = função toUTC (r) {var e = 0; var n = r; if (dr && n> ano) {var i = Math.floor (n / ano) * ano; var a = Matemática.floor (i / 1e3); e + = a; n- = a * 1e3} return u (new t (1970,0,1,0,0, e, n))}; for (var f in t) {if (G (t, f)) {r [f] = t [f]}} P (r, {agora: t.now, UTC: t.UTC}, verdadeiro); r.protótipo = t.protótipo; P (r.protótipo, {construtor: r}, verdadeiro); var l = função parse (r) {var n = e.exec (r); se (n) {var o = u (n [1]), f = u (n [2] || 1) -1, l = u (n [3] || 1) -1, s = u (n [4] || 0), c = u (n [5] || 0), v = u (n [6] || 0), h = Math.floor (u (n [7] || 0) * 1e3), p = Booleano (n [4] &&! N [ 8]), y = n [9] === "-"? 1: -1, d = u (n [10] || 0), g = u (n [11] || 0), w; var b = c> 0 || v> 0 || h> 0; if (s <(b? 24: 25) && c <60 && v <60 && h <1e3 && f> -1 && f <12 && d <24 && g <60 && l> -1 && l <i ( o, f + 1) -i (o, f)) {w = ((i (o, f) + l) * 24 + s + d * y) * 60; w = ((w + c + g * y) * 60 + v) * 1e3 + h; if (p) {w = a (w)} if (-864e13 <= w && w <= 864e13) {return w}} return NaN} return t.parse.apply ( este, argumentos)}; P (r, {analisar: l}); retornar r} (Data)} se (! Data.agora) {Date.now = function now () {return (new Date) .getTime ()}} var gr = l.toFixed && (8e-5.toFixed (3)! == "0,000" || .9.toFixed (0)! == "1" || 1.255.toFixed (2)! == "1.25" || (1000000000000000128) .toFixed (0)! == "1000000000000000128"); var wr = {base: 1e7, tamanho : 6, dados: [0,0,0,0,0,0], multiplicação: multiplicação da função (t, r) {var e = -1; var n = r; enquanto (++ e <tamanho da escrita) {n + = t * wr.data [e]; wr.data [e] = n% wr.base; n = Math.floor (n / wr.base)}}, divide: função divide (t) {var r = wr.size; var e = 0; while (- r> = 0) {e + = wr.data [r]; wr.data [r] = Math.floor (e / t); e = e% t * wr.base}}, numToString: function numToString () {var t = wr.size; var r = ""; while (- t> = 0) {if (r! == "" || t == = 0 || wr.data [t]! == 0) {var e = o (wr.data [t]); if (r === "") {r = e} else {r + = K (" 0000000 ", 0,7-e.length) + e}}} retorno r}, pow: função pow (t, r, e) {retorno r === 0? E: r% 2 === 1? Pow (t, r-1, e * t): pow (t * t,r / 2, e)}, log: função log (t) {var r = 0; var e = t; enquanto (e> = 4096) {r + = 12; e / = 4096} enquanto (e> = 2) {r + = 1; e / = 2} retornar r}}; var br = função paraFixado (t) {var r, e, n, i, a, f, l, s; r = u (t); r = Y (r)? 0: Math.floor (r); if (r <0 || r> 20) {lançar novo RangeError ("Number.toFixed chamado com número inválido de decimais")} e = u (this); if (Y (e)) {return "NaN"} if (e <= - 1e21 || e> = 1e21) {return o (e)} n = ""; if (e <0) {n = "- "; e = -e} i =" 0 "; se (e> 1e-21) {a = wr.log (e * wr.pow (2,69,1)) - 69; f = a <0? e * wr.pow (2, -a, 1): e / wr.pow (2, a, 1); f * = 4503599627370496; a = 52-a; if (a> 0) {wr.multiply (0 , f); l = r; enquanto (l> = 7) {wr.multiply (1e7,0); l- = 7} wr.multiply (wr.pow (10, l, 1), 0); l = a-1; while (l> = 23) {wr.divide (1 << 23); l- = 23} wr.divide (1 << l); wr.multiply (1,1); wr.divide ( 2); i = wr.numToString ()} else {wr.multiply (0, f); wr.multiply (1 << - a, 0); i = wr.numToString () + K ("0.00000000000000000000 ", 2,2 + r)}} if (r> 0) {s = i.length; if (s <= r) {i = n + K (" 0,0000000000000000000 ", 0, r-s + 2) + i} else {i = n + K (i, 0, sr) + "." + K (i, sr)}} else {i = n + i} return i}; P (l, {toFixed: br }, gr); var Tr = function () {try {return 1..toPrecision (undefined) === "1"} catch (t) {return true}} (); var mr = l.toPrecision; P ( l, {toPrecision: function toPrecision (t) {return typeof t === "undefined"? mr.call (this): mr.call (this, t)}}, Tr); if ("ab" .split ( / (?: ab) * /). length! == 2 || ".". split (/(.?)(.?)/). length! == 4 || "tesst" .split (/ ( s) * /) [1] === "t" || "test" .split (/ (?:) /, - 1) .length! == 4 || "". split (/.?/) .length || ".". split (/ () () /). length> 1) {(function () {var t = typeof / () ?? /. exec ("") [1] === "indefinido"; var r = Math.pow (2,32) -1; f.split = função (e, n) {var i = String (this);if (typeof e === "undefined" && n === 0) {return []} if (! M (e)) {return Q (this, e, n)} var a = []; var o = ( e.ignoreCase? "i": "") + (e.multiline? "m": "") + (e.unicode? "u": "") + (e.sticky? "y": "") , f = 0, u, l, s, c; var h = new RegExp (e.source, o + "g"); if (! t) {u = new RegExp ("^" + h.source + "$ ( ?! \\ s) ", o)} var p = typeof n ===" undefined "? r: z.ToUint32 (n); l = h.exec (i); while (l) {s = l. índice + l [0] .length; if (s> f) {_ (a, K (i, f, l.index)); if (! t && l.length> 1) {l [0] .substitua (u , function () {para (var t = 1; t <argumentos.comprimento-2; t ++) {if (tipo de argumentos [t] === "indefinido") {l [t] = vazio 0}}})} if (l.length> 1 && l.index <i.length) {v.apply (a, W (l, 1))} c = l [0] .length; f = s; if (a.length> = p ) {break}} if (h.lastIndex === l.index) {h.lastIndex ++} l = h.exec (i)} if (f === i.comprimento) {if (c ||! h.test ("")) {_ (a, "")}} else {_ (a, K (i, f))} return a.length> p? W ( a, 0, p): a}}) ()} else if ("0" .split (void 0,0) .length) {f.split = divisão de função (t, r) {if (typeof t == = "undefined" && r === 0) {return []} return Q (this, t, r)}} var Dr = f.replace; var Sr = function () {var t = []; "x". substituir (/ x (.)? / g, função (r, e) {_ (t, e)}); retornar t.length === 1 && typeof t [0] === "indefinido"} (); se (! Sr) {f.replace = substituição de função (t, r) {var e = D (r); var n = M (t) && / \) [*?] /. Test (t.source); se (! e ||! n) {return Dr.call (this, t, r)} else {var i = function (e) {var n = arguments.length; var i = t.lastIndex; t.lastIndex = 0 ; var a = t.exec (e) || []; t.lastIndex = i; _ (a, argumentos [n-2], argumentos [n-1]); retornar r.apply (this, a)} ; return Dr.call (this, t, i)}}} var xr = f.substr; var Or = "". substr && "0b" .substr (-1)! == "b"; P (f,{substr: função substr (t, r) {var e = t; if (t <0) {e = w (this.length + t, 0)} return xr.call (this, e, r)}}, Ou); var Er = "\ t \ n \ x0B \ f \ r \ xa0 \ u1680 \ u2000 \ u2001 \ u2002 \ u2003" + "\ u2004 \ u2005 \ u2006 \ u2007 \ u2008 \ u2009 \ u200a \ u202f \ u205f \ u3000 \ u2028 "+" \ u2029 \ ufeff "; var jr =" \ u200b "; var Ir =" ["+ Er +"] "; var Mr = novo RegExp (" ^ "+ Ir + Ir +" * ") ; var Ur = new RegExp (Ir + Ir + "* $"); var $ r = f.trim && (Er.trim () ||! jr.trim ()); P (f, {trim: function trim () {if (typeof this === "undefined" || this === null) {throw new TypeError ("não é possível converter" + this + "to object")} return o (this) .replace (Mr, "" ) .replace (Ur, "")}}, $ r); var Fr = d.bind (String.prototype.trim); var Nr = f.lastIndexOf && "abc \ u3042 \ u3044" .lastIndexOf ("\ u3042 \ u3044 ", 2)! == - 1; P (f,{lastIndexOf: function lastIndexOf (t) {if (typeof this === "undefined" || this === null) {throw new TypeError ("não é possível converter" + this + "para objeto")} var r = o (isto); var e = o (t); var n = argumentos.comprimento> 1? u (argumentos [1]): NaN; var i = Y (n)? Infinito: z.ToInteger (n); var a = b (w (i, 0), r.length); var f = e.length; var l = a + f; enquanto (l> 0) {l = w (0, lf); var s = V ( K (r, l, a + f), e); if (s! == - 1) {return l + s}} return-1}}, Nr); var Cr = f.lastIndexOf; P (f, {lastIndexOf: function lastIndexOf (t) {return Cr.apply (this, arguments)}}, f.lastIndexOf.length! == 1); if (parseInt (Er + "08")! == 8 || parseInt (Er + "0x16")! == 22) {parseInt = function (t) {var r = / ^ [- +]? 0 [xX] /; função de retorno parseInt (e, n) {if (typeof e === " símbolo ") {" "+ e} var i = Fr (String (e)); var a = u (n) || (r.test (i)? 16:10); retornar t (i, a)} } (parseInt)} if (1 / parseFloat ("- 0")!== - Infinito) {parseFloat = function (t) {função de retorno parseFloat (r) {var e = Fr (String (r)); var n = t (e); return n === 0 && K (e, 0, 1) === "-"? - 0: n}} (parseFloat)} if (String (new RangeError ("test"))! == "RangeError: test") {var kr = function toString () {if (typeof this === "undefined" || this === null) {throw new TypeError ("não é possível converter" + this + "to object")} var t = this.name; if (typeof t === "undefined") {t = "Error"} else if (typeof t! == "string") {t = o (t)} var r = this.message; if (typeof r === "undefined") { r = ""} else if (typeof r! == "string") {r = o (r)} if (! t) {return r} if (! r) {return t} return t + ":" + r }; Error.prototype.toString = kr} if (R) {var Ar = function (t, r) {if (tt (t, r)) {var e = Object.getOwnPropertyDescriptor (t, r); if (e .configurável) {e.enumerable = false; Objeto.defineProperty (t, r, e)}}}; Ar (Error.prototype, "message"); if (Error.prototype.message! == "") {Error.prototype.message = ""} Ar (Erro. protótipo, "nome")} if (String (/ a / gim)! == "/ a / gim") {var Rr = function toString () {var t = "/" + this.source + "/"; se (this.global) {t + = "g"} if (this.ignoreCase) {t + = "i"} if (this.multiline) {t + = "m"} return t}; RegExp.prototype.toString = Rr} });toString = Rr}});toString = Rr}});
/ *!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 de Paul Miller (http://paulmillr.com)
 * e contribuidores, Licença MIT
 * es6-shim: v0.35.4
 * consulte https://github.com/paulmillr/es6-shim/blob/0.35.4/LICENSE
 * Detalhes e documentação:
 * https://github.com/paulmillr/es6-shim/
 * /
(função (e, t) {if (typeof define === "function" && define.amd) {define (t)} else if (typeof extensions === "object") {module.exports = t ()} else {e.returnExports = t ()}}) (this, function () {"use strict"; var e = Function.call.bind (Function.apply); var t = Function.call.bind (Function.call) ; var r = Array.isArray; var n = Object.keys; var o = função notThunker (t) {retornar função notThunk () {retornar! e (t, este, argumentos)}}; var i = função (e) {try {e (); return false} catch (t) {return true}}; var a = function valueOrFalseIfThrows (e) {try {return e ()} catch (t) {return false}}; var u = o (i); var f = function () {return! i (function () {return Object.defineProperty ({}, "x", {get: function () {}})})}; var s = !! Object.defineProperty && f (); var c = function foo () {}. Name === "foo"; var l = Function.call.bind (Array.prototype.forEach); var p = Function.call.bind (Array .protótipo.reduzir); var v = Function.call.bind (Array.prototype.filter); var y = Function.call.bind (Array.prototype.some); var h = function (e, t, r, n) {if (! n && t em e) {return} if (s) {Object.defineProperty (e, t, {configurable: true, enumerable: false, writable: true, value: r})} else {e [t] = r} }; var b = função (e, t, r) {l (n (t), função (n) {var o = t [n]; h (e, n, o, !! r)})}; var g = Function.call.bind (Object.prototype.toString); var d = typeof / abc / === "função"? função IsCallableSlow (e) {return typeof e === "function" && g (e) = == "[função do objeto]"}: função IsCallableFast (e) {return typeof e === "function"}; var m = {getter: function (e, t, r) {if (! s) {throw new TypeError ("getters requerem suporte ES5 verdadeiro")} Object.defineProperty (e, t, {configurable: true, enumerable: false, get: r})}, proxy: function (e, t, r) {if (! S ) {lance novo TypeError ("getters requerem suporte ES5 verdadeiro ")} var n = Object.getOwnPropertyDescriptor (e, t); Object.defineProperty (r, t, {configurable: n.configurable, enumerable: n.enumerable, get: function getKey () {return e [t]}, definir: função setKey (r) {e [t] = r}})}, redefinir: função (e, t, r) {se (s) {var n = Object.getOwnPropertyDescriptor (e, t ); n.value = r; Object.defineProperty (e, t, n)} else {e [t] = r}}, defineByDescriptor: function (e, t, r) {if (s) {Object.defineProperty ( e, t, r)} else if ("valor" em r) {e [t] = r.value}}, preserveToString: function (e, t) {if (t && d (t.toString)) {h (e , "toString", t.toString.bind (t), true)}}}; var O = Object.create || function (e, t) {var r = function Prototype () {}; r.prototype = e ; var o = new r; if (typeof t! == "undefined") {n (t) .forEach (function (e) {m.defineByDescriptor (o, e, t [e])})} return o} ; var w = função (e, t) {if (! Objeto.setPrototypeOf) {return false} return a (function () {var r = function Subclasse (t) {var r = new e (t); Object.setPrototypeOf (r, Subclass.prototype); return r}; Object.setPrototypeOf ( r, e); r.prototype = O (e.prototype, {construtor: {value: r}}); return t (r)})}; var j = function () {if (typeof self! == " undefined ") {return self} if (typeof window! ==" undefined ") {return window} if (typeof global! ==" undefined ") {return global} lançar um novo erro (" não foi possível localizar o objeto global ")} ; var S = j (); var T = S.isFinite; var I = Function.call.bind (String.prototype.indexOf); var E = Function.apply.bind (Array.prototype.indexOf); var P = Function.call.bind (Array.prototype.concat); var C = Function.call.bind (String.prototype.slice); var M = Function.call.bind (Array.prototype.push); var x = Função. apply.bind (Array.prototype.push); var N = Function.call.bind (Array.prototype.shift);var A = Math.max; var R = Math.min; var _ = Math.floor; var k = Math.abs; var L = Math.exp; var F = Math.log; var D = Math.sqrt; var z = Function.call.bind (Object.prototype.hasOwnProperty); var q; var W = function () {}; var G = S.Map; var H = G && G.prototype ["excluir"]; var V = G && G .prototype.get; var B = G && G.prototype.has; var U = G && G.prototype.set; var $ = S.Symbol || {}; var J = $. species || "@@ species"; var X = Number.isNaN || function isNaN (e) {return e! == e}; var K = Number.isFinite || function isFinite (e) {return typeof e === "number" && T (e)}; var Z = d (Math.sign)? Math.sign: sinal de função (e) {var t = Número (e); if (t === 0) {return t} if (X (t)) {return t} retornar t <0? -1: 1}; var Y = função log1p (e) {var t = Número (e); if (t <-1 || X (t)) {retornar NaN} if (t == = 0 || t === Infinito) {return t} if (t === - 1) {return-Infinity} return 1 + t-1 === 0? T: t * (F (1 + t) / (1 + t-1))};var Q = function isArguments (e) {return g (e) === "[object Arguments]"}; var ee = function isArguments (e) {return e! == null && typeof e === "object" && typeof e. comprimento === "número" && e.length> = 0 && g (e)! == "[array do objeto]" && g (e.callee) === "[Função do objeto]"}; var te = Q (argumentos)? Q: ee; var re = {primitivo: function (e) {return e === null || typeof e! == "function" && typeof e! == "object"}, string: function (e) {return g (e) === "[string de objeto]"}, regex: função (e) {return g (e) === "[object RegExp]"}, símbolo: função (e) {return typeof S.Symbol = == "função" && typeof e === "símbolo"}}; var ne = substituição da funçãoNativo (e, t, r) {var n = e [t]; h (e, t, r, verdadeiro); m. preserveToString (e [t], n)}; var oe = typeof $ === "função" && typeof $ ["para "] ===" function "&& re.symbol ($ ()); var ie = re.symbol ($. iterator)? $. iterator:" _ es6-shim iterator _ "; if (S.Set && typeof (new S. Definir) ["@@ iterator"] === "function") {ie = "@@ iterator"} if (! S.Reflect) {h (S, "Reflect", {}, true)} var ae = S.Reflect; var ue = String; var fe = typeof document === "undefined" ||! Document? Null: document.all; var se = fe == null? Function isNullOrUndefined (e) {return e == null }: function isNullOrUndefinedAndNotDocumentAll (e) {return e == null && e! == fe}; var ce = {Call: function Call (t, r) {var n = arguments.length> 2? argumentos [2]: []; if (! ce.IsCallable (t)) {throw new TypeError (t + "não é uma função")} return e (t, r, n)}, RequireObjectCoercible: function (e, t) {if (se (e) ) {throw new TypeError (t || "Não é possível chamar o método em" + e)} return e}, TypeIsObject:function (e) {if (e === void 0 || e === null || e === true || e === false) {return false} return typeof e === "function" || typeof e === "objeto" || e === fe}, ToObject: function (e, t) {return Object (ce.RequireObjectCoercible (e, t))}, IsCallable: d, IsConstructor: function (e) {return ce.IsCallable (e)}, ToInt32: function (e) {return ce.ToNumber (e) >> 0}, ToUint32: function (e) {return ce.ToNumber (e) >>> 0}, ToNumber : function (e) {if (g (e) === "[Object Symbol]") {throw new TypeError ("Não é possível converter um valor Symbol em um número")} return + e}, ToInteger: function (e) {var t = ce.ToNumber (e); if (X (t)) {return 0} if (t === 0 ||! K (t)) {return t} return (t> 0? 1: - 1) * _ (k (t))}, ToLength: function (e) {var t = ce.ToInteger (e); if (t <= 0) {return 0} if (t> Number.MAX_SAFE_INTEGER) {return Number.MAX_SAFE_INTEGER} return t}, SameValue: function (e,t) {if (e === t) {if (e === 0) {return 1 / e === 1 / t} return true} return X (e) && X (t)}, SameValueZero: function ( e, t) {return e === t || X (e) && X (t)}, IsIterable: function (e) {return ce.TypeIsObject (e) && (typeof e [ie]! == "indefinido" || te (e))}, GetIterator: function (e) {if (te (e)) {return new q (e, "value")} var t = ce.GetMethod (e, ie); if (! ce.IsCallable (t)) {throw new TypeError ("o valor não é iterável")} var r = ce.Call (t, e); if (! ce.TypeIsObject (r)) {throw new TypeError ("ruim iterador ")} return r}, GetMethod: function (e, t) {var r = ce.ToObject (e) [t]; if (se (r)) {return void 0} if (! ce.IsCallable (r )) {throw new TypeError ("Método não chamável:" + t)} return r}, IteratorComplete: function (e) {return !! e.done}, IteratorClose: function (e, t) {var r = ce. GetMethod (e, "return"); if (r === void 0) {return} var n, o; tente {n = ce.Call (r,e)} catch (i) {o = i} if (t) {return} if (o) {throw o} if (! ce.TypeIsObject (n)) {throw new TypeError ("Método de retorno do iterador retornou um não- objeto. ")}}, IteratorNext: function (e) {var t = arguments.length> 1? e.next (arguments [1]): e.next (); if (! ce.TypeIsObject (t)) { lançar novo TypeError ("bad iterator")} return t}, IteratorStep: function (e) {var t = ce.IteratorNext (e); var r = ce.IteratorComplete (t); return r? false: t}, Construir : function (e, t, r, n) {var o = typeof r === "undefined"? e: r; if (! n && ae.construct) {return ae.construct (e, t, o)} var i = o.prototype; if (! ce.TypeIsObject (i)) {i = Object.prototype} var a = O (i); var u = ce.Call (e, a, t); return ce.TypeIsObject (u )? u: a}, SpeciesConstructor: function (e, t) {var r = e.constructor; if (r === void 0) {return t} if (! ce.TypeIsObject (r)) {throw new TypeError ("Construtor ruim")} var n = r [J]; if (se (n)) {return t} if (! Ce.IsConstructor (n)) {lançar novo TypeError ("Bad @@ species")} retornar n}, CreateHTML: function (e, t, r, n) {var o = ce.ToString (e); var i = "< "+ t; if (r! ==" ") {var a = ce.ToString (n); var u = a.replace (/" / g, "& quot;"); i + = "" + r + '= "'+ u +'" '} var f = i + ">"; var s = f + o; return s + "</" + t + ">"}, IsRegExp: função IsRegExp (e) {if (! ce.TypeIsObject (e)) {return false} var t = e [$. match]; if (typeof t! == "undefined") {return !! t} return re.regex (e)}, ToString: function ToString (e ) {return ue (e)}}; if (s && oe) {var le = function defineWellKnownSymbol (e) {if (re.symbol ($ [e])) {return $ [e]} var t = $ ["para "] (" Símbolo. "+ E); Object.defineProperty ($, e, {configurável: falso, enumerável: falso, gravável: falso, valor: t}); retornar t}; if (! Re.symbol ($ .search)) {var pe = le ("search "); var ve = String.prototype.search; h (RegExp.prototype, pe, function search (e) {return ce.Call (ve, e, [this])}); var ye = function search (e ) {var t = ce.RequireObjectCoercible (this); if (! se (e)) {var r = ce.GetMethod (e, pe); if (typeof r! == "undefined") {return ce.Call ( r, e, [t])}} return ce.Call (ve, t, [ce.ToString (e)])}; ne (String.prototype, "search", ye)} if (! re.symbol ( $ .replace)) {var he = le ("replace"); var be = String.prototype.replace; h (RegExp.prototype, he, function replace (e, t) {return ce.Call (be, e, [this, t])}); var ge = substituição de função (e, t) {var r = ce.RequireObjectCoercible (this); if (! se (e)) {var n = ce.GetMethod (e, he) ; if (typeof n! == "undefined") {return ce.Call (n, e, [r, t])}} return ce.Call (be, r, [ce.ToString (e), t]) }; ne (String.prototype, "substituir", ge)} if (! re.symbol ($. split)) {var de = le ("split"); var me = String.prototype.split;h (RegExp.protótipo, de, divisão de função (e, t) {retornar ce.Chamada (me, e, [este, t])}); var Oe = divisão de função (e, t) {var r = ce. RequireObjectCoercible (this); if (! Se (e)) {var n = ce.GetMethod (e, de); if (typeof n! == "undefined") {return ce.Call (n, e, [r, t])}} return ce.Call (me, r, [ce.ToString (e), t])}; ne (String.prototype, "split", Oe)} var we = re.symbol ($. match ); var je = we && function () {var e = {}; e [$. match] = function () {return 42}; return "a" .match (e)! == 42} (); if (! we || je) {var Se = le ("match"); var Te = String.prototype.match; h (RegExp.prototype, Se, function match (e) {return ce.Call (Te, e, [this ])}); var Ie = correspondência de função (e) {var t = ce.RequireObjectCoercible (this); if (! se (e)) {var r = ce.GetMethod (e, Se); if (typeof r! == "undefined") {return ce.Call (r, e, [t])}} return ce.Call (Te, t, [ce.ToString (e)])}; ne (String.prototype, "match ",Ie)}} var Ee = função wrapConstructor (e, t, r) {m.preserveToString (t, e); if (Object.setPrototypeOf) {Object.setPrototypeOf (e, t)} if (s) {l (Object .getOwnPropertyNames (e), função (n) {if (n in W || r [n]) {return} m.proxy (e, n, t)})} else {l (Object.keys (e), função (n) {if (n in W || r [n]) {return} t [n] = e [n]})} t.prototype = e.prototype; m.redefine (e.prototype, "construtor ", t)}; var Pe = function () {return this}; var Ce = function (e) {if (s &&! z (e, J)) {m.getter (e, J, Pe)}}; var Me = function (e, t) {var r = t || função iterator () {return this}; h (e, ie, r); if (! e [ie] && re.symbol (ie)) {e [ie] = r}}; var xe = função createDataProperty (e, t, r) {if (s) {Object.defineProperty (e, t, {configurável: verdadeiro, enumerável: verdadeiro, gravável: verdadeiro, valor: r })} else {e [t] = r}}; var Ne = função createDataPropertyOrThrow (e, t, r) {xe (e, t, r); if (! ce.SameValue (e [t], r) ) {throw new TypeError ("propriedade não é configurável")}}; var Ae = function (e, t, r, n) {if (! ce.TypeIsObject (e)) {throw new TypeError ("Construtor requer` novo`: "+ t.name)} var o = t.prototype; if (! ce.TypeIsObject (o)) {o = r} var i = O (o); for (var a in n) {if (z (n, a)) {var u = n [ a]; h (i, a, u, true)}} return i}; if (String.fromCodePoint && String.fromCodePoint.length! == 1) {var Re = String.fromCodePoint; ne (String, "fromCodePoint", função fromCodePoint (e) {retornar ce.Call (Re, this, argumentos)})} var _e = {fromCodePoint: função fromCodePoint (e) {var t = []; var r; for (var n = 0, o = argumentos .length; n <o; n ++) {r = Número (argumentos [n]); if (! ce.SameValue (r, ce.ToInteger (r)) || r <0 || r> 1114111) {jogar novo RangeError ("Ponto de código inválido" + r)} if (r <65536) {M (t, String.fromCharCode (r))} else {r- = 65536; M (t, String.fromCharCode ((r >> 10 ) +55296)); M (t, String.fromCharCode (r% 1024 + 56320))}} return t.join ("")}, bruto:função raw (e) {var t = ce.ToObject (e, "bad callSite"); var r = ce.ToObject (t.raw, "bad raw value"); var n = r.length; var o = ce .ToLength (n); if (o <= 0) {return ""} var i = []; var a = 0; var u, f, s, c; while (a <o) {u = ce.ToString (a); s = ce.ToString (r [u]); M (i, s); se (a + 1> = o) {quebra} f = a + 1 <argumentos.comprimento? argumentos [a + 1 ]: ""; c = ce.ToString (f); M (i, c); a + = 1} return i.join ("")}}; if (String.raw && String.raw ({raw: {0: "x", 1: "y", comprimento: 2}})! == "xy") {ne (String, "raw", _ e.raw)} b (String, _e); var ke = função repeat ( e, t) {if (t <1) {return ""} if (t% 2) {return repeat (e, t-1) + e} var r = repeat (e, t / 2); return r + r}; var Le = Infinito; var Fe = {repetir: função repetir (e) {var t = ce.ToString (ce.RequireObjectCoercible (this)); var r = ce.ToInteger (e); if (r <0 || r> = Le) {lance novo RangeError ("a contagem de repetição deve ser menor que infinito e não deve ultrapassar o tamanho máximo da string ")} return ke (t, r)}, startWith: function startsWith (e) {var t = ce.ToString (ce.RequireObjectCoercible (this)); ce.IsRegExp (e)) {throw new TypeError ('Não é possível chamar o método "startsWith" com um regex')} var r = ce.ToString (e); var n; if (argumentos.length> 1) {n = argumentos [1]} var o = A (ce.ToInteger (n), 0); retornar C (t, o, o + r.length) === r}, terminaWith: function endsWith (e) {var t = ce .ToString (ce.RequireObjectCoercible (this)); if (ce.IsRegExp (e)) {throw new TypeError ('Não é possível chamar o método "endsWith" com um regex')} var r = ce.ToString (e); var n = t.length; var o; if (argumentos.length> 1) {o = argumentos [1]} var i = tipo de o === "indefinido"? n: ce.ToInteger (o); var a = R ( A (i, 0), n); retornar C (t, ar.length, a) === r}, inclui: a função inclui (e) {if (ce.IsRegExp (e)) {lançar novo TypeError ('"inclui" não aceita um RegExp')} var t = ce.ToString (e); var r; if (argumentos.length> 1) {r = argumentos [1] } return I (this, t, r)! == - 1}, codePointAt: function codePointAt (e) {var t = ce.ToString (ce.RequireObjectCoercible (this)); var r = ce.ToInteger (e); var n = t.length; if (r> = 0 && r <n) {var o = t.charCodeAt (r); var i = r + 1 === n; if (o <55296 || o> 56319 || i) {return o} var a = t.charCodeAt (r + 1); if (a <56320 || a> 57343) {return o} return (o-55296) * 1024 + (a-56320) +65536} }}; if (String.prototype.includes && "a" .includes ("a", Infinity)! == false) {ne (String.prototype, "includes", Fe.includes)} if (String.prototype.startsWith && String .prototype.endsWith) {var De = i (function () {return "/ a /". startsWith (/ a /)}); var ze = a (function () {return "abc" .startsWith ("a" ,Infinity) === false}); if (! De ||! Ze) {ne (String.prototype, "startsWith", Fe.startsWith); ne (String.prototype, "endsWith", Fe.endsWith)}} if (oe) {var qe = a (function () {var e = / a /; e [$. match] = false; return "/ a /". startsWith (e)}); if (! qe) { ne (String.prototype, "startsWith", Fe.startsWith)} var We = a (function () {var e = / a /; e [$. match] = false; return "/ a /". endsWith (e )}); if (! We) {ne (String.prototype, "endsWith", Fe.endsWith)} var Ge = a (function () {var e = / a /; e [$. match] = false; return "/ a /". includes (e)}); if (! Ge) {ne (String.prototype, "includes", Fe.includes)}} b (String.prototype, Fe); var He = [" \ t \ n \ x0B \ f \ r \ xa0 \ u1680 \ u180e \ u2000 \ u2001 \ u2002 \ u2003 "," \ u2004 \ u2005 \ u2006 \ u2007 \ u2008 \ u2009 \ u200a \ u202f \ u205f \ u3000 \ u2028 " , "\ u2029 \ ufeff"]. join (""); var Ve = new RegExp ("(^ [" + He + "] +) | (["+ He +"] + $) "," g "); var Be = function trim () {return ce.ToString (ce.RequireObjectCoercible (this)). Replace (Ve," ")} ; var Ue = ["\ x85", "\ u200b", "\ ufffe"]. join (""); var $ e = new RegExp ("[" + Ue + "]", "g"); var Je = / ^ [- +] 0x [0-9a-f] + $ / i; var Xe = Ue.trim (). Length! == Ue.length; h (String.prototype, "trim", Be, Xe ); var Ke = function (e) {return {value: e, done: arguments.length === 0}}; var Ze = function (e) {ce.RequireObjectCoercible (e); this._s = ce.ToString (e); this._i = 0}; Ze.prototype.next = function () {var e = this._s; var t = this._i; if (typeof e === "indefinido" || t> = e.length) {this._s = void 0; return Ke ()} var r = e.charCodeAt (t); var n, o; if (r <55296 || r> 56319 || t + 1 === e.length) {o = 1} else {n = e.charCodeAt (t + 1); o = n <56320 || n> 57343? 1: 2} this._i = t + o; retornar Ke (e. substr (t, o))}; Me (Ze.protótipo); Me (String.protótipo, função () {retornar novo Ze (este)}); var Ye = {de: função de (e) {var r = isto; var n; if (argumentos.comprimento> 1) {n = argumentos [1]} var o, i; if (typeof n === "undefined") {o = false} else {if (! ce.IsCallable (n)) {throw new TypeError ("Array.from : quando fornecido, o segundo argumento deve ser uma função ")} if (arguments.length> 2) {i = arguments [2]} o = true} var a = typeof (te (e) || ce.GetMethod (e , isto é))! == "indefinido"; var u, f, s; if (a) {f = ce.IsConstructor (r)? Objeto (novo r): []; var c = ce.GetIterator (e) ; var l, p; s = 0; while (true) {l = ce.IteratorStep (c); if (l === false) {break} p = l.value; try {if (o) {p = typeof i === "indefinido"? n (p, s): t (n, i, p, s)} f [s] = p} catch (v) {ce.IteratorClose (c, true); lance v } s + = 1} u = s} else {var y = ce.ToObject (e); u = ce.ToLength (y.length); f = ce.IsConstructor (r)? Objeto (novo r (u)): novo Array (u); var h; para (s = 0; s <u; ++ s) {h = y [s];if (o) {h = typeof i === "indefinido"? n (h, s): t (n, i, h, s)} Ne (f, s, h)}} f.length = u; return f}, de: função de () {var e = argumentos.comprimento; var t = isto; var n = r (t) ||! ce.IsCallable (t)? new Array (e): ce.Construct ( t, [e]); para (var o = 0; o <e; ++ o) {Ne (n, o, argumentos [o])} n.comprimento = e; retornar n}}; b (Matriz, Ye); Ce (Matriz); q = função (e, t) {this.i = 0; this.array = e; this.kind = t}; b (q.prototype, {next: function () {var e = this.i; var t = this.array; if (! (this instanceof q)) {throw new TypeError ("Não é um ArrayIterator")} if (typeof t! == "undefined") {var r = ce .ToLength (t.length); for (; e <r; e ++) {var n = this.kind; var o; if (n === "chave") {o = e} else if (n === "valor") {o = t [e]} else if (n === "entrada") {o = [e, t [e]]} this.i = e + 1; retornar Ke (o)}} this.array = void 0; return Ke ()}}); Me (q.protótipo); var Qe = Array.of === Ye.of || function () {var e = function Foo (e) {this .comprimento = e}; e.protótipo = [];var t = Array.of.apply (e, [1,2]); retornar t instância de e && t.length === 2} (); if (! Qe) {ne (Array, "de", Ye.of) } var et = {copyWithin: função copyWithin (e, t) {var r = ce.ToObject (this); var n = ce.ToLength (r.length); var o = ce.ToInteger (e); var i = ce.ToInteger (t); var a = o <0? A (n + o, 0): R (o, n); var u = i <0? A (n + i, 0): R (i, n); var f; if (argumentos.comprimento> 2) {f = argumentos [2]} var s = tipo de f === "indefinido"? n: ce.ToInteger (f); var c = s <0? A (n + s, 0): R (s, n); var l = R (cu, na); var p = 1; se (u <a && a <u + l) {p = -1; u + = l -1; a + = l-1} while (l> 0) {if (u in r) {r [a] = r [u]} else {delete r [a]} u + = p; a + = p; l - = 1} retorno r}, preencher: função preencher (e) {var t; if (argumentos.comprimento> 1) {t = argumentos [1]} var r; se (argumentos.comprimento> 2) {r = argumentos [2]} var n = ce.ToObject (this); var o = ce.ToLength (n.length); t = ce.ToInteger (typeof t === "indefinido"? 0: t); r = ce. ToInteger (typeof r === "indefinido "? o: r); var i = t <0? A (o + t, 0): R (t, o); var a = r <0? o + r: r; para (var u = i ; u <o && u <a; ++ u) {n [u] = e} return n}, find: função find (e) {var r = ce.ToObject (this); var n = ce.ToLength (r. comprimento); if (! ce.IsCallable (e)) {throw new TypeError ("Array # find: predicado deve ser uma função")} var o = argumentos.length> 1? argumentos [1]: nulo; for (var i = 0, a; i <n; i ++) {a = r [i]; if (o) {if (t (e, o, a, i, r)) {return a}} else if (e ( a, i, r)) {return a}}}, findIndex: function findIndex (e) {var r = ce.ToObject (this); var n = ce.ToLength (r.length); if (! ce.IsCallable (e)) {lançar novo TypeError ("Array # findIndex: predicado deve ser uma função")} var o = argumentos.length> 1? argumentos [1]: nulo; for (var i = 0; i <n; i ++ ) {if (o) {if (t (e, o, r [i], i, r)) {return i}} else if (e (r [i], i, r)) {return i}} return-1}, keys: function keys () {return new q (this, "key")}, values:function values ​​() {return new q (this, "value")}, entries: function entries () {return new q (this, "entry")}}; if (Array.prototype.keys &&! ce.IsCallable ([ 1] .keys (). Next)) {delete Array.prototype.keys} if (Array.prototype.entries &&! Ce.IsCallable ([1] .entries (). Next)) {delete Array.prototype.entries} se (Array.prototype.keys && Array.prototype.entries &&! Array.prototype.values ​​&& Array.prototype [ie]) {b (Array.prototype, {valores: Array.prototype [ie]}); if (re.symbol ($. Unscopables )) {Array.prototype [$. Unscopables] .values ​​= true}} if (c && Array.prototype.values ​​&& Array.prototype.values.name! == "valores") {var tt = Array.prototype.values; ne (Array .protótipo, "valores", valores de função () {retornar ce.Chamada (tt, este, argumentos)}); h (Matriz.protótipo, ou seja, Matriz.protótipo.valores, verdadeiro)} b (Matriz.protótipo, et );if (1 / [true] .indexOf (true, -0) <0) {h (Array.prototype, "indexOf", função indexOf (e) {var t = E (this, argumentos); if (t == = 0 && 1 / t <0) {return 0} return t}, true)} Me (Array.prototype, function () {return this.values ​​()}); if (Object.getPrototypeOf) {Me (Object.getPrototypeOf ( [] .values ​​()))} var rt = function () {return a (function () {return Array.from ({length: -1}). length === 0})} (); var nt = function () {var e = Array.from ([0] .entries ()); return e.length === 1 && r (e [0]) && e [0] [0] === 0 && e [0] [1 ] === 0} (); if (! Rt ||! Nt) {ne (Array, "de", Ye.from)} var ot = function () {return a (function () {return Array.from ([0], void 0)})} (); if (! Ot) {var it = Array.from; ne (Array, "de", função de (e) {if (argumentos.comprimento> 1 && tipo de argumentos [ 1]! == "undefined") {return ce.Call (it, this, arguments)} else {return t (it, this, e)}})} var at = - (Math.pow (2,32) -1); var ut = function (e, r) {var n = {length: at}; n [r? (N.length >>> 0) -1: 0] = true; return a (function () {t (e, n, function () {lançar new RangeError ("não deve chegar aqui")}, []); retornar verdadeiro})}; if (! ut (Array.prototype.forEach)) {var ft = Array.prototype.forEach; ne (Array.prototype, "forEach", função forEach (e) {return ce.Call (ft, this.length> = 0? this: [], arguments)}, true)} if (! ut (Array.prototype.map)) {var st = Array.prototype.map; ne (Array.prototype, "map", mapa de função (e) {return ce.Call (st, this.length> = 0? This: [], arguments)}, true)} if (! Ut (Array.prototype.filter)) {var ct = Array.prototype.filter; ne (Array.prototype, "filtro", filtro de função (e ) {return ce.Call (ct, this.length> = 0? this: [], arguments)}, true)} if (! ut (Array.prototype.some)) {var lt = Array.prototype.some; ne (Array.prototype, "some", function some (e) {return ce.Call (lt, this.length> = 0? This: [], arguments)}, true)} if (! Ut (Array.prototype.every)) {var pt = Array.prototype.every; ne (Array.prototype , "cada", função cada (e) {retornar ce.Chamada (pt, este.comprimento> = 0? este: [], argumentos)}, verdadeiro)} if (! ut (Array.prototype.reduce)) { var vt = Array.prototype.reduce; ne (Array.prototype, "reduzir", função reduzir (e) {retornar ce.Chamada (vt, this.length> = 0? this: [], argumentos)}, verdadeiro) } if (! ut (Array.prototype.reduceRight, true)) {var yt = Array.prototype.reduceRight; ne (Array.prototype, "reduceRight", função reduceRight (e) {return ce.Call (yt, this. comprimento> = 0? isto: [], argumentos)}, verdadeiro)} var ht = Número ("0o10")! == 8; var bt = Número ("0b10")! == 2; var gt = y ( Ue, função (e) {return Number (e + 0 + e) ​​=== 0}); if (ht || bt || gt) {var dt = Number; var mt = / ^ 0b [01] + $ / i; var Ot = / ^ 0o [0-7] + $ / i; var wt = mt.test.bind (mt); var jt = Ot.test.bind (Ot);var St = function (e) {var t; if (typeof e.valueOf === "function") {t = e.valueOf (); if (re.primitive (t)) {return t}} if (typeof e.toString === "função") {t = e.toString (); if (re.primitive (t)) {return t}} lance novo TypeError ("Sem valor padrão")}; var Tt = $ e .test.bind ($ e); var It = Je.test.bind (Je); var Et = função () {var e = função Número (t) {var r; if (argumentos.comprimento> 0) {r = re.primitivo (t)? t: St (t, "número")} else {r = 0} if (typeof r === "string") {r = ce.Call (Be, r); if ( wt (r)) {r = parseInt (C (r, 2), 2)} else if (jt (r)) {r = parseInt (C (r, 2), 8)} else if (Tt (r) || It (r)) {r = NaN}} var n = this; var o = a (função () {dt.prototype.valueOf.call (n); retornar verdadeiro}); if (n instância de e &&! O ) {return new dt (r)} return dt (r)}; return e} (); Ee (dt, Et, {}); b (Et, {NaN: dt.NaN, MAX_VALUE: dt.MAX_VALUE, MIN_VALUE : dt.MIN_VALUE, NEGATIVE_INFINITY: dt.NEGATIVE_INFINITY, POSITIVE_INFINITY: dt.POSITIVE_INFINITY}); Number = Et; m.redefine (S, "Number", Et)} var Pt = Math.pow (2,53) -1; b (Number, {MAX_SAFE_INTEGER: Pt, MIN_SAFE_INTEGER: -Pt, EPSILON : 2.220446049250313e-16, parseInt: S.parseInt, parseFloat: S.parseFloat, isFinite: K, isInteger: function isInteger (e) {return K (e) && ce.ToInteger (e) === e}, isSafeInteger: function isSafeInteger (e) {return Number.isInteger (e) && k (e) <= Number.MAX_SAFE_INTEGER}, isNaN: X}); h (Number, "parseInt", S.parseInt, Number.parseInt! == S.parseInt ); if ([, 1] .find (function () {return true}) === 1) {ne (Array.prototype, "find", et.find)} if ([, 1] .findIndex (function () {return true})! == 0) {ne (Array.prototype, "findIndex", et.findIndex)} var Ct = Function.bind.call (Function.bind, Object.prototype.propertyIsEnumerable); var Mt = função garantirEnumerável (e, t) {if (s && Ct (e, t)) {Object.defineProperty (e, t, {enumerable:falso})}}; var xt = função sliceArgs () {var e = Número (este); var t = argumentos.length; var r = te; var n = novo Array (r <0? 0: r); para (var o = e; o <t; ++ o) {n [oe] = argumentos [o]} retornar n}; var Nt = função assignTo (e) {retornar função assignToSource (t, r) {t [r ] = e [r]; retornar t}}; var At = função (e, t) {var r = n (Object (t)); var o; if (ce.IsCallable (Object.getOwnPropertySymbols)) {o = v (Object.getOwnPropertySymbols (Object (t)), Ct (t))} retorna p (P (r, o || []), Nt (t), e)}; var Rt = {atribuir: função (e , t) {var r = ce.ToObject (e, "Não é possível converter indefinido ou nulo em objeto"); retornar p (ce.Call (xt, 1, argumentos), At, r)}, is: function is (e , t) {return ce.SameValue (e, t)}}; var _t = Object.assign && Object.preventExtensions && function () {var e = Object.preventExtensions ({1: 2}); tente {Object.assign (e, " xy ")} catch (t) {return e [1] ===" y "}} (); if (_t) {ne (Object," assign ", Rt.atribuir)} b (Object, Rt); if (s) {var kt = {setPrototypeOf: function (e, r) {var n; var o = function (e, t) {if (! ce.TypeIsObject (e) ) {throw new TypeError ("não é possível definir protótipo em um objeto não")} if (! (t === null || ce.TypeIsObject (t))) {throw new TypeError ("só pode definir protótipo para um objeto ou nulo "+ t)}}; var i = função (e, r) {o (e, r); t (n, e, r); retornar e}; tente {n = e.getOwnPropertyDescriptor (e.prototype , r) .set; t (n, {}, nulo)} catch (a) {if (e.prototype! == {} [r]) {return} n = function (e) {this [r] = e}; i.polyfill = i (i ({}, null), e.prototype) instanceof e} return i} (Object, "__ proto __")}; b (Object, kt)} if (Object.setPrototypeOf && Object.getPrototypeOf && Object .getPrototypeOf (Object.setPrototypeOf ({}, null))! == null && Object.getPrototypeOf (Object.create (null)) === null) {(função () {var e = Object.create (null); var t = Object.getPrototypeOf; var r = Object.setPrototypeOf;Object.getPrototypeOf = function (r) {var n = t (r); retornar n === e? Null: n}; Object.setPrototypeOf = function (t, n) {var o = n === null? E : n; return r (t, o)}; Object.setPrototypeOf.polyfill = false}) ()} var Lt =! i (function () {return Object.keys ("foo")}); if (! Lt ) {var Ft = Object.keys; ne (Object, "keys", teclas de função (e) {return Ft (ce.ToObject (e))}); n = Object.keys} var Dt = i (function () {return Object.keys (/ a / g)}); if (Dt) {var zt = Object.keys; ne (Objeto, "chaves", teclas de função (e) {if (re.regex (e)) { var t = []; for (var r in e) {if (z (e, r)) {M (t, r)}} return t} return zt (e)}); n = Object.keys} se (Object.getOwnPropertyNames) {var qt =! I (function () {return Object.getOwnPropertyNames ("foo")}); if (! Qt) {var Wt = typeof window === "object"? Object.getOwnPropertyNames ( janela): []; var Gt = Object.getOwnPropertyNames; ne (Object, "getOwnPropertyNames",função getOwnPropertyNames (e) {var t = ce.ToObject (e); if (g (t) === "[janela do objeto]") {try {return Gt (t)} catch (r) {return P ([ ], Wt)}} return Gt (t)})}} if (Object.getOwnPropertyDescriptor) {var Ht =! I (function () {return Object.getOwnPropertyDescriptor ("foo", "bar")}); if ( ! Ht) {var Vt = Object.getOwnPropertyDescriptor; ne (Object, "getOwnPropertyDescriptor", função getOwnPropertyDescriptor (e, t) {return Vt (ce.ToObject (e), t)})}} if (Object.seal) { var Bt =! i (function () {return Object.seal ("foo")}); if (! Bt) {var Ut = Object.seal; ne (Object, "selo", função seal (e) {if (! ce.TypeIsObject (e)) {return e} return Ut (e)})}} if (Object.isSealed) {var $ t =! i (function () {return Object.isSealed ("foo")} ); if (! $ t) {var Jt = Object.isSealed; ne (Object, "isSealed", função isSealed (e) {if (! ce.TypeIsObject (e)) {return true} return Jt (e)})}} if (Object.freeze) {var Xt =! I (function () {return Object.freeze ("foo")}); if (! Xt) {var Kt = Object.freeze; ne (Object, "freeze", função freeze (e) {if (! Ce.TypeIsObject (e)) {return e} return Kt (e)})}} if (Object .isFrozen) {var Zt =! i (function () {return Object.isFrozen ("foo")}); if (! Zt) {var Yt = Object.isFrozen; ne (Object, "isFrozen", função isFrozen ( e) {if (! ce.TypeIsObject (e)) {return true} return Yt (e)})}} if (Object.preventExtensions) {var Qt =! i (function () {return Object.preventExtensions ("foo ")}); if (! Qt) {var er = Object.preventExtensions; ne (Object," preventExtensions ", função preventExtensions (e) {if (! ce.TypeIsObject (e)) {return e} return er (e )})}} if (Object.isExtensible) {var tr =! i (function () {return Object.isExtensible ("foo")}); if (! tr) {var rr = Object.isExtensible;ne (Object, "isExtensible", function isExtensible (e) {if (! ce.TypeIsObject (e)) {return false} return rr (e)})}} if (Object.getPrototypeOf) {var nr =! i ( function () {return Object.getPrototypeOf ("foo")}); if (! nr) {var or = Object.getPrototypeOf; ne (Object, "getPrototypeOf", função getPrototypeOf (e) {return or (ce.ToObject ( e))})}} var ir = s && function () {var e = Object.getOwnPropertyDescriptor (RegExp.prototype, "flags"); return e && ce.IsCallable (e.get)} (); if (s &&! ir) { var ar = function flags () {if (! ce.TypeIsObject (this)) {throw new TypeError ("Método chamado em tipo incompatível: deve ser um objeto.")} var e = ""; if (this.global) {e + = "g"} if (this.ignoreCase) {e + = "i"} if (this.multiline) {e + = "m"} if (this.unicode) {e + = "u"} if (this. pegajoso) {e + = "y"} return e}; m.getter (RegExp.prototype, "flags", ar)} var ur = s && a (function () {return String (new RegExp (/ a / g, "i")) === "/ a / i"}); var fr = oe && s && function () {var e = /. /; e [$. match] = false; return RegExp (e) === e} (); var sr = a (function () {return RegExp.prototype.toString.call ( {fonte: "abc"}) === "/ abc /"}); var cr = sr && a (function () {return RegExp.prototype.toString.call ({fonte: "a", sinalizadores: "b"} ) === "/ a / b"}); if (! sr ||! cr) {var lr = RegExp.prototype.toString; h (RegExp.prototype, "toString", função toString () {var e = ce.RequireObjectCoercible (this); if (re.regex (e)) {return t (lr, e)} var r = ue (e.source); var n = ue (e.flags); return "/" + r + "/" + n}, true); m.preserveToString (RegExp.prototype.toString, lr)} if (s && (! ur || fr)) {var pr = Object.getOwnPropertyDescriptor (RegExp.prototype, "flags "). get; var vr = Object.getOwnPropertyDescriptor (RegExp.prototype," source ") || {}; var yr = function () {return this.source}; var hr = ce.IsCallable (vr.get) ? vr.get: yr; var br = RegExp; var gr = function () {retornar função RegExp (e, t) {var r = ce.IsRegExp (e); var n = esta instância de RegExp; if (! n && r && tipo de t === "undefined" && e.constructor === RegExp) {return e} var o = e; var i = t; if (re.regex (e)) {o = ce.Call (hr, e); i = typeof t === "undefined"? ce.Call (pr, e): t; retornar nova RegExp (o, i)} else if (r) {o = e.source; i = typeof t === " undefined "? e.flags: t} return new br (e, t)}} (); Ee (br, gr, {$ input: true}); RegExp = gr; m.redefine (S," RegExp ", gr)} if (s) {var dr = {input: "$ _", lastMatch: "$ &", lastParen: "$ +", leftContext: "$` ", rightContext:" $ '"}; l ( n (dr), função (e) {if (e em RegExp &&! (dr [e] em RegExp)) {m.getter (RegExp, dr [e], função get () {retornar RegExp [e]})}})} Ce (RegExp); var mr = 1 / Número. EPSILON; var Or = function roundTiesToEven (e) {return e + mr-mr}; var wr = Math.pow (2, -23); var jr = Math.pow (2.127) * (2-wr); var Sr = Math.pow (2, -126); var Tr = Math.E; var Ir = Math.LOG2E; var Er = Math.LOG10E; var Pr = Number.prototype.clz; excluir Number.prototype.clz; var Cr = {acosh: function acosh (e) {var t = Number (e); if (X (t) || e <1) {return NaN} if (t === 1) {return 0} if (t = == Infinito) {return t} var r = 1 / (t * t); if (t <2) {return Y (t-1 + D (1-r) * t)} var n = t / 2; retornar Y (n + D (1-r) * n-1) + 1 / Ir}, asinh: função asinh (e) {var t = Número (e); if (t === 0 ||! T ( t)) {return t} var r = k (t); var n = r * r; var o = Z (t); if (r <1) {return o * Y (r + n / (D (n +1) +1))} return o * (Y (r / 2 + D (1 + 1 / n) * r / 2-1) + 1 / Ir)}, atanh: função atanh (e) {var t = Número (e); if (t === 0) {return t} if (t === - 1) {return-Infinity} if (t === 1) {return Infinity} if (X (t) || t <-1 || t> 1) {return NaN} var r = k (t); return Z (t) * Y (2 * r / (1-r)) / 2}, cbrt: function cbrt (e) { var t = Número (e); if (t === 0) {return t} var r = t <0; var n; if (r) {t = -t} if (t === Infinito) {n = Infinito} else {n = L (F (t) / 3); n = (t / (n * n) + 2 * n) / 3} retornar r? -N: n}, clz32: função clz32 (e ) {var t = Número (e); var r = ce.ToUint32 (t); se (r === 0) {retornar 32} retornar Pr? ce.Chamada (Pr, r): 31 -_ (F ( r + .5) * Ir)}, cosh: função cosh (e) {var t = Número (e); if (t === 0) {return 1} if (X (t)) {return NaN} if ( ! T (t)) {retornar infinito} var r = L (k (t) -1); retornar (r + 1 / (r * Tr * Tr)) * (Tr / 2)}, expm1: função expm1 ( e) {var t = Número (e); if (t === - Infinito) {return-1} if (! T (t) || t === 0) {return t} if (k (t) > .5) {return L (t) -1} var r = t; var n = 0; var o = 1; enquanto (n + r! == n) {n + = r; o + = 1; r * = t / o} retornar n}, hipoteca: hipoteca de função (e, t) {var r = 0; var n = 0; para (var o = 0; o <argumentos.comprimento; ++ o) {var i = k (Número (argumentos [o])); if (n <i) {r * = n / i * (n / i); r + = 1; n = i} else {r + = i> 0? I / n * (no):i}} return n === Infinity? Infinity: n * D (r)}, log2: função log2 (e) {return F (e) * Ir}, log10: função log10 (e) {return F (e) * Er}, log1p: Y, sinal: Z, sinh: função sinh (e) {var t = Número (e); if (! T (t) || t === 0) {return t} var r = k (t); if (r <1) {var n = Math.expm1 (r); retornar Z (t) * n * (1 + 1 / (n + 1)) / 2} var o = L (r -1); retornar Z (t) * (o-1 / (o * Tr * Tr)) * (Tr / 2)}, tanh: função tanh (e) {var t = Número (e); if (X (t) || t === 0) {return t} if (t> = 20) {return 1} if (t <= - 20) {return-1} return (Math.expm1 (t) -Math. expm1 (-t)) / (L (t) + L (-t))}, trunc: função trunc (e) {var t = Número (e); retornar t <0? -_ (- t): _ (t)}, imul: função imul (e, t) {var r = ce.ToUint32 (e); var n = ce.ToUint32 (t); var o = r >>> 16 & 65535; var i = r & 65535; var a = n >>> 16 & 65535; var u = n & 65535; retornar i * u + (o * u + i * a <<16> >> 0) | 0}, fround: função fround (e) {var t = Number ( e);if (t === 0 || t === Infinito || t === - Infinito || X (t)) {return t} var r = Z (t); var n = k (t); if (n <Sr) {return r * Or (n / Sr / wr) * Sr * wr} var o = (1 + wr / Number.EPSILON) * n; var i = o- (on); if (i> jr || X (i)) {return r * Infinity} return r * i}}; var Mr = função dentro de ULPDistance (e, t, r) {return k (1-e / t) /Number.EPSILON <(r || 8)}; b (Math, Cr); h (Math, "sinh", Cr.sinh, Math.sinh (710) === Infinity); h (Math, "cosh", Cr.cosh, Math .cosh (710) === Infinito); h (Math, "log1p", Cr.log1p, Math.log1p (-1e-17)! == - 1e-17); h (Math, "asinh", Cr .asinh, Math.asinh (-1e7)! == - Math.asinh (1e7)); h (Math, "asinh", Cr.asinh, Math.asinh (1e300) === Infinity); h (Math, "atanh", Cr.atanh, Math.atanh (1e-300) === 0); h (Math, "tanh", Cr.tanh, Math.tanh (-2e-17)! == - 2e-17 );jr || X (i)) {return r * Infinity} return r * i}}; var Mr = função dentro de ULPDistance (e, t, r) {return k (1-e / t) /Number.EPSILON <(r || 8)}; b (Math, Cr); h (Math, "sinh", Cr.sinh, Math.sinh (710) === Infinity); h (Math, "cosh", Cr.cosh, Math .cosh (710) === Infinito); h (Math, "log1p", Cr.log1p, Math.log1p (-1e-17)! == - 1e-17); h (Math, "asinh", Cr .asinh, Math.asinh (-1e7)! == - Math.asinh (1e7)); h (Math, "asinh", Cr.asinh, Math.asinh (1e300) === Infinity); h (Math, "atanh", Cr.atanh, Math.atanh (1e-300) === 0); h (Math, "tanh", Cr.tanh, Math.tanh (-2e-17)! == - 2e-17 );jr || X (i)) {return r * Infinity} return r * i}}; var Mr = função dentro de ULPDistance (e, t, r) {return k (1-e / t) /Number.EPSILON <(r || 8)}; b (Math, Cr); h (Math, "sinh", Cr.sinh, Math.sinh (710) === Infinity); h (Math, "cosh", Cr.cosh, Math .cosh (710) === Infinito); h (Math, "log1p", Cr.log1p, Math.log1p (-1e-17)! == - 1e-17); h (Math, "asinh", Cr .asinh, Math.asinh (-1e7)! == - Math.asinh (1e7)); h (Math, "asinh", Cr.asinh, Math.asinh (1e300) === Infinity); h (Math, "atanh", Cr.atanh, Math.atanh (1e-300) === 0); h (Math, "tanh", Cr.tanh, Math.tanh (-2e-17)! == - 2e-17 );== - 1e-17); h (Math, "asinh", Cr.asinh, Math.asinh (-1e7)! == - Math.asinh (1e7)); h (Math, "asinh", Cr.asinh , Math.asinh (1e300) === Infinity); h (Math, "atanh", Cr.atanh, Math.atanh (1e-300) === 0); h (Math, "tanh", Cr.tanh , Math.tanh (-2e-17)! == - 2e-17);== - 1e-17); h (Math, "asinh", Cr.asinh, Math.asinh (-1e7)! == - Math.asinh (1e7)); h (Math, "asinh", Cr.asinh , Math.asinh (1e300) === Infinity); h (Math, "atanh", Cr.atanh, Math.atanh (1e-300) === 0); h (Math, "tanh", Cr.tanh , Math.tanh (-2e-17)! == - 2e-17);
h (Math, "acosh", Cr.acosh, Math.acosh (Number.MAX_VALUE) === Infinity); h (Math, "acosh", Cr.acosh,! Mr (Math.acosh (1 + Number.EPSILON ), Math.sqrt (2 * Number.EPSILON))); h (Math, "cbrt", Cr.cbrt,! Mr (Math.cbrt (1e-300), 1e-100)); h (Math, " sinh ", Cr.sinh, Math.sinh (-2e-17)! == - 2e-17); var xr = Math.expm1 (10); h (Math," expm1 ", Cr.expm1, xr> 22025.465794806718 || xr <22025.465794806718); var Nr = Math.round; var Ar = Math.round (.5-Number.EPSILON / 4) === 0 && Math.round (-. 5 + Number.EPSILON / 3,99) === 1; var Rr = mr + 1; var _r = 2 * mr-1; var kr = [Rr, _r] .every (função (e) {return Math.round (e) === e}); h ( Matemática, "round", função round (e) {var t = _ (e); var r = t === - 1? -0: t + 1; return et <.5? T: r} ,! Ar ||! kr); m.preserveToString (Math.round, Nr); var Lr = Math.imul; if (Math.imul (4294967295,5)! == - 5) {Math.imul = Cr.imul; m .preserveToString (Math.imul, Lr)} if (Math.imul.comprimento! == 2) {ne (Matemática, "imul", função imul (e, t) {retornar ce.Chamada (Lr, Matemática, argumentos)})} var Fr = função () {var e = S.setTimeout ; if (typeof e! == "function" && typeof e! == "object") {return} ce.IsPromise = function (e) {if (! ce.TypeIsObject (e)) {return false} if (typeof e ._promise === "undefined") {return false} return true}; var r = function (e) {if (! ce.IsConstructor (e)) {throw new TypeError ("Construtor de promessa incorreta")} var t = this; var r = function (e, r) {if (t.resolve! == void 0 || t.reject! == void 0) {throw new TypeError ("Implementação da má promessa!")} t.resolve = e; t.reject = r}; t.resolve = void 0; t.reject = void 0; t.promise = new e (r); if (! (ce.IsCallable (t.resolve) && ce.IsCallable (t .reject))) {throw new TypeError ("Construtor de promessa incorreta")}}; var n; if (typeof window! == "undefined" && ce.IsCallable (window.postMessage)) {n = function () {var e = []; var t = "zero-timeout-message"; var r = function (r) {M (e, r); window.postMessage (t, "* ")}; var n = function (r) {if (r.source === window && r.data === t) {r.stopPropagation (); if (e.length === 0) {return} var n = N (e); n ()}}; window.addEventListener ("mensagem", n, verdadeiro); retornar r}} var o = função () {var e = S.Promise; var t = e && e.resolve && e. resolve (); return t && function (e) {return t.then (e)}}; var i = ce.IsCallable (S.setImmediate)? S.setImmediate: typeof process === "objeto" && process.nextTick? processo. nextTick: o () || (ce.IsCallable (n)? n (): function (t) {e (t, 0)}); var a = function (e) {return e}; var u = function ( e) {lançar e}; var f = 0; var s = 1; var c = 2; var l = 0; var p = 1; var v = 2; var y = {}; var h = função (e, t, r) {i (função () {g (e, t, r)})}; var g = função (e, t, r) {var n, o; if (t === y) {retorno e (r)} tente {n = e (r); o = t.resolver} catch (i) {n = i; o = t.reject} o (n)}; var d = função (e, t) {var r = e._promise; var n = r.reactionLength; if (n > 0) {h (r.fulfillReactionHandler0, r.reactionCapability0, t); r.fulfillReactionHandler0 = vazio 0; r.rejectReactions0 = vazio 0; r.reactionCapability0 = vazio 0; if (n> 1) {para (var o = 1, i = 0; o <n; o ++,i + = 3) {h (r [i + l], r [i + v], t); e [i + l] = vazio 0; e [i + p] = vazio 0; e [i + v] = vazio 0}}} r.result = t; r.state = s; r.reactionLength = 0}; var m = função (e, t) {var r = e._promise; var n = r.reactionLength; se (n> 0) {h (r.rejectReactionHandler0, r.reactionCapability0, t); r.fulfillReactionHandler0 = vazio 0; r.rejectReactions0 = vazio 0; r.reactionCapability0 = vazio 0; if (n> 1) {para (var o = 1, i = 0; o <n; o ++, i + = 3) {h (r [i + p], r [i + v], t); e [i + l] = vazio 0; e [ i + p] = vazio 0; e [i + v] = vazio 0}}} r.resultado = t; r.estado = c; r.reactionLength = 0}; var O = função (e) {var t = false; var r = function (r) {var n; if (t) {return} t = true; if (r === e) {return m (e, new TypeError ("Auto-resolução"))} if ( ! ce.TypeIsObject (r)) {return d (e, r)} try {n = r.then} catch (o) {return m (e, o)} if (! ce.IsCallable (n)) {return d (e, r)} i (função () {j (e, r, n)})}; var n = função (r) {if (t) {retorno} t = verdadeiro; retorno m (e, r )}; retornar {resolver: r, rejeitar: n}}; var w = função (e, r, n,o) {if (e === I) {t (e, r, n, o, y)} else {t (e, r, n, o)}}; var j = função (e, t, r ) {var n = O (e); var o = n.resolver; var i = n.rejeitar; tentar {w (r, t, o, i)} catch (a) {i (a)}}; var T, I; var E = function () {var e = function Promise (t) {if (! (This instanceof e)) {throw new TypeError ('Constructor Promise requer "new"')} if (this && this._promise) {throw new TypeError ("Bad construction")} if (! ce.IsCallable (t)) {throw new TypeError ("not a valid resolver")} var r = Ae (this, e, T, {_ promessa: {result : vazio 0, estado: f, comprimento da reação: 0, cumprimentoReactionHandler0: vazio 0, rejeitarReaçãoHandler0: vazio 0, capacidade de reação0: vazio 0}}); var n = O (r); var o = n.rejeitar; tentar {t (n .resolve, o)} catch (i) {o (i)} return r}; return e} (); T = E.prototype; var P = function (e, t, r, n) {var o = false ; função de retorno (i) {if (o) {return} o = true; t [e] = i; if (- n.contagem === 0) {var a = r.resolve; a (t)} }}; var C = função (e, t, r) {var n = e.iterator; var o = []; var i = {contagem: 1}; var a, u; var f = 0; while (true) {try {a = ce.IteratorStep (n); if (a === false ) {e.done = true; break} u = a.value} catch (s) {e.done = true; lance s} o [f] = void 0; var c = t.resolve (u); var l = P (f, o, r, i); i.contagem + = 1; w (c.então, c, l, r.rejeitar); f + = 1} if (- i.contagem === 0) { var p = r.resolve; p (o)} retornar r.promissão}; var x = função (e, t, r) {var n = e.iterador; var o, i, a; enquanto (verdadeiro) {tentar {o = ce.IteratorStep (n); if (o === false) {e.done = true; break} i = o.value} catch (u) {e.done = true; lance u} a = t .resolver (i); w (a.então, a, r.resolver, r.rejeitar)} retornar r.promissão}; b (E, {todos: função todos (e) {var t = isto; se (! ce.TypeIsObject (t)) {throw new TypeError ("Promise is not object")} var n = new r (t); var o, i; try {o = ce.GetIterator (e); i = {iterator: o, feito: falso}; retornar C (i, t, n)} catch (a) {var u = a; if (i &&! i.done) {try {ce.IteratorClose (o, true)} catch (f ) {u = f}} var s = n.rejeitar; s (u); retornar n.promessa}}, raça:function race (e) {var t = this; if (! ce.TypeIsObject (t)) {throw new TypeError ("Promise is not object")} var n = new r (t); var o, i; try { o = ce.GetIterator (e); i = {iterator: o, done: false}; return x (i, t, n)} catch (a) {var u = a; if (i &&! i.done) { tente {ce.IteratorClose (o, true)} catch (f) {u = f}} var s = n.reject; s (u); return n.promise}}, rejeite: função rejeite (e) {var t = this; if (! ce.TypeIsObject (t)) {throw new TypeError ("Construtor de promessa incorreta")} var n = new r (t); var o = n.reject; o (e); return n.promise }, resolve: function resolve (e) {var t = this; if (! ce.TypeIsObject (t)) {throw new TypeError ("Construtor de promessa incorreta")} if (ce.IsPromise (e)) {var n = e.construtor; if (n === t) {return e}} var o = new r (t); var i = o.resolve; i (e); return o.promise}}); b (T, {"catch": function (e) {return this.then (null, e)}, then: function then (e, t) {var n = this; if (! ce.IsPromise (n)) {throw new TypeError ("não é uma promessa")} var o = ce.SpeciesConstructor (n, E); var i; var b = arguments.length> 2 && arguments [2] === y; if ( b && o === E) {i = y} else {i = new r (o)} var g = ce.IsCallable (e)? e: a; var d = ce.IsCallable (t)? t: u; var m = n._promise; var O; if (m.state === f) {if (m.reactionLength === 0) {m.fulfillReactionHandler0 = g; m.rejectReactionHandler0 = d; m.reactionCapability0 = i} else {var w = 3 * (m.reactionLength-1); m [w + l] = g; m [w + p] = d; m [w + v] = i} m.reactionLength + = 1} else if ( m.estado === s) {O = m.resultado; h (g, i, O)} else if (m.estado === c) {O = m.resultado; h (d, i, O) } else {lançar novo TypeError ("estado de promessa inesperado")} return i.promise}}); y = new r (E); I = T.then; return E} (); if (S.Promise) {delete S.Promise.accept; deletar S.Promise.defer; deletar S.Promise.prototype.chain} if (typeof Fr === "função") {b (S, {Promise: Fr}); var Dr = w ( S.Promise, função (e) {return e.resolve (42) .then (function () {}) instanceof e}); var zr =! i (function () {return S.Promise.reject (42) .then (null, 5) .then (null, W )}); var qr = i (function () {return S.Promise.call (3, W)}); var Wr = function (e) {var t = e.resolve (5); t.constructor = { }; var r = e.resolve (t); tente {r.then (null, W) .then (null, W)} catch (n) {return true} return t === r} (S.Promise) ; var Gr = s && function () {var e = 0; var t = Object.defineProperty ({}, "então", {get: function () {e + = 1}}); Promise.resolve (t); retornar e === 1} (); var Hr = function BadResolverPromise (e) {var t = new Promise (e); e (3, function () {}); this.then = t.then; this.constructor = BadResolverPromise }; Hr.prototype = Promise.prototype; Hr.all = Promise.all; var Vr = a (function () {return !! Hr.all ([1,2])}); if (! Dr ||! zr ||! qr || Wr ||! Gr || Vr) {Promise = Fr; ne (S, "Promise", Fr)} if (Promise.all.length! == 1) {var Br = Promise. todos; ne (promessa, "todos",function all (e) {return ce.Call (Br, this, arguments)})} if (Promise.race.length! == 1) {var Ur = Promise.race; ne (Promise, "race", função race (e) {return ce.Call (Ur, this, arguments)})} if (Promise.resolve.length! == 1) {var $ r = Promise.resolve; ne (Promise, "resolve", função resolve ( e) {return ce.Call ($ r, this, arguments)})} if (Promise.reject.length! == 1) {var Jr = Promise.reject; ne (Promise, "rejeitar", função rejeitar (e ) {retornar ce.Chamada (Jr, isto, argumentos)})} Mt (Promessa, "todos"); Mt (Promessa, "corrida"); Mt (Promessa, "resolver"); Mt (Promessa, "rejeitar" ); Ce (Promessa)} var Xr = função (e) {var t = n (p (e, função (e, t) {e [t] = verdadeiro; retornar e}, {})); retornar e. join (":") === t.join (":")}; var Kr = Xr (["z", "a", "bb"]); var Zr = Xr (["z", 1 , "a", "3", 2]);if (s) {var Yr = function fastkey (e, t) {if (! t &&! Kr) {return null} if (se (e)) {return "^" + ce.ToString (e)} else if ( typeof e === "string") {return "$" + e} else if (typeof e === "number") {if (! Zr) {return "n" + e} return e} else if (typeof e === "boolean") {return "b" + e} return null}; var Qr = function emptyObject () {return Object.create? Object.create (null): {}}; var en = function addIterableToMap ( e, n, o) {if (r (o) || re.string (o)) {l (o, function (e) {if (! ce.TypeIsObject (e)) {throw new TypeError ("Valor do iterador "+ e +" não é um objeto de entrada ")} n.set (e [0], e [1])})} else if (o instância de e) {t (e.prototype.forEach, o, function (e , t) {n.set (t, e)})} else {var i, a; if (! se (o)) {a = n.set; if (! ce.IsCallable (a)) {jogar novo TypeError ("mapa inválido")} i = ce.GetIterator (o)} if (typeof i! == "undefined") {while (true) {var u = ce.IteratorStep (i); if (u === false) {break} var f = u.value; try {if (! Ce.TypeIsObject (f)) {throw new TypeError ("Iterator value" + f + "não é um objeto de entrada ")} t (a, n, f [0], f [1])} catch (s) {ce.IteratorClose (i, true); throw s}}}}}; var tn = function addIterableToSet ( e, n, o) {if (r (o) || re.string (o)) {l (o, função (e) {n.add (e)})} else if (o instância de e) {t (e.prototype.forEach, o, function (e) {n.add (e)})} else {var i, a; if (! se (o)) {a = n.add; if (! ce. IsCallable (a)) {throw new TypeError ("bad set")} i = ce.GetIterator (o)} if (typeof i! == "undefined") {while (true) {var u = ce.IteratorStep (i ); if (u === false) {break} var f = u.value; tente {t (a, n, f)} catch (s) {ce.IteratorClose (i, true); lance s}}} }}; var rn = {Map: function () {var e = {}; var r = function MapEntry (e, t) {this.key = e; this.value = t; this.next = null; this. prev = null}; r.prototype.isRemoved = function isRemoved () {return this.key === e};var n = função isMap (e) {return !! e._es6map}; var o = função requireMapSlot (e, t) {if (! ce.TypeIsObject (e) ||! n (e)) {throw new TypeError ( "Method Map.prototype." + T + "chamado em receptor incompatível" + ce.ToString (e))}}; var i = função MapIterator (e, t) {o (e, "[[MapIterator]]"); this.head = e._head; this.i = this.head; this.kind = t}; i.prototype = {isMapIterator: true, next: function next () {if (! this.isMapIterator) {throw new TypeError ("Não é um MapIterator")} var e = this.i; var t = this.kind; var r = this.head; if (typeof this.i === "undefined") {return Ke ()} while ( e.isRemoved () && e! == r) {e = e.prev} var n; enquanto (e.next! == r) {e = e.next; if (! e.isRemoved ()) {if ( t === "chave") {n = e.key} else if (t === "valor") {n = e.value} else {n = [e.key, e.value]} this.i = e; retornar Ke (n)}} this.i = void 0; retornar Ke ()}}; Me (i.protótipo); var a; var u = função Map () {if (!(esta instância do Mapa)) {lançar novo TypeError ('Mapa do construtor requer "novo"')} if (this && this._es6map) {throw new TypeError ("Construção ruim")} var e = Ae (this, Map, a, { _es6map: true, _head: null, _map: G? new G: null, _size: 0, _storage: Qr ()}); var t = new r (null, null); t.next = t.prev = t; e._head = t; if (arguments.length> 0) {en (Map, e, arguments [0])} return e}; a = u.prototype; m.getter (a, "size", function () {if (typeof this._size === "undefined") {throw new TypeError ("método de tamanho chamado em mapa incompatível")} return this._size}); b (a, {get: function get (e) {o (this, "get"); var t; var r = Yr (e, true); if (r! == null) {t = this._storage [r]; if (t) {return t.value} else {return}} if (this._map) {t = V.call (this._map, e); if (t) {return t.value} else {return}} var n = this._head; var i = n ; while ((i = i.next)! == n) {if (ce.SameValueZero (i.key, e)) {return i.valor}}}, has: function has (e) {o (this, "has"); var t = Yr (e, true); if (t! == null) {return typeof this._storage [t]! == "undefined"} if (this._map) {return B.call (this._map, e)} var r = this._head; var n = r; while ((n = n.next)! == r ) {if (ce.SameValueZero (n.key, e)) {return true}} return false}, set: function set (e, t) {o (this, "set"); var n = this._head; var i = n; var a; var u = Yr (e, true); if (u! == null) {if (typeof this._storage [u]! == "undefined") {this._storage [u] .value = t; return this} else {a = this._storage [u] = new r (e, t); i = n.prev}} else if (this._map) {if (B.call (this. _map, e)) {V.call (this._map, e) .value = t} else {a = new r (e, t); U.call (this._map, e, a); i = n. prev}} while ((i = i.next)! == n) {if (ce.SameValueZero (i.key, e)) {i.value = t; return this}} a = a || new r ( e, t); if (ce.SameValue (-0, e)) {a.key = + 0} a.next = this._head; a.prev = this._head.prev; a.prev.next = a ; a.next.prev = a; this._size + = 1;retornar isso}, "excluir": função (t) {o (isso, "excluir"); var r = isso._head; var n = r; var i = Yr (t, verdadeiro); if (i! == null) {if (typeof this._storage [i] === "undefined") {return false} n = this._storage [i] .prev; delete this._storage [i]} else if (this._map) { if (! B.call (this._map, t)) {return false} n = V.call (this._map, t) .prev; H.call (this._map, t)} while ((n = n .next)! == r) {if (ce.SameValueZero (n.key, t)) {n.key = e; n.value = e; n.prev.next = n.next; n.next.prev = n.prev; this._size- = 1; return true}} return false}, clear: function clear () {o (this, "clear"); this._map = G? new G: null; this._size = 0; this._storage = Qr (); var t = this._head; var r = t; var n = r.next; while ((r = n)! == t) {r.key = e; r .valor = e; n = r.next; r.next = r.prev = t} t.next = t.prev = t}, keys: function keys () {o (this, "keys"); return new i (isto, "chave")}, valores: valores da função () {o (isto, "valores");retornar novo i (isto, "valor")}, entradas: entradas de função () {o (isto, "entradas"); retornar novo i (isto, "chave + valor")}, forEach: function forEach (e) { o (this, "forEach"); var r = argumentos.length> 1? argumentos [1]: nulo; var n = this.entries (); for (var i = n.next () ;! i.done; i = n.next ()) {if (r) {t (e, r, i.value [1], i.value [0], this)} else {e (i.value [1], i. valor [0], este)}}}}); Me (a, a.entries); return u} (), Set: function () {var e = function isSet (e) {return e._es6set && typeof e._storage ! == "undefined"}; var r = function requireSetSlot (t, r) {if (! ce.TypeIsObject (t) ||! e (t)) {throw new TypeError ("Set.prototype." + r + " chamado em receptor incompatível "+ ce.ToString (t))}}; var o; var i = function Set () {if (! (this instanceof Set)) {throw new TypeError ('O conjunto de construtor requer" novo "') } if (this && this._es6set) {throw new TypeError ("Bad construction")} var e = Ae (this, Set, o, {_ es6set: true, "[[SetData]]": null, _storage: Qr ()}); if (! e._es6set) {lançar novo TypeError ("bad set")} if (arguments.length> 0) {tn (Set, e, arguments [0])} return e}; o = i.prototype; var a = function (e) {var t = e; if (t === "^ null") {return null} else if (t === "^ undefined") {return void 0} else {var r = t.charAt ( 0); if (r === "$") {return C (t, 1)} else if (r === "n") {return + C (t, 1)} else if (r === "b") {return t === "btrue"}} return + t}; var u = função garantirMap (e) {if (! e ["[[SetData]]"]) {var t = new rn. Map; e ["[[SetData]]"] = t; l (n (e._storage), função (e) {var r = a (e); t.set (r, r)}); e [ "[[SetData]]"] = t} e._storage = null}; m.getter (i.prototype, "size", function () {r (this, "size"); if (this._storage) { return n (isto._storage) .length} u (this); return this ["[[SetData]]"]. size}); b (i.prototype, {has: function has (e) {r (this, "has"); var t; if (this._storage && (t = Yr (e))! == null) {return !! this._storage [t]} u (this); return this ["[[SetData]]"]. tem (e)}, adicione: function add (e) {r (this, "add"); var t; if (this._storage && (t = Yr (e))! == null) {this._storage [t] = verdadeiro; retornar este} u (este); este ["[[SetData]]"]. set (e, e); retornar este}, "excluir": função (e) {r (isto, "excluir") ; var t; if (this._storage && (t = Yr (e))! == null) {var n = z (this._storage, t); return delete this._storage [t] && n} u (this); retornar este ["[[SetData]]"] ["delete"] (e)}, limpar: função clear () {r (this, "clear"); if (this._storage) {this._storage = Qr ( )} if (this ["[[SetData]]"]) {this ["[[SetData]]"]. clear ()}}, valores:valores de função () {r (isto, "valores"); u (isto); retornar novo f (este ["[[SetData]]"]. valores ())}, entradas: entradas de função () {r (este , "entradas"); u (este); retornar novo f (este ["[[SetData]]"]. entradas ())}, forEach: function forEach (e) {r (this, "forEach"); var n = argumentos.comprimento> 1? argumentos [1]: nulo; var o = isto; u (o); este ["[[SetData]]"]. forEach (função (r, i) {if (n) { t (e, n, i, i, o)} else {e (i, i, o)}})}}); h (i.protótipo, "chaves", i.protótipo.valores, verdadeiro); Eu (i.prototype, i.prototype.values); var f = function SetIterator (e) {this.it = e}; f.prototype = {isSetIterator: true, next: function next () {if (! this.isSetIterator ) {throw new TypeError ("Não é um SetIterator")} return this.it.next ()}}; Me (f.prototype); return i} ()}; var nn = S.Set &&! Set.prototype [" delete "] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray ((new Set) .keys); if (nn) {S.Set = rn.Set} if (S.Map || S.Set) {var on = a (function () { return new Map ([[1,2]]). get (1) === 2}); if (! on) {S.Map = function Map () {if (! (this instanceof Map)) {throw new TypeError ('Mapa do construtor requer "novo"')} var e = new G; if (arguments.length> 0) {en (Map, e, arguments [0])} delete e.constructor; Object.setPrototypeOf (e , S.Map.prototype); return e}; S.Map.prototype = O (G.prototype); h (S.Map.prototype, "construtor", S.Map, true); m.preserveToString (S. Mapa, G)} var an = novo Mapa; var un = função () {var e = novo Mapa ([[1,0], [2,0], [3,0], [4,0]]) ; e.set (-0, e); return e.get (0) === e && e.get (-0) === e && e.has (0) && e.has (-0)} (); var fn = an.set (1,2) === an; if (! un ||! fn) {ne (Map.prototype, "set", conjunto de funções (e, r) {t (U, this, e = == 0? 0: e, r); retornar isso})} if (! Un) {b (Map.prototype,{get: function get (e) {return t (V, this, e === 0? 0: e)}, has: function has (e) {return t (B, this, e === 0? 0 : e)}}, verdadeiro); m.preserveToString (Map.prototype.get, V); m.preserveToString (Map.prototype.has, B)} var sn = new Set; var cn = Set.prototype ["delete "] && Set.prototype.add && Set.prototype.has && function (e) {e [" excluir "] (0); e.add (-0); return! E.has (0)} (sn); var ln = sn .add (1) === sn; if (! cn ||! ln) {var pn = Set.prototype.add; Set.prototype.add = função add (e) {t (pn, this, e == = 0? 0: e); retornar isso}; m.preserveToString (Set.prototype.add, pn)} if (! Cn) {var vn = Set.prototype.has; Set.prototype.has = function has (e ) {return t (vn, this, e === 0? 0: e)}; m.preserveToString (Set.prototype.has, vn); var yn = Set.prototype ["delete"]; Set.prototype [ "delete"] = função SetDelete (e) {return t (yn, this, e === 0? 0: e)}; m.preserveToString (Set.prototype ["delete"],yn)} var hn = w (S.Map, função (e) {var t = new e ([]); t.set (42,42); return t instanceof e}); var bn = Object.setPrototypeOf &&! hn; var gn = function () {try {return! (S.Map () instanceof S.Map)} catch (e) {return e instanceof TypeError}} (); if (S.Map.length! == 0 || bn ||! gn) {S.Map = function Map () {if (! (this instanceof Map)) {throw new TypeError ('Constructor Map requer "new"')} var e = new G; if ( argument.length> 0) {en (Map, e, arguments [0])} delete e.constructor; Object.setPrototypeOf (e, Map.prototype); return e}; S.Map.prototype = G.prototype; h (S.Map.prototype, "construtor", S.Map, true); m.preserveToString (S.Map, G)} var dn = w (S.Set, função (e) {var t = new e ([ ]); t.add (42,42); return t instanceof e}); var mn = Object.setPrototypeOf &&! dn; var On = function () {try {return! (S.Set () instanceof S.Set) } catch (e) {return e instanceof TypeError}} (); if (S.Set.length!== 0 || mn ||! On) {var wn = S.Set; S.Set = function Set () {if (! (This instanceof Set)) {throw new TypeError ('Conjunto de construtor requer "novo"' )} var e = new wn; if (argument.length> 0) {tn (Set, e, arguments [0])} delete e.constructor; Object.setPrototypeOf (e, Set.prototype); retornar e}; S .Set.prototype = wn.prototype; h (S.Set.prototype, "construtor", S.Set, true); m.preserveToString (S.Set, wn)} var jn = novo S.Map; var Sn = ! a (function () {return jn.keys (). next (). done}); if (typeof S.Map.prototype.clear! == "função" || (novo S.Set) .size! = = 0 || jn.size! == 0 || typeof S.Map.prototype.keys! == "função" || typeof S.Set.prototype.keys! == "função" || typeof S.Map. prototype.forEach! == "função" || typeof S.Set.prototype.forEach! == "função" || u (S.Map) || u (S.Set) || typeof jn.keys (). próximo! == "função" || Sn ||! hn) {b (S, {Map: rn.Map, Set:rn.Set}, true)} if (S.Set.prototype.keys! == S.Set.prototype.values) {h (S.Set.prototype, "keys", S.Set.prototype.values, true )} Me (Object.getPrototypeOf ((novo S.Map) .keys ())); Me (Object.getPrototypeOf ((novo S.Set) .keys ())); if (c && S.Set.prototype.has. nome! == "has") {var Tn = S.Set.prototype.has; ne (S.Set.prototype, "has", function has (e) {return t (Tn, this, e)})} } b (S, rn); Ce (S.Map); Ce (S.Set)} var In = função throwUnlessTargetIsObject (e) {if (! ce.TypeIsObject (e)) {throw new TypeError ("o alvo deve ser um objeto ")}}; var En = {aplicar: função aplicar () {retornar ce.Chamada (ce.Chamada, nula, argumentos)}, construir: construir função (e, t) {if (! ce.IsConstructor ( e)) {lançar novo TypeError ("O primeiro argumento deve ser um construtor.")} var r = argumentos.length> 2? argumentos [2]: e; if (! ce.IsConstructor (r)) {lançar novo TypeError ( "novo.target deve ser um construtor. ")} return ce.Construct (e, t, r," internal ")}, deleteProperty: function deleteProperty (e, t) {In (e); if (s) {var r = Object .getOwnPropertyDescriptor (e, t); if (r &&! r.configurable) {return false}} return delete e [t]}, has: function has (e, t) {In (e); return t in e}} ; if (Object.getOwnPropertyNames) {Object.assign (En, {ownKeys: function ownKeys (e) {In (e); var t = Object.getOwnPropertyNames (e); if (ce.IsCallable (Object.getOwnPropertySymbols)) { x (t, Object.getOwnPropertySymbols (e))} return t}})} var Pn = function ConvertExceptionToBoolean (e) {return! i (e)}; if (Object.preventExtensions) {Object.assign (En, {isExtensible : function isExtensible (e) {In (e); return Object.isExtensions (e)}, preventExtensions: function preventExtensions (e) {In (e); return Pn (function () {return Object.preventExtensions (e)}) }})} if (s) {var Cn = função get (e, t, r) {var n = Object.getOwnPropertyDescriptor (e, t); if (! n) {var o = Object.getPrototypeOf (e); if (o === null) {return void 0} return Cn (o, t, r)} if ("valor "em n) {retornar n.valor} if (n.get) {retornar ce.Chamada (n.get, r)} retornar vazio 0}; var Mn = conjunto de funções (e, r, n, o) {var i = Object.getOwnPropertyDescriptor (e, r); if (! i) {var a = Object.getPrototypeOf (e); if (a! == null) {return Mn (a, r, n, o)} i = {valor: void 0, gravável: verdadeiro, enumerável: verdadeiro, configurável: verdadeiro}} if ("valor" em i) {if (! i.writable) {return false} if (! ce.TypeIsObject (o)) { retornar falso} var u = Object.getOwnPropertyDescriptor (o, r); if (u) {retornar ae.defineProperty (o, r, {valor: n})} else {retornar ae.defineProperty (o, r, {valor: n, gravável: verdadeiro, enumerável: verdadeiro, configurável: verdadeiro})}} if (i.set) {t (i.set, o, n); retornar verdadeiro} retornar falso}; Object.assign (En, {defineProperty : function defineProperty (e, t, r) {In (e); retorna Pn (function () {return Object.defineProperty (e, t,r)})}, getOwnPropertyDescriptor: function getOwnPropertyDescriptor (e, t) {In (e); retornar Object.getOwnPropertyDescriptor (e, t)}, get: function get (e, t) {In (e); var r = argumentos.comprimento> 2? argumentos [2]: e; retornar Cn (e, t, r)}, conjunto: conjunto de funções (e, t, r) {In (e); var n = argumentos.comprimento> 3? argumentos [3]: e; retornar Mn (e, t, r, n)}})} if (Object.getPrototypeOf) {var xn = Object.getPrototypeOf; En.getPrototypeOf = função getPrototypeOf (e) {In (e) ; return xn (e)}} if (Object.setPrototypeOf && En.getPrototypeOf) {var Nn = function (e, t) {var r = t; while (r) {if (e === r) {return true} r = En.getPrototypeOf (r)} return false}; Object.assign (En, {setPrototypeOf: function setPrototypeOf (e, t) {In (e); if (t! == null &&! Ce.TypeIsObject (t)) { lançar new TypeError ("proto deve ser um objeto ou nulo")} if (t === ae.getPrototypeOf (e)) {return true} if (ae.isExtensible &&! ae.isExtensible (e)) {retornar falso} if (Nn (e, t)) {retornar falso} Object.setPrototypeOf (e, t); retornar verdadeiro}})} var An = função (e, t) {if (! ce.IsCallable (S.Reflect [e])) {h (S.Reflect, e, t)} else {var r = a (function () {S.Reflect [e] (1); S.Reflect [e ] (NaN); S.Reflect [e] (verdadeiro); retornar verdadeiro}); if (r) {ne (S.Reflect, e, t)}}}; Object.keys (En) .forEach (function ( e) {An (e, En [e])}); var Rn = S.Reflect.getPrototypeOf; if (c && Rn && Rn.name! == "getPrototypeOf") {ne (S.Reflect, "getPrototypeOf", função getPrototypeOf ( e) {return t (Rn, S.Reflect, e)})} if (S.Reflect.setPrototypeOf) {if (a (function () {S.Reflect.setPrototypeOf (1, {}); retornar verdadeiro}) ) {ne (S.Reflect, "setPrototypeOf", En.setPrototypeOf)}} if (S.Reflect.defineProperty) {if (! a (função () {var e =! S.Reflect.defineProperty (1, "teste ", {valor: 1}); var t = typeof Object.preventExtensions! ==" função "||! S.Reflect.defineProperty (Object.preventExtensions ({}), "test", {}); return e && t})) {ne (S.Reflect, "defineProperty", En.defineProperty)}} if (S.Reflect.construct) {if (! a (função () {var e = função F () {}; retornar S.Reflect.construct (function () {}, [], e) instância de e})) {ne (S.Reflect, "construir ", En.construct)}} if (String (new Date (NaN))! ==" Invalid Date ") {var _n = Date.prototype.toString; var kn = function toString () {var e = + this; if (e! == e) {return "Invalid Date"} return ce.Call (_n, this)}; ne (Date.prototype, "toString", kn)} var Ln = {anchor: function anchor (e) {return ce.CreateHTML (this, "a", "name", e)}, big: function big () {return ce.CreateHTML (this, "big", "", "")}, blink: function blink () {return ce.CreateHTML (this, "blink", "", "")}, negrito:function bold () {return ce.CreateHTML (this, "b", "", "")}, fixed: function fixed () {return ce.CreateHTML (this, "tt", "", "")}, fontcolor: function fontcolor (e) {return ce.CreateHTML (this, "font", "color", e)}, fontsize: function fontsize (e) {return ce.CreateHTML (this, "font", "size", e)}, itálico: itálico de função () {retornar ce.CriarHTML (this, "i", "", "")}, link: link de função (e) {retornar ce.CriarHTML (this, "a", " href ", e)}, small: function small () {return ce.CreateHTML (this," small "," "," ")}, strike: function strike () {return ce.CreateHTML (this," strike " , "", "")}, sub: function sub () {return ce.CreateHTML (this, "sub", "", "")}, sup: function sub () {return ce.CreateHTML (this, "sup", "", "")}}; l (Object.keys (Ln), função (e) {var r = String.prototype [e]; var n = false; if (ce. IsCallable (r)) {var o = t (r, "", '"'); var i = P ([], o.match (/" / g)). Length; n = o! == o. toLowerCase () || i> 2} else {n = true} if (n) {ne (String.prototype, e, Ln [e])}}); var Fn = function () {if (! oe) { return false} var e = typeof JSON === "objeto" && typeof JSON.stringify === "function"? JSON.stringify: null; if (! e) {return false} if (typeof e ($ ())! == "undefined") {return true} if (e ([$ ()])! == "[null]") {return true} var t = {a: $ ()}; t [$ ()] = true; if (e (t)! == "{}") {return true} return false} (); var Dn = a (function () {if (! oe) {return true} return JSON.stringify ( Object ($ ())) === "{}" && JSON.stringify ([Object ($ ())]) === "[{}]"}); if (Fn ||! Dn) {var zn = JSON.stringify; ne (JSON,"stringify", função stringify (e) {if (typeof e === "symbol") {return} var n; if (arguments.length> 1) {n = arguments [1]} var o = [e]; if (! r (n)) {var i = ce.IsCallable (n)? n: nulo; var a = função (e, r) {var n = i? t (i, this, e, r): r ; if (typeof n! == "símbolo") {if (re.symbol (n)) {return Nt ({}) (n)} else {return n}}}; o.push (a)} else { o.push (n)} if (argument.length> 2) {o.push (arguments [2])} return zn.apply (this, o)})} return S});
/ *! jQuery v3.5.1 | (c) Fundação JS e outros contribuidores | jquery.org/license * /
! function (e, t) {"use strict"; "object" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) throw new Error ("jQuery requer uma janela com um documento"); return t (e)}: t (e)} ("undefined"! = typeof window? window: this, function ( C, e) {"usar estrito"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat? Function (e) {return t.flat.call (e)}: function (e) {return t.concat.apply ([], e)}, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call (Object), y = {}, m = function (e) {return "function" == typeof e && "number"! = typeof e.nodeType}, x = function (e) {return null! = e && e === e.window}, E = C.document, c = {type:! 0, src:! 0, nonce:! 0, noModule:! 0}; função b (e, t , n) {var r, i, o = (n = n || E) .createElement ("script");if (o.text = e, t) for (r em c) (i = t [r] || t.getAttribute && t.getAttribute (r)) && o.setAttribute (r, i); n.head.appendChild (o ) .parentNode.removeChild (o)} função w (e) {return null == e? e + "": "object" == typeof e || "function" == typeof e? n [o.call (e) ] || "objeto": tipo de e} var f = "3.5.1", S = função (e, t) {retornar novo S.fn.init (e, t)}; função p (e) {var t = !! e && "comprimento" em e && e.length, n = w (e); retornar! m (e) &&! x (e) && ("matriz" === n || 0 === t || " número "== typeof t && 0 <t && t-1 in e)} S.fn = S.prototype = {jquery: f, construtor: S, comprimento: 0, toArray: function () {return s.call (this)}, get: function (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = S .merge (this.constructor (), e); retornar t.prevObject = this, t}, cada:function (e) {return S.each (this, e)}, map: function (n) {return this.pushStack (S.map (this, function (e, t) {return n.call (e, t, e)}))}, slice: function () {return this.pushStack (s.apply (this, arguments))}, primeiro: function () {return this.eq (0)}, last: function () { return this.eq (-1)}, even: function () {return this.pushStack (S.grep (this, function (e, t) {return (t + 1)% 2}))}, odd: function () {return this.pushStack (S.grep (this, function (e, t) {return t% 2}))}, eq: function (e) {var t = this.length, n = + e + (e <0? T: 0); return this.pushStack (0 <= n && n <t? [This [n]]: [])}, end: function () {return this.prevObject || this.constructor ()} , push: u, sort: t.sort, splice: t.splice}, S.extend = S.fn.extend = function () {var e, t, n, r, i, o, a = argumentos [0 ] || {}, s = 1, u = argumentos.comprimento, l =! 1; for ("booleano" == tipo de a && (l = a, a = argumentos [s] || {}, s ++), " objeto "== typeof a || m (a) || (a = {}), s === u && (a = this,s -); s <u; s ++) if (null! = (e = argumentos [s])) para (t em e) r = e [t], "__ proto __"! == t && a! == r && ( l && r && (S.isPlainObject (r) || (i = Array.isArray (r)))? (n = a [t], o = i &&! Array.isArray (n)? []: i || S.isPlainObject (n)? n: {}, i =! 1, a [t] = S.extend (l, o, r)): void 0! == r && (a [t] = r)); retornar a} , S.extend ({expando: "jQuery" + (f + Math.random ()). Substituir (/ \ D / g, ""), isReady:! 0, erro: função (e) {lançar novo Erro ( e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! e || "[objeto Object]"! == o.call (e)) && (! (t = r (e)) || "função" == typeof (n = v.call (t, "construtor") && t.constructor) && a.call (n) === l)}, isEmptyObject: function ( e) {var t; for (t in e) return! 1; return! 0}, globalEval: function (e, t, n) {b (e, {nonce: t && t.nonce}, n)}, cada: função (e, t) {var n, r = 0; if (p (e)) {para (n = e.comprimento; r <n; r ++) if (! 1 === t.call (e [r], r, e [r])) break} else for (r in e) if (! 1 === t. call (e [r], r, e [r])) break; return e}, makeArray: function (e, t) {var n = t || []; return null! = e && (p (Object (e ))? S.merge (n, "string" == typeof e? [E]: e): u.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: i.call (t, e, n)}, mesclar: função (e, t) {para (var n = + t.length, r = 0, i = e.length; r < n; r ++) e [i ++] = t [r]; return e.length = i, e}, grep: function (e, t, n) {for (var r = [], i = 0, o = e .length, a =! n; i <o; i ++)! t (e [i], i)! == a && r.push (e [i]); return r}, map: function (e, t, n ) {var r, i, o = 0, a = []; if (p (e)) para (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); senão para (o em e) nulo! = (i = t (e [o], o, n)) && a.push (i); return g (a)} , guid: 1, suporte: y}), "função" == typeof Symbol && (S.fn [Symbol.iterator] = t [Symbol.iterator]), S.each ("Número booleano String Função Matriz Data RegExp Objeto Símbolo de erro ".split (" "), função (e, t) {n [" [objeto "+ t +"] "] = t.toLowerCase ()}); var d = função (n) {var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "chiar" +1 * nova data, p = n.documento, k = 0, r = 0, m = ue (), x = ue (), A = ue (), N = ue (), D = função (e, t) {return e === t && (l =! 0), 0}, j = {}. hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t .slice, P = function (e, t) {for (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; return-1}, R = "verificado | selecionado | assíncrono | foco automático | reprodução automática | controles | adiar | desativado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo", M = "[\\ x20 \\ t \\ r \ \ n \\ f] ", I =" (?: \\\\ [\\ da-fA-F] {1,6} "+ M +"? | \\\\ [^ \\ r \\ n \\ f] | [\\ w-] | [^ \ 0 - \\ x7f]) + ", W =" \\ ["+ M +" * ("+ I +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?:'((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\. | [^ \\\\\"]) *) \ " | ("+ I +")) |) "+ M +" * \\] ", F =" :( "+ I +") (?: \\ ((('((?: \\\\. | [ ^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ W +") *) |. *) \\) |) ", B = novo RegExp (M +" + "," g "), $ = novo RegExp ("^" + M + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + M + "+ $", "g"), _ = nova RegExp ("^" + M + "*," + M + "*"), z = nova RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*") , U = novo RegExp (M + "|>"), X = novo RegExp (F), V = novo RegExp ("^" + I + "$"), G = {ID: novo RegExp ("^ # (" + I + ")"), CLASSE: novo RegExp ("^ \\. (" + I + ")"), TAG: novo RegExp ("^ (" + I + "| [*])"), ATTR: novo RegExp ( "^ "+ W), PSEUDO: nova RegExp (" ^ "+ F), CHILD: nova RegExp (" ^ :( apenas | primeiro | último | enésimo | enésimo último) - (filho | do tipo) (?: \\ ("+ M +" * (par | ímpar | (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ R +") $ "," i "), needsContext: novo RegExp ("^" + M + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ (" + M + "* ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / HTML $ / i, Q = / ^ (?: input | select | textarea | button) $ / i, J = / ^ h \ d $ / i, K = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\ \\ [\\ da-fA-F] {1,6} "+ M +"? | \\\\ ([^ \\ r \\ n \\ f]) "," g "), ne = função (e, t) {var n = "0x" + e.slice (1) -65536; retornar t || (n <0? String.fromCharCode (n + 65536): String.fromCharCode (n >> 10 | 55296,1023 & n | 56320))}, re = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f - \ uFFFF \ w -] / g, ou seja, = função (e, t) {return t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1) .toString (16) + "": "\\" + e}, oe = function () {T ()}, ae = be (function (e) {return! 0 === e.disabled && "fieldset" === e.nodeName.toLowerCase ()}, {dir: "parentNode", próximo: "legend"}); tente {H.apply (t = O.call (p .childNodes), p.childNodes), t [p.childNodes.length] .nodeType} catch (e) {H = {apply: t.length? function (e, t) {L.apply (e, O.call (t))}: função (e, t) {var n = e.length, r = 0; enquanto (e [n ++] = t [r ++]); e.length = n-1}}} função se ( t, e, n, r) {var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e? e.nodeType: 9; if (n = n || [], "string"! = typeof t ||! t || 1! == p && 9! == p && 11! == p) return n; if (! r && (T (e), e = e || C,E)) {if (11! == p && (u = Z.exec (t))) if (i = u [1]) {if (9 === p) {if (! (A = e.getElementById (i))) retornar n; if (a.id === i) retornar n.push (a), n} else if (f && (a = f.getElementById (i)) && y (e, a) && a. id === i) return n.push (a), n} else {if (u [2]) return H.apply (n, e.getElementsByTagName (t)), n; if ((i = u [3 ]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply (n, e.getElementsByClassName (i)), n} if (d.qsa &&! N [t + ""] && (! v ||! v.test (t) ) && (1! == p || "objeto"! == e.Nome do nó.toLowerCase ())) {if (c = t, f = e, 1 === p && (U.test (t) || z.test (t))) {(f = ee.test (t) && ye (e.parentNode) || e) === e && d.scope || ((s = e.getAttribute ("id"))? s = s.replace (re, ie): e.setAttribute ("id", s = S)), o = (l = h (t)). comprimento; enquanto (o -) l [o] = ( s? "#" + s: ": escopo") + "" + xe (l [o]); c = l.join (",")} tente {return H.apply (n, f.querySelectorAll (c)), n} catch (e) {N (t,! 0)} finalmente {s === S && e.removeAttribute (" id ")} }} return g (t.replace ($, "$ 1"), e, n, r)} função ue () {var r = []; função de retorno e (t, n) {return r.push (t + " ")> b.cacheLength && delete e [r.shift ()], e [t +" "] = n}} função le (e) {return e [S] =! 0, e} função ce (e) {var t = C.createElement ("fieldset"); try {return !! e (t)} catch (e) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} function fe ( e, t) {var n = e.split ("|"), r = n.length; enquanto (r -) b.attrHandle [n [r]] = t} função pe (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n == = t) return-1; return e? 1: -1} função de (t) {return function (e) {return "input" === e.nodeName.toLowerCase () && e.type === t}} function he (n) {return function (e) {var t = e.nodeName.toLowerCase (); return ("input" === t || "botão "=== t) && e.type === n}} function ge (t) {return function (e) {return" form "in e? e.parentNode &&! 1 === e.disabled?" label "em e? "rótulo" em e.parentNode? e.parentNode.disabled === t: e.disabled === t: e.isDisabled === t || e.isDisabled! ==! t && ae (e) == = t: e.disabled === t: "rótulo" em e && e.disabled === t}} função ve (a) {return le (function (o) {return o = + o, le (function (e, t) {var n, r = a ([], e.length, o), i = r.length; enquanto (i -) e [n = r [i]] && (e [n] =! ( t [n] = e [n]))})})} função ye (e) {return e && "undefined"! = typeof e.getElementsByTagName && e} for (e em d = se.support = {}, i = se .isXML = function (e) {var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement;return! Y.test (t || n && n.nodeName || "HTML")}, T = se.setDocument = function (e) {var t, n, r = e? e.ownerDocument || e: p; return r! = C && 9 === r.nodeType && r.documentElement && (a = (C = r) .documentElement, E =! i (C), p! = C && (n = C.defaultView) && n.top! == n && ( n.addEventListener? n.addEventListener ("unload", oe,! 1): n.attachEvent && n.attachEvent ("onunload", oe)), d.scope = ce (function (e) {return a.appendChild (e) .appendChild (C.createElement ("div")), "undefined"! = typeof e.querySelectorAll &&! e.querySelectorAll (": scope fieldset div"). length}), d.attributes = ce (function (e) { return e.className = "i",! e.getAttribute ("className")}), d.getElementsByTagName = ce (function (e) {return e.appendChild (C.createComment ("")) ,! e.getElementsByTagName ("*").length}), d.getElementsByClassName = K.test (C.getElementsByClassName), d.getById = ce (function (e) {return a.appendChild (e) .id = S,! C.getElementsByName ||! C.getElementsByName (S) .length}), d.getById? (B.filter.ID = função (e) {var t = e.replace (te, ne); função de retorno (e) {return e.getAttribute ("id" ) === t}}, b.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n = t.getElementById (e); retornar n? [n] : []}}) :( b.filter.ID = function (e) {var n = e.replace (te, ne); função de retorno (e) {var t = "undefined"! = typeof e.getAttributeNode && e. getAttributeNode ("id"); return t && t.value === n}}, b.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n, r, i , o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e) , r = 0;while (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]} return []}}), b.find.TAG = d .getElementsByTagName? function (e, t) {return "undefined"! = typeof t.getElementsByTagName? t.getElementsByTagName (e): d.qsa? t.querySelectorAll (e): void 0}: function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, b.find.CLASS = d.getElementsByClassName && function (e, t) {if ("undefined"! = typeof t.getElementsByClassName && E) return t.getElementsByClassName (e)}, s = [ ], v = [], (d.qsa = K.test (C.querySelectorAll)) && (ce (function (e) {var t; a.appendChild (e) .innerHTML = "<a id = '" + S + "'> </a> <select id ='" + S + "- \ r \\ 'msallowcapture =' '> <opção selecionada =' '> </ option> </select> ", e.querySelectorAll (" [msallowcapture ^ = ''] "). length && v.push (" [* ^ $] = "+ M +" * (?: '' | \ "\" ) "), e.querySelectorAll (" [selecionado] "). length || v.push (" \\ ["+ M +" * (?: valor | "+ R +") "), e.querySelectorAll (" [ id ~ = "+ S +" -] "). length || v.push (" ~ = "), (t = C.createElement (" input ")). setAttribute (" name "," "), e. appendChild (t), e.querySelectorAll ("[name = '']"). length || v.push ("\\ [" + M + "* name" + M + "* =" + M + "* (?: '' | \ "\") "), e.querySelectorAll (": verificado "). comprimento || v.push (": verificado "), e.querySelectorAll (" a # "+ S +" + * "). comprimento || v.push (". #. + [+ ~]"), e.querySelectorAll ("\\\ f"), v.push ("[\\ r \\ n \\ f]")}), ce (função (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <selecionar desativado = 'disabled'> <option /> </select> "; var t = C.createElement (" input "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" nome "," D "), e.querySelectorAll (" [name = d] "). length && v.push (" name "+ M +" * [* ^ $ |! ~]? = "), 2! == e .querySelectorAll (": enabled"). length && v.push (": enabled", ": disabled"), a.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": disabled"). length && v.push (": enabled", ": disabled"), e.querySelectorAll ("* ,: x"), v.push (",. *:")})), (d.matchesSelector = K.test (c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce (function (e) {d.disconnectedMatch = c.call (e, "*"), c.call (e, "[s! = '']: x "), s.push ("! = ", F)}), v = v.length && new RegExp (v.join (" | ")), s = s.length && new RegExp (s.join (" | ") ), t = K.test (a.compareDocumentPosition), y = t || K.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r )))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) return! 0; return! 1}, D = t? function (e, t ) {if (e === t) return l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! d.sortDetached && t.compareDocumentPosition (e) === n? e == C || e.ownerDocument == p && y (p, e)? - 1: t == C || t.ownerDocument == p && y (p, t)? 1: u? P (u, e) -P (u, t): 0: 4 & n? -1: 1)}: função (e, t) {if (e === t) return l =! 0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; se (! I ||! O) retornar e == C? -1 : t == C? 1: i? -1: o? 1: u? P (u, e) -P (u, t): 0; se (i === o) retornar pe (e, t) ; n = e; while (n = n.parentNode) a.unshift (n); n = t; while (n = n.parentNode) s.unshift (n); while (a [r] === s [ r]) r ++; retornar r? pe (a [r], s [r]): a [r] == p? -1: s [r] == p? 1: 0}), C}, se .matches = function (e, t) {return se (e, null, null, t)}, se.matchesSelector = function (e, t) {if (T (e), d.matchesSelector && E &&! N [t + "" ] && (! s ||! s.test (t)) && (! v ||! v.test (t))) tente {var n = c.call (e, t); if (n || d .disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (e) {N (t,! 0)} return 0 <se (t, C, null, [e]). length} , se.contém = função (e, t) {return (e.ownerDocument || e)! = C && T (e), y (e, t)}, se.attr = function (e, t) {(e.ownerDocument || e)! = C && T (e); var n = b.attrHandle [t.toLowerCase ()], r = n && j.call (b.attrHandle, t.toLowerCase ())? n (e, t,! E): void 0; return void 0! == r? r: d.attributes ||! E? e.getAttribute (t) :( r = e.getAttributeNode (t)) && r.specified? r.value: null}, se .escape = function (e) {return (e + ""). replace (re, ie)}, se.error = function (e) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + e)}, se .uniqueSort = function (e) {var t, n = [], r = 0, i = 0; if (l =! d.detectDuplicates, u =! d.sortStable && e.slice (0), e.sort (D ), l) {enquanto (t = e [i ++]) t === e [i] && (r = n.push (i)); enquanto (r -) e.splice (n [r], 1 )} return u = null, e}, o = se.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; if (i) {if (1 === i || 9 === i || 11 === i) {if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else if (3 === i || 4 === i) return e.nodeValue } else while (t = e [r ++]) n + = o (t); return n}, (b = se.selectors = {cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: { }, relative: {">": {dir: "parentNode", first:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", first:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1] .replace (te, ne), e [3] = (e [3 ] || e [4] || e [5] || ""). substituir (te, ne), "~ =" === e [2] && (e [3] = "" + e [3 ] + ""), e.slice (0,4)}, CRIANÇA: função (e) {return e [1] = e [1] .toLowerCase (), "enésimo" === e [1] .slice (0,3)? (E [3] || se.error (e [0]), e [4] = + (e [4]? E [5] + (e [6] || 1): 2 * ("par" === e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar "=== e [3])): e [3] && se.error (e [0]), e}, PSEUDO: função (e) {var t, n =! e [6] && e [2] ; retornar G.CHILD.test (e [0])? null: (e [3]? e [2] = e [4] || e [5] || "": n && X.test (n) && ( t = h (n,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t ), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtro: {TAG: função (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e ) {var t = m [e + ""]; retornar t || (t = novo RegExp ("(^ |" + M + ")" + e + "(" + M + "| $)")) && m (e, function (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")})}, ATTR:function (n, r, i) {return function (e) {var t = se.attr (e, n); return null == t? "! =" === r:! r || (t + = " "," = "=== r? t === i:"! = "=== r? t! == i:" ^ = "=== r? i && 0 === t.indexOf (i) : "* =" === r? i && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ =" == = r? -1 <("" + t.replace (B, "") + "") .indexOf (i): "| =" === r && (t === i || t.slice (0 , i.length + 1) === i + "-"))}}, CRIANÇA: função (h, e, t, g, v) {var y = "enésimo"! == h.slice (0,3 ), m = "último"! == h.slice (-4), x = "do tipo" === e; return 1 === g && 0 === v? function (e) {return !! e .parentNode}: function (e, t, n) {var r, i, o, a, s, u, l = y! == m? "nextSibling": "previousSibling", c = e.parentNode, f = x && e.Nome do nó.paraCase Inferior (), p =! n &&! x, d =! 1; if (c) {if (y) {while (l) {a = e;while (a = a [l]) if (x? a.nodeName.toLowerCase () === f: 1 === a.nodeType) return! 1; u = l = "apenas" === h &&! u && "nextSibling"} return! 0} if (u = [m? c.firstChild: c.lastChild], m && p) {d = (s = (r = (i = (o = (a = c) [S] | | (a [S] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === k && r [1]) && r [2], a = s && c.childNodes [s]; enquanto (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if (1 === a.nodeType && + + d && a === e) {i [h] = [k, s, d]; quebrar}} else if (p && (d = s = (r = (i = (o = (a = e) [S] || (a [S] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === k && r [1]) ,! 1 === d) while (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if ((x? A.nodeName.toLowerCase () === f: 1 === a.nodeType) && ++ d && (p && ((i = (o = a [S] || (a [S] = {})) [a.uniqueID] || (o [a .uniqueID] = {})) [h] = [k, d]), a === e)) break; return (d- = v) === g || d% g == 0 && 0 <= d / g}}}, PSEUDO:função (e, o) {var t, a = b.pseudos [e] || b.setFilters [e.toLowerCase ()] || se.error ("pseudo sem suporte:" + e); retornar a [S] ? a (o): 1 <a.length? (t = [e, e, "", o], b.setFilters.hasOwnProperty (e.toLowerCase ())? le (função (e, t) {var n , r = a (e, o), i = r.length; enquanto (i -) e [n = P (e, r [i])] =! (t [n] = r [i])} ): function (e) {return a (e, 0, t)}): a}}, pseudos: {not: le (function (e) {var r = [], i = [], s = f ( e.replace ($, "$ 1")); retornar s [S]? le (função (e, t, n, r) {var i, o = s (e, nulo, r, []), a = e.length; enquanto (a -) (i = o [a]) && (e [a] =! (t [a] = i))}): função (e, t, n) {return r [ 0] = e, s (r, nulo, n, i), r [0] = nulo,! I.pop ()}}), tem: le (função (t) {função de retorno (e) {retorno 0 <se (t, e) .length}}), contém: le (função (t) {return t = t.replace (te, ne), função (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (function (n) {return V.test (n || "") || se.error ("unsupported lang:" + n),n = n.replace (te, ne) .toLowerCase (), function (e) {var t; faça {if (t = E? e.lang: e.getAttribute ("xml: lang") || e.getAttribute ("lang")) return (t = t.toLowerCase ()) === n || 0 === t.indexOf (n + "-")} enquanto ((e = e.parentNode) && 1 === e .nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; return t && t.slice (1) === e.id}, root: function (e) {return e === a}, focus: function (e) {return e === C.activeElement && (! C.hasFocus || C.hasFocus ()) && !! (e.type || e.href | | ~ e.tabIndex)}, ativado: ge (! 1), desativado: ge (! 0), verificado: função (e) {var t = e.nodeName.toLowerCase (); return "input" === t && !! e.checked || "option" === t && !! e.selected}, selecionado: function (e) {return e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, vazio: function (e) {para (e = e.firstChild; e; e = e.nextSibling) se (e.nodeType <6) return! 1; return! 0}, parent: function (e) {return! B.pseudos.empty (e)}, header: function (e) {return J.test (e.nodeName)}, input: function (e) {return Q.test (e.nodeName)}, botão: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && "button" === e. digite || "botão" === t}, texto: função (e) {var t; return "input" === e.nodeName.toLowerCase () && "texto" === e.type && (null == (t = e.getAttribute ("type")) || "text" === t.toLowerCase ())}, primeiro: ve (function () {return [0]}), último: ve (function (e , t) {return [t-1]}), eq: ve (função (e, t, n) {return [n <0? n + t: n]}), even: ve (função (e, t ) {para (var n = 0; n <t; n + = 2) e.push (n); retornar e}), ímpar: ve (função (e, t) {para (var n = 1; n <t ; n + = 2) e.push (n); retornar e}), lt: ve (função (e, t, n) {para (var r = n <0? n + t: t <n? t: n ; 0 <= - r;) e.push (r); retornar e}), gt: ve (função (e, t,n) {para (var r = n <0? n + t: n; ++ r <t;) e.push (r); retornar e})}}). pseudos.nth = b.pseudos.eq, {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) b.pseudos [e] = de (e); for (e em {enviar:! 0, redefinir :! 0}) b.pseudos [e] = he (e); função me () {} função xe (e) {para (var t = 0, n = e.length, r = ""; t <n ; t ++) r + = e [t] .value; return r} função be (s, e, t) {var u = e.dir, l = e.next, c = l || u, f = t && "parentNode "=== c, p = r ++; retornar e.first? função (e, t, n) {enquanto (e = e [u]) se (1 === e.nodeType || f) retornar s (e , t, n); retornar! 1}: função (e, t, n) {var r, i, o, a = [k, p]; se (n) {enquanto (e = e [u]) se ((1 === e.nodeType || f) && s (e, t, n)) return! 0} else while (e = e [u]) if (1 === e.nodeType || f) if (i = (o = e [S] || (e [S] = {})) [e.uniqueID] || (o [e.uniqueID] = {}), l && l === e.nodeName.toLowerCase ()) e = e [u] || e; senão {if ((r = i [c]) && r [0] === k && r [1] === p) retorna a [2] = r [2 ]; if ((i [c] = a) [2] = s (e, t, n)) retorno! 0} retorno!1}} função we (i) {return 1 <i.length? Função (e, t, n) {var r = i.length; while (r -) if (! I [r] (e, t, n)) return! 1; return! 0}: i [0]} função Te (e, t, n, r, i) {for (var o, a = [], s = 0, u = e.length , l = nulo! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s) )); retornar a} função Ce (d, h, g, v, y, e) {retornar v &&! v [S] && (v = Ce (v)), y &&! y [S] && (y = Ce (y, e)), le (função (e, t, n, r) {var i, o, a, s = [], u = [], l = t.length, c = e || função ( e, t, n) {para (var r = 0, i = t.length; r <i; r ++) se (e, t [r], n); retornar n} (h || "*", n .nodeType? [n]: n, []), f =! d ||! e && h? c: Te (c, s, d, n, r), p = g? y || (e? d: l || v)? []: t: f; if (g && g (f, p, n, r), v) {i = Te (p, u), v (i, [], n, r), o = i.length; enquanto (o -) (a = i [o]) && (p [u [o]] =! (f [u [o]] = a))} if (e) {if ( y || d) {if (y) {i = [], o = p.length; enquanto (o -) (a = p [o]) && i.push (f [o] = a); y ( nulo, p = [], i, r)} o = p.length; enquanto (o -) (a = p [o]) && -1 <(i = y? P (e, a): s [o]) && (e [i] =! (T [i] = a))}} senão p = Te (p === t ? p.splice (l, p.length): p), y? y (nulo, t, p, r): H.aplicar (t, p)})} função Ee (e) {for (var i, t, n, r = comprimento e.longo, o = b.relativo [e [0] .tipo], a = o || b.relativo [""], s = o? 1: 0, u = ser (função (e) {return e === i}, a,! 0), l = be (function (e) {return-1 <P (i, e)}, a,! 0), c = [function ( e, t, n) {var r =! o && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n) ); return i = null, r}]; s <r; s ++) if (t = b.relative [e [s] .type]) c = [be (we (c), t)]; else {if ((t = b.filter [e [s] .type] .apply (null, e [s] .matches)) [S]) {for (n = ++ s; n <r; n ++) if (b .relative [e [n] .type]) break; return Ce (1 <s && we (c), 1 <s && xe (e.slice (0, s-1) .concat ({value: "" === e [ s-2] .type? "*": ""})). substituir ($, "$ 1"), t, s <n && Ee (e.slice (s, n)), n <r && Ee (e = e. fatia (n)), n <r && xe (e))} c.push (t)} return we (c)} return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) {var n, r, i , o, a, s, u, l = x [e + ""]; se (l) retornar t? 0: l.slice (0); a = e, s = [], u = b.preFiltro; enquanto (a) {para (o em n &&! (r = _. exec (a)) || (r && (a = a.slice (r [0] .comprimento) || a), s.push (i = [ ])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({valor: n, digite: r [0] .replace ($, " ")}), a = a.slice (n.length)), b.filtro)! (r = G [o] .exec (a)) || u [o] &&! (r = u [o] (r)) || (n = r.shift (), i.push ({valor: n, tipo: o, corresponde a: r}), a = a.slice (n.length)); if (! n ) break} return t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compile = function (e, t) {var n, v, y, m, x, r, i = [], o = [], a = A [e + ""]; if (! a) {t || (t = h (e)), n = t.length ; enquanto (n -) (a = Ee (t [n])) [S]? i.push (a): o.push (a); (a = A (e, (v = o, m = 0 <(y = i) .comprimento, x = 0 <v.length, r = função (e, t, n, r, i) {var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG ("*", i), h = k + = null == p? 1: Math.random () ||. 1, g = d.length; for (i && (w = t == C || t || i); l! == g && null! = (O = d [l]); l ++) {if (x && o) { a = 0, t || o.ownerDocument == C || (T (o), n =! E); enquanto (s = v [a ++]) if (s (o, t || C, n)) {r.push (o); break} i && (k = h)} m && ((o =! s && o) && u -, e && c.push (o))} if (u + = l, m && l! == u) { a = 0; enquanto (s = y [a ++]) s (c, f, t, n); se (e) {if (0 <u) enquanto (l -) c [l] || f [l ] || (f [l] = q.call (r)); f = Te (f)} H.aplicar (r, f), i &&! e && 0 <f.length && 1 <u + y.length && se.uniqueSort (r )} return i && (k = h, w = p), c}, m? le (r): r))). selector = e} return a}, g = se.select = function (e, t, n , r) {var i, o, a, s, u, l = "função" == tipo de e && e, c =! r && h (e = l.seletor || e); if (n = n || [], 1 === c.length) {if (2 <(o = c [0] = c [0] .slice (0)). Length && "ID" === (a = o [0]).digite && 9 === t.nodeType && E && b.relative [o [1] .type]) {if (! (t = (b.find.ID (a.matches [0] .replace (te, ne), t) || []) [0])) return n; l && (t = t.parentNode), e = e.slice (o.shift (). Value.length)} i = G.needsContext.test (e)? 0: o.length; while (i -) {if (a = o [i], b.relative [s = a.type]) break; if ((u = b.find [s]) && (r = u (a.matches [0] .replace (te, ne), ee.test (o [0] .type) && ye (t.parentNode) || t))) {if (o.splice (i, 1), ! (e = r.length && xe (o))) return H.apply (n, r), n; break}}} return (l || f (e, c)) (r, t,! E, n, ! t || ee.test (e) && ye (t.parentNode) || t), n}, d.sortStable = S.split (""). sort (D) .join ("") === S , d.detectDuplicates = !! l, T (), d.sortDetached = ce (function (e) {return 1 & e.compareDocumentPosition (C.createElement ("fieldset"))}), ce (function (e) {return e .innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || fe ("type | href | height | width", function (e, t, n) {if (! n) return e.getAttribute (t, "type" == = t.toLowerCase ()? 1: 2)}), d.attributes && ce (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), " "=== e.firstChild.getAttribute (" valor ")}) || fe (" valor ", função (e, t, n) {if (! n &&" input "=== e.nodeName.toLowerCase () ) return e.defaultValue}), ce (function (e) {return null == e.getAttribute ("disabled")}) || fe (R, function (e, t, n) {var r; if (! n) return! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), se} (C); S.find = d, S.expr = d.seletores, S.expr [":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType ) if (1 === e.nodeType) {if (i && S (e) .is (n)) break; r.push (e)} return r}, T = function (e, t) {for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, k = S.expr.match.needsContext; função A (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var N = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] * ) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; função D (e, n, r) {return m (n)? S .grep (e, function (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? S.grep (e, function (e) {return e = == n! == r}): "string"! = typeof n? S.grep (e, função (e) {return-1 <i.call (n, e)! == r}): S. filtro (n, e, r)} S.filtro = função (e, t, n) {var r = t [0]; retornar n && (e = ": não (" + e + ")"), 1 == = t.length && 1 === r.nodeType? S.find.MatchSelector (r, e)? [r]: []: S.find.matches (e, S.grep (t, function (e) {return 1 === e.nodeType}))}, S.fn. extend ({find: function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) return this.pushStack (S (e) .filter (function () {for (t = 0; t <r; t ++) if (S.contains (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) S.find (e, i [t], n); return 1 <r? S.uniqueSort (n): n}, filtro: função (e) {return this.pushStack (D (this , e || [] ,! 1))}, não: function (e) {return this.pushStack (D (this, e || [] ,! 0))}, é: function (e) {return! ! D (this, "string" == typeof e && k.test (e)? S (e): e || [] ,! 1) .length}}); var j, q = / ^ (?: \ S * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (S.fn.init = função (e, t, n) {var r, i; if (! e) retorna isso; if (n = n || j, "string" == typeof e) {if (! (r = "<" === e [0] && ">" == = e [e.length-1] && 3 <= e.length? [nulo, e, nulo]: q.exec (e)) ||! r [1] && t) return! t || t.jquery? (t || n) .find (e): this.constructor (t) .find (e); if (r [1]) {if (t = t instanceof S? T [0]: t, S.merge (this, S.parseHTML (r [1], t && t.nodeType? T.ownerDocument || t: E,! 0 )), N.test (r [1]) && S.isPlainObject (t)) para (r em t) m (este [r])? This [r] (t [r]): this.attr (r, t [r]); retornar este} return (i = E.getElementById (r [2])) && (this [0] = i, this.length = 1), this} return e.nodeType? (this [0 ] = e, this.length = 1, this): m (e)? void 0! == n.ready? n.ready (e): e (S): S.makeArray (e, this)}). protótipo = S.fn, j = S (E); var L = / ^ (?: pais | anterior (?: Até | Todos)) /, H = {filhos:! 0, conteúdo:! 0, próximo :! 0, prev:! 0}; function O (e, t) {while ((e = e [t]) && 1! == e.nodeType); return e} S.fn.extend ({has: function (e ) {var t = S (e, this), n = t.length; retornar this.filter (function () {for (var e = 0; e <n; e ++) if (S.contains (this, t [ e])) return! 0})}, mais próximo: função (e, t) {var n, r = 0, i = this.length, o = [],a = "string"! = typeof e && S (e); if (! k.test (e)) for (; r <i; r ++) for (n = this [r]; n && n! == t; n = n .parentNode) if (n.nodeType <11 && (a? -1 <a.index (n): 1 === n.nodeType && S.find.matchesSelector (n, e))) {o.push (n); break } return this.pushStack (1 <o.length? S.uniqueSort (o): o)}, índice: função (e) {return e? "string" == typeof e? i.call (S (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1} , adicione: function (e, t) {return this.pushStack (S.uniqueSort (S.merge (this.get (), S (e, t)))))}, addBack: function (e) {return this. add (null == e? this.prevObject: this.prevObject.filter (e))}}), S.each ({parent: function (e) {var t = e.parentNode; return t && 11! == t. nodeType? t: null}, parent: function (e) {return h (e, "parentNode")}, parentsUntil: function (e, t, n) {return h (e, "parentNode", n)},next: function (e) {return O (e, "nextSibling")}, prev: function (e) {return O (e, "previousSibling")}, nextAll: function (e) {return h (e, "nextSibling") ")}, prevAll: function (e) {return h (e," previousSibling ")}, nextUntil: function (e, t, n) {return h (e," nextSibling ", n)}, prevUntil: function ( e, t, n) {return h (e, "previousSibling", n)}, irmãos: function (e) {return T ((e.parentNode || {}). firstChild, e)}, children: function ( e) {return T (e.firstChild)}, contents: function (e) {return null! = e.contentDocument && r (e.contentDocument)? e.contentDocument: (A (e, "template") && (e = e .content || e), S.merge ([], e.childNodes))}}, função (r, i) {S.fn [r] = função (e, t) {var n = S.map ( this, i, e); return "Até"! == r.slice (-5) && (t = e), t && "string" == typeof t && (n = S.filter (t, n)), 1 <this.length &&(H [r] || S.uniqueSort (n), L.test (r) && n.reverse ()), this.pushStack (n)}}); var P = / [^ \ x20 \ t \ r \ n \ f] + / g; função R (e) {retornar e} função M (e) {lançar e} função I (e, t, n, r) {var i; tentar {e && m (i = e.promessa )? i.call (e) .done (t) .fail (n): e && m (i = e.then)? i.call (e, t, n): t.apply (vazio 0, [e]. fatia (r))} catch (e) {n.apply (void 0, [e])}} S.Callbacks = function (r) {var e, n; r = "string" == typeof r? (e = r, n = {}, S.each (e.match (P) || [], função (e, t) {n [t] =! 0}), n): S.extend ({}, r); var i, t, o, a, s = [], u = [], l = -1, c = função () {para (a = a || r.uma vez, o = i =! 0 ; u.length; l = -1) {t = u.shift (); enquanto (++ l <s.length)! 1 === s [l] .aplicar (t [0], t [1] ) && r.stopOnFalse && (l = s.length, t =! 1)} r.memória || (t =! 1), i =! 1, a && (s = t? []: "")}, f = {add: function () {return s && (t &&! i && (l = s.length-1, u.push (t)), função n (e) {S.each (e, function (e, t) {m (t)? r.unique && f.has (t) || s.push (t): t && t.length && "string"! == w (t) && n (t)})} (argumentos), t &&! i && c ()), this}, remove: function () {retornar S.each (argumentos, função (e, t) {var n; enquanto (-1 <(n = S.inArray (t, s, n))) s.splice (n, 1), n <= l && l -}), este}, tem: function (e) {return e? -1 <S.inArray (e, s): 0 <s.length}, vazio: function () {return s && (s = []), este}, desabilitar: função () {retornar a = u = [], s = t = "", este}, desabilitado: função () {retorno! s}, bloqueio: função () {retorno a = u = [], t || i || (s = t = ""), este}, bloqueado: function () {return !! a}, fireWith: function (e, t) {return a || (t = [e, (t = t || []). slice? t.slice (): t], u.push (t), i || c ()), this}, fire: function () {return f.fireWith (this, arguments), this}, disparado: function () {return !! o}}; return f}, S.extend ({Adiado: function (e) {var o = [["notificar "," progresso ", S.Callbacks (" memória "), S.Callbacks ("memória"), 2], ["resolver", "concluído", S.Callbacks ("uma vez na memória"), S.Callbacks ("uma vez na memória"), 0, "resolvido"], ["rejeitar" , "falha", S.Callbacks ("uma vez na memória"), S.Callbacks ("uma vez na memória"), 1, "rejeitado"]], i = "pendente", a = {estado: função () {retorno i }, sempre: função () {retornar s.done (argumentos) .fail (argumentos), este}, "pegar": função (e) {retornar a.então (nulo, e)}, tubo: função () { var i = argumentos; retornar S.Deferred (função (r) {S.each (o, função (e, t) {var n = m (i [t [4]]) && i [t [4]]; s [t [1]] (função () {var e = n && n.apply (this, argumentos); e && m (e.promise)? e.promise (). progress (r.notify) .done (r.resolve). falha (r.rejeitar): r [t [0] + "Com"] (isto, n? [e]: argumentos)})}), i = nulo}). promessa ()}, então: função (t , n, r) {var u = 0; função l (i, o, a,s) {função de retorno () {var n = this, r = argumentos, e = função () {var e, t; if (! (i <u)) {if ((e = a.apply (n, r )) === o.promise ()) lançar novo TypeError ("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m ( t)? s? t.call (e, l (u, o, R, s), l (u, o, M, s)) :( u ++, t.call (e, l (u, o, R , s), l (u, o, M, s), l (u, o, R, o.notifyWith))) :( a! == R && (n = vazio 0, r = [e]), ( s || o.resolveWith) (n, r))}}, t = s? e: function () {try {e ()} catch (e) {S.Deferred.exceptionHook && S.Deferred.exceptionHook (e, t .stackTrace), u <= i + 1 && (a! == M && (n = vazio 0, r = [e]), o.rejectWith (n, r))}}; i? t () :( S. Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook ()), C.setTimeout (t))}} return S.Deferred (function (e) {o [0] [3] .add (l (0, e, m (r)? r: R, e.notifyWith)), o [1] [3] .add (l (0, e, m (t)? t: R)), o [2] [3 ] .add (l (0, e, m (n)? n: M))}). promessa ()}, promessa:function (e) {return null! = e? S.extend (e, a): a}}, s = {}; return S.each (o, function (e, t) {var n = t [2] , r = t [5]; a [t [1]] = n.add, r && n.add (função () {i = r}, o [3-e] [2] .disable, o [3-e ] [3] .desativar, o [0] [2] .lock, o [0] [3] .lock), n.add (t [3] .fire), s [t [0]] = função ( ) {return s [t [0] + "Com"] (this === s? void 0: this, argumentos), this}, s [t [0] + "With"] = n.fireWith}), a.promisso (s), e && e.call (s, s), s}, quando: função (e) {var n = argumentos.comprimento, t = n, r = Matriz (t), i = s.call ( argumentos), o = S.Deferred (), a = função (t) {função de retorno (e) {r [t] = isso, i [t] = 1 <argumentos.comprimento? s.call (argumentos): e , - n || o.resolveWith (r, i)}}; if (n <= 1 && (I (e, o.done (a (t)). resolve, o.reject,! n), "pendente "=== o.state () || m (i [t] && i [t] .then))) return o.then (); enquanto (t -) I (i [t], a (t) , o.reject); return o.promise ()}}); var W = / ^ (Avaliação | Interno | Intervalo | Referência | Sintaxe | Tipo | URI) Erro $ /; S.Deferred.exceptionHook = function (e, t) {C.console && C.console.warn && e && W.test (e.name) && C.console.warn ("jQuery.Deferred exception:" + e.message, e.stack, t)} , S.readyException = function (e) {C.setTimeout (function () {throw e})}; var F = S.Deferred (); função B () {E.removeEventListener ("DOMContentLoaded", B), C .removeEventListener ("load", B), S.ready ()} S.fn.ready = function (e) {return F.then (e) ["catch"] (function (e) {S.readyException (e )}), este}, S.extend ({isReady:! 1, readyWait: 1, ready: function (e) {(! 0 === e? - S.readyWait: S.isReady) || (S .isReady =! 0)! == e && 0 <- S.readyWait || F.resolveWith (E, [S])}}), S.ready.then = F.then, "complete" === E. readyState || "carregando"! == E.readyState &&! E.documentElement.doScroll? C.setTimeout (S.ready) :( E.addEventListener ("DOMContentLoaded", B), C.addEventListener ("load", B)); var $ = function (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; if ( "objeto" === w (n)) para (s em i =! 0, n) $ (e, t, s, n [s] ,! 0, o, a); senão se (vazio 0! = = r && (i =! 0, m (r) || (a =! 0), l && (a? (t.call (e, r), t = null) :( l = t, t = function (e , t, n) {return l.call (S (e), n)})), t)) for (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n))); retornar i? e: l? t.call (e): u? t (e [0], n): o}, _ = / ^ - ms - /, z = / - ([az]) / g; função U (e, t) {retornar t.toUpperCase ()} função X (e) {retornar e.replace (_, "ms - "). replace (z, U)} var V = function (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; function G () { this.expando = S.expando + G.uid ++} G.uid = 1, G.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = {}, V (e) && (e.nodeType? E [this.expando] = t: Object.defineProperty (e, this.expando, {value: t, configurable:! 0}))), t}, set: function ( e, t, n) {var r, i = isto.cache (e); if ("string" == typeof t) i [X (t)] = n; else for (r in t) i [X (r)] = t [r]; return i}, obter : function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [X (t)]}, acesso: function (e, t) , n) {return void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0 ! == n? n: t)}, remova: função (e, t) {var n, r = e [this.expando]; if (void 0! == r) {if (void 0! == t ) {n = (t = Array.isArray (t)? t.map (X) :( t = X (t)) em r? [t]: t.match (P) || []). comprimento; while (n -) excluir r [t [n]]} (vazio 0 === t || S.isEmptyObject (r)) && (e.nodeType? e [this.expando] = vazio 0: excluir e [ this.expando])}}, hasData: function (e) {var t = e [this.expando]; return void 0! == t &&! S.isEmptyObject (t)}}; var Y = new G, Q = novo G, J = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, K = / [AZ] / g; função Z (e , t, n) {var r, i; if (vazio 0 === n && 1 === e.nodeType) if (r = "dados -" + t.substituir (K, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {try {n = "true" === (i = n) || "false"! == i && ("null" === i? null: i === + i + ""? + i: J.test (i)? JSON.parse (i): i)} catch (e ) {} Q.set (e, t, n)} else n = void 0; retornar n} S.extend ({hasData: function (e) {return Q.hasData (e) || Y.hasData (e) }, data: function (e, t, n) {return Q.access (e, t, n)}, removeData: function (e, t) {Q.remove (e, t)}, _ data: function (e , t, n) {return Y.access (e, t, n)}, _ removeData: function (e, t) {Y.remove (e, t)}}), S.fn.extend ({data: function (n, e) {var t, r, i, o = this [0], a = o && o.attributes; if (void 0 === n) {if (this.length && (i = Q.get (o) , 1 === o.nodeType &&! Y.get (o, "hasDataAttrs"))) {t = a.length; while (t -) a [t] && 0 === (r = a [t]. nome) .indexOf ("dados -") && (r = X (r.slice (5)), Z (o, r, i [r])); Y.set (o, "hasDataAttrs",! 0)} return i} return "object" == typeof n? This.each (function () {Q.set (this, n)}): $ (this, function (e) {var t; if ( o && void 0 === e) return void 0! == (t = Q.get (o, n))? t: void 0! == (t = Z (o, n))? t: void 0; this .each (function () {Q.set (this, n, e)})}, null, e, 1 <arguments.length, null,! 0)}, removeData: function (e) {return this.each ( function () {Q.remove (this, e)})}}), S.extend ({queue: function (e, t, n) {var r; if (e) return t = (t || "fx ") +" fila ", r = Y.get (e, t), n && (! r || Array.isArray (n)? r = Y.access (e, t, S.makeArray (n)): r .push (n)), r || []}, desenfileirar: function (e, t) {t = t || "fx"; var n = S.queue (e, t), r = n.length, i = n.shift (), o = S._queueHooks (e, t); "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n. unshift ("inprogress"), delete o.stop, i.call (e, function () {S.dequeue (e, t)}, o)) ,! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; retornar Y.get (e, n) || Y.access (e, n, {vazio: S.Callbacks ("uma vez memória "). add (function () {Y.remove (e, [t +" fila ", n])})})}}), S.fn.extend ({queue: function (t, n) {var e = 2; return "string"! = typeof t && (n = t, t = "fx", e -), arguments.length <e? S.queue (this [0], t): void 0 == = n? this: this.each (function () {var e = S.queue (this, t, n); S._queueHooks (this, t), "fx" === t && "inprogress"! == e [0] && S.dequeue (this, t)})}, desenfileirar: function (e) {return this.each (function () {S.dequeue (this, e)})}, clearQueue: function (e) { return this.queue (e || "fx", [])}, promessa: function (e, t) {var n, r = 1, i = S.Deferred (), o = this, a = this.length , s = function () {- r || i.resolveWith (o, [o])}; "string"! = typeof e && (t = e, e = void 0), e = e || "fx" ; enquanto (a -) (n = Y.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add (s)); return s (), i.promise (t)}}); var ee = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, te = new RegExp ("^ (?: ([+ -]) = |) ("+ ee +") ([az%] *) $ "," i "), ne = [" Superior "," Direita "," Inferior "," Esquerda "], re = E.documentElement, ie = function (e) {return S.contains (e.ownerDocument, e)}, oe = {composite:! 0}; re.getRootNode && (ie = function (e) {return S.contains (e.ownerDocument, e ) || e.getRootNode (oe) === e.ownerDocument}); var ae = function (e, t) {return "none" === (e = t || e) .style.display || " "=== e.style.display && ie (e) &&" none "=== S.css (e," display ")}; função se (e, t, n, r) {var i, o, a = 20, s = r? Function () {return r.cur ()}: function () {return S.css (e, t, "")}, u = s (), l = n && n [3] || (S.cssNumber [t]? "":" px "), c = e.nodeType && (S.cssNumber [t] ||" px "! == l && + u) && te.exec (S.css (e, t)); if (c && c [3 ]! == l) {u / = 2, l = l || c [3], c = + u || 1; enquanto (a -) S.style (e, t, c + l), ( 1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, S.style (e, t, c + l), n = n || []} retorna n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var ue = {}; função le (e, t) {for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c <f; c ++) (r = e [c]). estilo && (n = r.style.display, t? ("nenhum" === n && (l [c] = Y.get (r, "exibir") || nulo, l [c] || (r.style.display = "")), "" === r.style.display && ae (r) && (l [c] = (u = a = o = void 0, a = (i = r) .ownerDocument, s = i.nodeName, (u = ue [s ]) || (o = a.body.appendChild (a.createElement (s)), u = S.css (o, "exibir"), o.parentNode.removeChild (o), "nenhum"=== u && (u = "bloquear"), ue [s] = u)))): "nenhum"! == n && (l [c] = "nenhum", Y.set (r, "exibir", n))); para (c = 0; c <f; c ++) null! = l [c] && (e [c] .style.display = l [c]); return e} S.fn.extend ( {show: function () {return le (this,! 0)}, ocultar: function () {return le (this)}, alternar: function (e) {return "boolean" == typeof e? e? this. show (): this.hide (): this.each (function () {ae (this)? S (this) .show (): S (this) .hide ()})}}); var ce, fe , pe = / ^ (?: caixa de seleção | rádio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, he = / ^ $ | ^ module $ | \ / (?: java | ecma) script / i; ce = E.createDocumentFragment (). appendChild (E.createElement ("div")), (fe = E.createElement ("input" )). setAttribute ("tipo", "rádio"), fe.setAttribute ("verificado", "verificado"), fe.setAttribute ("nome", "t"), ce.appendChild (fe), y.checkClone = ce.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, ce.innerHTML = "<textarea> x </textarea>", y.noCloneChecked = !! ce.cloneNode (! 0) .lastChild.defaultValue, ce .innerHTML = "<option> </option>", y.option = !! ce.lastChild; var ge = {thead: [1, "<table>", "</table>"], col: [2 , "<table> <colgroup>", "</colgroup> </table>"], tr: [2, "<table> <tbody>", "</tbody> </table>"], td: [3, "<table> <tbody> <tr>", "</tr> </tbody> </table>"], _ padrão: [0, "", ""]}; função ve (e, t ) {var n; return n = "undefined"! = typeof e.getElementsByTagName? e.getElementsByTagName (t || "*"): "undefined"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*" ): [],vazio 0 === t || t && A (e, t)? S.merge ([e], n): n} função ye (e, t) {para (var n = 0, r = e.length; n <r; n ++) Y.set (e [n], "globalEval",! t || Y.get (t [n], "globalEval"))} ge.tbody = ge.tfoot = ge.colgroup = ge .caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple = 'multiple'>", "</select>"] ); var me = / <| & #? \ w +; /; função xe (e, t, n, r, i) {para (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; d <h; d ++) if ((o = e [d]) || 0 === o) if ("objeto" === w (o)) S.merge (p, o.nodeType? [o]: o); senão if (me.test (o)) {a = a || f.appendChild (t.createElement ("div") ), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + S.htmlPrefilter (o) + u [2], c = u [0]; enquanto (c -) a = a.lastChild; S.merge (p, a.childNodes), (a = f.firstChild). textContent = ""} else p.push (t.createTextNode (o)); f.textContent = "", d = 0; enquanto (o = p [d ++]) if (r && - 1 <S.inArray (o, r)) i && i.push (o ); else if (l = ie (o), a = ve (f.appendChild (o), "script"), l && ye (a), n) {c = 0; enquanto (o = a [c ++]) ele .test (o.type || "") && n.push (o)} return f} var be = / ^ tecla /, we = / ^ (?: mouse | ponteiro | menu de contexto | arrastar | soltar) | clicar /, Te = / ^ ([^.] *) (?: \. (. +) |) /; Função Ce () {retornar! 0} função Ee () {retornar! 1} função Se (e, t) { return e === function () {try {return E.activeElement} catch (e) {}} () == ("focus" === t)} função ke (e, t, n, r, i, o) {var a, s; if ("objeto" == tipo de t) {for (s em "string"! = tipo de n && (r = r || n, n = vazio 0), t) ke (e, s, n, r, t [s], o); retornar e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("string" == typeof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)) ,! 1 === i) i = Ee; senão if (! i) return e;retornar 1 === o && (a = i, (i = função (e) {retornar S (). off (e), a.aplicar (isto, argumentos)}). guid = a.guid || (a. guid = S.guid ++)), e.each (função () {S.event.add (this, t, i, r, n)})} função Ae (e, i, o) {o? (Y. set (e, i,! 1), S.event.add (e, i, {namespace:! 1, handler: function (e) {var t, n, r = Y.get (this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (S.event.special [i] || {}). DelegateType && e.stopPropagation (); else if (r = s.call (argumentos), Y. set (this, i, r), t = o (this, i), this [i] (), r! == (n = Y.get (this, i)) || t? Y.set (this , i,! 1): n = {}, r! == n) return e.stopImmediatePropagation (), e.preventDefault (), n.value} else r.length && (Y.set (this, i, {value : S.event.trigger (S.extend (r [0], S.Event.prototype), r.slice (1), este)}), e.stopImmediatePropagation ())}})): void 0 == = Y.get (e, i) && S.event.add (e, i, Ce)} S.event = {global: {}, adicione: função (t, e, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Y.get (t); if (V (t)) {n.handler && (n = (o = n) .handler, i = o.selector), i && S.find.matchesSelector (re, i), n.guid || (n.guid = S.guid ++), (u = v. eventos) || (u = v.events = Object.create (null)), (a = v.handle) || (a = v.handle = function (e) {return "undefined"! = typeof S && S.event .triggered! == e.type? S.event.dispatch.apply (t, argumentos): void 0}), l = (e = (e || ""). match (P) || [""] ) .comprimento; enquanto (l -) d = g = (s = Te.exec (e [l]) || []) [1], h = (s [2] || ""). dividir ( "."). sort (), d && (f = S.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = S.event.special [d] || {}, c = S.extend ({type: d, origType: g, data: r, handler: n, guid: n.guid, seletor: i, needsContext: i && S.expr.match.needsContext .test (i), namespace: h.join (".")}, o), (p = u [d]) || ((p = u [d] = []). delegateCount = 0, f. setup &&! 1! == f.setup.call (t, r, h, a) || t.addEventListener && t.addEventListener (d,a)), f.add && (f.add.call (t, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p.delegateCount ++, 0 , c): p.push (c), S.event.global [d] =! 0)}}, remover: função (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData (e) && Y.get (e); if (v && (u = v.events)) {l = (t = (t || "") .match (P) || [""]). length; while (l -) if (d = g = (s = Te.exec (t [l]) || []) [1] , h = (s [2] || ""). split ("."). sort (), d) {f = S.event.special [d] || {}, p = u [d = ( r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |) ") +" (\\. | $) "), a = o = p.length; enquanto (o -) c = p [o] ,! i && g! == c.origType | | n && n.guid! == c.guid || s &&! s.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! c.selector) || ( p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e,c)); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, v.handle) || S.removeEvent (e, d, v.handle), delete u [ d])} else for (d in u) S.event.remove (e, d + t [l], n, r,! 0); S.isEmptyObject (u) && Y.remove (e, "manipular eventos" )}}, despacho: função (e) {var t, n, r, i, o, a, s = novo Array (argumentos.comprimento), u = S.event.fix (e), l = (Y. get (this, "events") || Object.create (null)) [u.type] || [], c = S.event.special [u.type] || {}; for (s [0] = u, t = 1; t <argument.length; t ++) s [t] = argumentos [t]; if (u.delegateTarget = this,! c.preDispatch ||! 1! == c.preDispatch.call ( este, u)) {a = S.event.handlers.call (n, r, i, o, a, s = novo Array (argumentos.comprimento), u = S.event.fix (e), l = (Y.get (this, "eventos") || Object.create ( null)) [u.type] || [], c = S.event.special [u.type] || {}; for (s [0] = u, t = 1; t <arguments.length; t ++ ) s [t] = argumentos [t]; if (u.delegateTarget = this,! c.preDispatch ||! 1! == c.preDispatch.call (this, u)) {a = S.event.handlers. chamar(n, r, i, o, a, s = novo Array (argumentos.comprimento), u = S.event.fix (e), l = (Y.get (this, "eventos") || Object.create ( null)) [u.type] || [], c = S.event.special [u.type] || {}; for (s [0] = u, t = 1; t <arguments.length; t ++ ) s [t] = argumentos [t]; if (u.delegateTarget = this,! c.preDispatch ||! 1! == c.preDispatch.call (this, u)) {a = S.event.handlers. chamar(this, u, l), t = 0; while ((i = a [t ++]) &&! u.isPropagationStopped ()) {u.currentTarget = i.elem, n = 0; while ((o = i.handlers [n ++]) &&! u.isImmediatePropagationStopped ()) u.rnamespace &&! 1! == o.namespace &&! u.rnamespace.test (o.namespace) || (u.handleObj = o, u.data = o.data , void 0! == (r = ((S.event.special [o.origType] || {}). handle || o.handler) .apply (i.elem, s)) &&! 1 === (u.result = r) && (u.preventDefault (), u.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (this, u), u.result}}, manipuladores: função (e, t ) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e. botão)) para (; l! == this; l = l.parentNode || this) if (1 === l.nodeType && ("click"! == e.type ||! 0! == l.disabled )) {para (o = [], a = {}, n = 0; n <u; n ++) vazio 0 === a [i = (r = t [n]). seletor + ""] &&(a [i] = r.needsContext? -1 <S (i, this) .index (l): S.find (i, this, null, [l]). length), a [i] && o.push (r); o.length && s.push ({elem: l, manipuladores: o})} return l = this, u <t.length && s.push ({elem: l, manipuladores: t.slice (u)}), s}, addProp: function (t, e) {Object.defineProperty (S.Event.prototype, t, {enumerable:! 0, configurable:! 0, get: m (e)? function () {if (this. originalEvent) return e (this.originalEvent)}: function () {if (this.originalEvent) return this.originalEvent [t]}, set: function (e) {Object.defineProperty (this, t, {enumerable:! 0 , configurável:! 0, gravável:! 0, valor: e})}})}, corrigir: função (e) {retornar e [S.expando]? e: novo S.Event (e)}, especial: { carregar: {noBubble:! 0}, clique em: {setup: function (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && Ae (t, "clique", Ce) ,! 1}, acionador: função (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && Ae (t, "click") ,! 0}, _ default: function (e) {var t = e.target; return pe.test (t.type) && t.click && A (t, "input") && Y.get (t, "click") || A (t, "a")}}, beforeunload: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e. originalEvent.returnValue = e.result)}}}}, S.removeEvent = function (e, t, n) {e.removeEventListener && e.removeEventListener (t, n)}, S.Event = function (e, t) {if (! (this instanceof S.Event)) return new S.Event (e, t); e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? Ce: Ee, this.target = e.target && 3 === e.target.nodeType? E.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): isso.type = e, t && S.extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [S.expando] =! 0}, S.Event.prototype = {construtor: S. Event, isDefaultPrevented: Ee, isPropagationStopped: Ee, isImmediatePropagationStopped: Ee, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ce, e &&! This.isSSimulated, stop. : function () {var e = this.originalEvent; this.isPropagationStopped = Ce, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ce, e this.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()}}, S.each ({altKey:! 0, bubbles:! 0, cancelável:! 0, changedTouches:! 0, ctrlKey:! 0, detalhe:! 0 , eventPhase:! 0, metaKey:! 0, pageX:! 0, pageY:! 0, shiftKey:! 0, visualizar:! 0, "char ":! 0, code:! 0, charCode:! 0, key:! 0, keyCode:! 0, button:! 0, buttons:! 0, clientX:! 0, clientY:! 0, offsetX:! 0 , offsetY:! 0, pointerId:! 0, pointerType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que: function (e) {var t = e.button; return null == e.which && be.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && we.test (e.type )? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, S.event.addProp), S.each ({focus: "focusin", blur: "focusout"}, função (e , t) {S.event.special [e] = {setup: function () {return Ae (this, e, Se) ,! 1}, trigger: function () {return Ae (this, e) ,! 0 }, delegateType: t}}), S.each ({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, function (e, i) {S.event. especial [e] = {delegateType: i, bindType: i, identificador:function (e) {var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains (this, n)) || (e.type = r.origType, t = r.handler.apply (this, arguments), e.type = i), t}}}), S.fn.extend ({on: function (e, t, n, r) {return ke (this , e, t, n, r)}, um: função (e, t, n, r) {retornar ke (este, e, t, n, r, 1)}, off: função (e, t, n ) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), this; if ("object" == typeof e) {for (i in e) this.off (i, t, e [i]); return this} return! 1! = = t && "função"! = typeof t || (n = t, t = void 0) ,! 1 === n && (n = Ee), this.each (function () {S.event.remove (this, e, n, t)})}}); var Ne = / <script | <estilo | <link / i, De = / verificado \ s * (?: [^ =] | = \ s *. verificado.) / i, je = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; função qe (e,t) {return A (e, "table") && A (11! == t.nodeType? t: t.firstChild, "tr") && S (e) .children ("tbody") [0] || e} função Le (e) {return e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e} função He (e) {return "true /" === (e.type || ""). slice (0,5)? e.type = e.type.slice (5): e.removeAttribute ("type"), e} função Oe (e, t) {var n, r, i, o, a, s; if (1 === t.nodeType) {if (Y.hasData (e) && (s = Y.get (e) .events)) para (i in Y .remove (t, "manipular eventos"), s) for (n = 0, r = s [i] .length; n <r; n ++) S.event.add (t, i, s [i] [n ]); Q.hasData (e) && (o = Q.acesso (e), a = S.extend ({}, o), Q.set (t, a))}} função Pe (n, r, i, o) {r = g (r); var e, t, a, s, u, l, c = 0, f = n.length, p = f-1, d = r [0], h = m (d); if (h || 1 <f && "string" == typeof d &&! y.checkClone && De.test (d)) return n.each (function (e) {var t = n.eq (e); h && (r [0] = d.call (this, e, t.html ())), Pe (t, r, i, o)}); if (f && (t = (e = xe (r, n) [0] .ownerDocument,! 1, n, o)). FirstChild, 1 === e.childNodes.length && (e = t), t || o)) {for (s = (a = S.map ( ve (e, "script"), Le)). comprimento; c <f; c ++) u = e, c! == p && (u = S.clone (u,! 0,! 0), s && S.merge ( a, ve (u, "script"))), i.call (n [c], u, c); if (s) para (l = a [a.length-1] .ownerDocument, S.map ( a, He), c = 0; c <s; c ++) u = a [c], he.test (u.type || "") &&! Y.access (u, "globalEval") && S.contains ( l, u) && (u.src && "module"! == (u.type || ""). toLowerCase ()? S._evalUrl &&! u.noModule && S._evalUrl (u.src, {nonce: u.nonce | | u.getAttribute ("nonce")}, l): b (u.textContent.replace (je, ""), u, l))} retorno n} função Re (e, t, n) {for (var r, i = t? S.filtro (t, e): e, o = 0; nulo! = (r = i [o]); o ++) n || 1! == r.nodeType || S.cleanData (ve (r)), r.parentNode && (n && ie (r) && ye (ve (r, "script")), r.parentNode.removeChild (r)); return e} S.extend ({htmlPrefilter: function ( e) {return e}, clone: ​​function (e, t, n) {var r, i, o, a, s, u, l, c = e.cloneNode (! 0), f = ie (e); if (! (y.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || S.isXMLDoc (e))) for (a = ve (c), r = 0, i = (o = ve (e)). comprimento; r <i; r ++) s = o [r], u = a [r], vazio 0, "entrada" === (l = u.Nome do nó.toLowerCase ()) && pe. test (s.type)? u.checked = s.checked: "input"! == l && "textarea"! == l || (u.defaultValue = s.defaultValue); if (t) if (n) para (o = o || ve (e), a = a || ve (c), r = 0, i = o.length; r <i; r ++) Oe (o [r], a [r]); else Oe (e, c); return 0 <(a = ve (c, "script")). length && ye (a,! f && ve (e, "script")), c}, cleanData: function (e) {for (var t, n, r, i = S.event.special, o = 0; vazio 0! == (n = e [o]);o ++) if (V (n)) {if (t = n [Y.expando]) {if (t.eventos) para (r em t.eventos) i [r]? S.event.remove (n, r ): S.removeEvent (n, r, t.handle); n [Y.expando] = vazio 0} n [Q.expando] && (n [Q.expando] = vazio 0)}}}), S. fn.extend ({desanexar: função (e) {retornar Re (este, e,! 0)}, remover: função (e) {retornar Re (este, e)}, texto: função (e) {retornar $ ( this, function (e) {return void 0 === e? S.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)})}, null, e, arguments.length)}, acrescente: function () {return Pe (this, arguments, function (e) {1! == this. nodeType && 11! == this.nodeType && 9! == this.nodeType || qe (this, e) .appendChild (e)})}, prefixo: function () {return Pe (this, arguments, function (e) {if ( 1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = qe (this, e); t.insertBefore (e, t.firstChild)}}) },antes de:function () {return Pe (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, after: function () {return Pe (this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vazio: function () {for (var e, t = 0; null! = (e = this [t]); t ++) 1 == = e.nodeType && (S.cleanData (ve (e,! 1)), e.textContent = ""); retornar isso}, clone: ​​função (e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return S.clone (this, e, t)})}, html: function (e) {return $ (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e &&! Ne.test (e) &&! Ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ()]) {e = S.htmlPrefilter (e); tente {for ( ; n <r; n ++) 1 === (t = this [n] || {}). nodeType && (S.cleanData (ve (t,! 1)),t.innerHTML = e); t = 0} catch (e) {}} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var n = [ ]; retornar Pe (this, argumentos, função (e) {var t = this.parentNode; S.inArray (this, n) <0 && (S.cleanData (ve (this)), t && t.replaceChild (e, this) )}, n)}}), S.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (e, a ) {S.fn [e] = função (e) {para (var t, n = [], r = S (e), i = r.length-1, o = 0; o <= i; o ++) t = o === i? this: this.clone (! 0), S (r [o]) [a] (t), u.apply (n, t.get ()); return this.pushStack ( n)}}); var Me = new RegExp ("^ (" + ee + ") (?! px) [az%] + $", "i"), Ie = função (e) {var t = e. ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle (e)}, We = function (e, t, n) {var r, i, o = {}; for (i in t ) o [i] = e.style [i], e.style [i] = t [i]; for (i in r = n.call (e), t) e.style [i] = o [i]; return r}, Fe = new RegExp (ne.join ("|"), "i"); função Be (e, t, n) {var r, i, o, a, s = e.style; return (n = n || Ie (e)) && (""! == (a = n.getPropertyValue (t) || n [t]) || ie (e) || (a = S.style (e, t)) ,! y .pixelBoxStyles () && Me.test (a) && Fe.test (t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} função $ e (e, t) {return { get: function () {if (! e ()) return (this.get = t) .apply (this, arguments); delete this.get}}}! function () {function e () {if (l) {u.style.cssText = "position: absolute; left: -11111px; width: 60px; margin-top: 1px; padding: 0; border: 0", l.style.cssText = "position: relative; display: block ; box-sizing: border-box; overflow: scroll; margin: auto; border: 1px; padding: 1px; largura:60%; superior: 1% ", re.appendChild (u) .appendChild (l); var e = C.getComputedStyle (l); n =" 1% "! == e.top, s = 12 === t (e.marginLeft), l.style.right = "60%", o = 36 === t (e.right), r = 36 === t (e.width), l.style.position = "absoluto", i = 12 === t (l.offsetWidth / 3), re.removeChild (u), l = null}} função t (e) {return Math.round (parseFloat (e))} var n , r, i, o, a, s, u = E.createElement ("div"), l = E.createElement ("div"); l.style && (l.style.backgroundClip = "content-box", l .cloneNode (! 0) .style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend (y, {boxSizingReliable: function () {return e (), r}, pixelBoxStyles: function () {return e (), o}, pixelPosition: function () {return e (), n}, trustedMarginLeft: function () {return e (), s}, scrollboxSize: function () {return e (), i}, TrustTrDimensions: function () {var e, t, n, r;return null == a && (e = E.createElement ("table"), t = E.createElement ("tr"), n = E.createElement ("div"), e.style.cssText = "position: absoluto; esquerda: -11111px ", t.style.height =" 1px ", n.style.height =" 9px ", re.appendChild (e) .appendChild (t) .appendChild (n), r = C.getComputedStyle (t ), a = 3 <parseInt (r.height), re.removeChild (e)), a}}))} (); var _e = ["Webkit", "Moz", "ms"], ze = E .createElement ("div"). style, Ue = {}; função Xe (e) {var t = S.cssProps [e] || Ue [e]; return t || (e in ze? e: Ue [ e] = função (e) {var t = e [0] .toUpperCase () + e.slice (1), n ​​= _e.length; enquanto (n -) if ((e = _e [n] + t ) in ze) return e} (e) || e)} var Ve = / ^ (none | table (?! - c [ea]). +) /, Ge = / ^ - /, Ye = {position : "absoluto", visibilidade: "oculto", exibição: "bloquear"}, Qe = {letterSpacing: "0", fontWeight: "400"};função Je (e, t, n) {var r = te.exec (t); retornar r? Math.max (0, r [2] - (n || 0)) + (r [3] || " px "): t} função Ke (e, t, n, r, i, o) {var a =" largura "=== t? 1: 0, s = 0, u = 0; if (n == = (r? "borda": "conteúdo")) retorna 0; para (; a <4; a + = 2) "margem" === n && (u + = S.css (e, n + ne [a], ! 0, i)), r? ("Conteúdo" === n && (u- = S.css (e, "preenchimento" + ne [a] ,! 0, i)), "margem"! == n && (u- = S.css (e, "borda" + ne [a] + "Largura",! 0, i))) :( u + = S.css (e, "preenchimento" + ne [a] ,! 0, i), "preenchimento"! == n? U + = S.css (e, "borda" + ne [a] + "Largura",! 0, i): s + = S.css (e, "borda "+ ne [a] +" Largura ",! 0, i)); return! r && 0 <= o && (u + = Math.max (0, Math.ceil (e [" offset "+ t [0] .toUpperCase ( ) + t.slice (1)] - ous-.5)) || 0), u} função Ze (e, t, n) {var r = Ie (e), i = (! y.boxSizingReliable () || n) &&"border-box" === S.css (e, "boxSizing",! 1, r), o = i, a = Be (e, t, r), s = "deslocamento" + t [0]. toUpperCase () + t.slice (1); if (Me.test (a)) {if (! n) return a; a = "auto"} return (! y.boxSizingReliable () && i ||! y.reliableTrDimensions () && A (e, "tr") || "auto" === a ||! ParseFloat (a) && "inline" === S.css (e, "display",! 1, r)) && e .getClientRects (). length && (i = "border-box" === S.css (e, "boxSizing",! 1, r), (o = s em e) && (a = e [s])) , (a = parseFloat (a) || 0) + Ke (e, t, n || (i? "borda": "conteúdo"), o, r, a) + "px"} função et (e, t, n, r, i) {return new et.prototype.init (e, t, n, r, i)} S.extend ({cssHooks: {opacity: {get: function (e, t) {if ( t) {var n = Be (e, "opacity"); return "" === n? "1": n}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0,fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, gridArea:! 0, gridColumn:! 0, gridColumnEnd:! 0, gridColumnStart:! 0, gridRow:! 0, gridRowEnd:! 0, gridRowStart:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {}, style: function ( e, t, n, r) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i, o, a, s = X (t), u = Ge.test (t) , l = e.style; if (u || (t = Xe (s)), a = S.cssHooks [t] || S.cssHooks [s], void 0 === n) retorna a && "get" em um && void 0! == (i = a.get (e,! 1, r))? i: l [t]; "string" === (o = typeof n) && (i = te.exec (n )) && i [1] && (n = se (e, t, i), o = "número"), nulo! = n && n == n && ("número"! == o || u || (n + = i && i [3] || (S.cssNumber [s]? "": "Px")), y.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || ( l [t] = "herdar "), a &&" definir "em um && vazio 0 === (n = a.set (e, n, r)) || (u? l.setProperty (t, n): l [t] = n)) }}, css: function (e, t, n, r) {var i, o, a, s = X (t); return Ge.test (t) || (t = Xe (s)), (a = S.cssHooks [t] || S.cssHooks [s]) && "get" in a && (i = a.get (e,! 0, n)), void 0 === i && (i = Be (e , t, r)), "normal" === i && t em Qe && (i = Qe [t]), "" === n || n? (o = parseFloat (i) ,! 0 === n | | isFinite (o)? o || 0: i): i}}), S.each (["altura", "largura"], função (e, u) {S.cssHooks [u] = {obter: function (e, t, n) {if (t) return! Ve.test (S.css (e, "display")) || e.getClientRects (). length && e.getBoundingClientRect (). width? Ze (e, u, n): We (e, Ye, function () {return Ze (e, u, n)})}, set: function (e, t, n) {var r, i = Ie (e), o =! y.scrollboxSize () && "absoluto" === i.position, a = (o || n) && "border-box" === S.css (e, "boxSizing ",! 1, i), s = n? Ke (e, u, n, a, i): 0; retornar a && o && (s- = Math.ceil (e [" offset "+ u [0] .toUpperCase () + u.slice (1)] - parseFloat (i [u]) - Ke (e, u, "fronteira",! 1, i) -. 5)), s && (r = te.exec (t) ) && "px"! == (r [3] || "px") && (e.style [u] = t, t = S.css (e, u)), Je (0, t, s) }}}), S.cssHooks.marginLeft = $ e (y.reliableMarginLeft, function (e, t) {if (t) return (parseFloat (Be (e, "marginLeft")) || e.getBoundingClientRect (). left-We (e, {marginLeft: 0}, function () {return e.getBoundingClientRect (). left})) + "px"}), S.each ({margin: "", padding: "", border : "Largura"}, função (i, o) {S.cssHooks [i + o] = {expandir: função (e) {para (var t = 0, n = {}, r = "string" == typeof e? e.split (""): [e]; t <4; t ++) n [i + ne [t] + o] = r [t] || r [t-2] || r [0] ; return n}}, "margin"! == i && (S.cssHooks [i + o].set = Je)}), S.fn.extend ({css: function (e, t) {return $ (this, function (e, t, n) {var r, i, o = {}, a = 0 ; if (Array.isArray (t)) {for (r = Ie (e), i = t.length; a <i; a ++) o [t [a]] = S.css (e, t [a] ,! 1, r); return o} return void 0! == n? S.style (e, t, n): S.css (e, t)}, e, t, 1 <arguments.length)} }), ((S.Tween = et) .protótipo = {construtor: et, init: função (e, t, n, r, i, o) {this.elem = e, this.prop = n, this. easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (S.cssNumber [n ]? "": "px")}, cur: function () {var e = et.propHooks [this.prop]; return e && e.get? e.get (this): et.propHooks._default.get (this )}, execute: function (e) {var t, n = et.propHooks [this.prop]; retornar this.options.duration? this.pos = t = S.easing [this.easing] (e, this. options.duration * e, 0,1, this.options.duration): this.pos = t = e, this.now = (this.end-this.start) * t + this.start, this.options.step && this .options.step.call (this.elem, this.now, this), n && n.set? n.set (this): et.propHooks._default.set (this), this}}). init.prototype = et. prototype, (et.propHooks = {_ default: {get: function (e) {var t; return 1! == e.elem.nodeType || null! = e.elem [e.prop] && null == e.elem .style [e.prop]? e.elem [e.prop] :( t = S.css (e.elem, e.prop, "")) && "auto"! == t? t: 0}, conjunto: função (e) {S.fx.step [e.prop]? S.fx.step [e.prop] (e): 1! == e.elem.nodeType ||! S.cssHooks [e. prop] && null == e.elem.style [Xe (e.prop)]? e.elem [e.prop] = e.now: S.style (e.elem, e.prop, e.now + e. unidade)}}}). scrollTop = et.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, S .easing = {linear: function (e) {return e}, swing: function (e) {return.5-Math.cos (e * Math.PI) / 2}, _ default: "swing"}, S.fx = et.prototype.init, S.fx.step = {}; var tt, nt, rt, it,ot = / ^ (?: toggle | show | hide) $ /, at = / queueHooks $ /; função st () {nt && (! 1 === E.hidden && C.requestAnimationFrame? C.requestAnimationFrame (st): C. setTimeout (st, S.fx.interval), S.fx.tick ())} função ut () {return C.setTimeout (function () {tt = void 0}), tt = Date.now ()} função lt (e, t) {var n, r = 0, i = {altura: e}; para (t = t? 1: 0; r <4; r + = 2-t) i ["margem" + (n = ne [r])] = i ["preenchimento" + n] = e; retornar t && (i.opacidade = i.width = e), i} função ct (e, t, n) {para (var r, i = (ft.tweeners [t] || []). concat (ft.tweeners ["*"]), o = 0, a = i.length; o <a; o ++) if (r = i [o ] .call (n, t, e)) return r} função ft (o, e, t) {var n, a, r = 0, i = ft.prefilters.length, s = S.Deferred (). sempre (function () {delete u.elem}), u = function () {if (a) return! 1; for (var e = tt || ut (), t = Math.max (0, l.startTime + l.duração-e), n = 1- (t / l.duração || 0), r = 0, i = l.tweens.length; r <i; r ++) l.tweens [r] .run (n ); retornar s.notifyWith (o, [l,n, t]), n <1 && i? t: (i || s.notifyWith (o, [l, 1,0]), s.resolveWith (o, [l]) ,! 1)}, l = s .promise ({elem: o, props: S.extend ({}, e), opts: S.extend (! 0, {specialEasing: {}, easing: S.easing._default}, t), originalProperties: e , originalOptions: t, startTime: tt || ut (), duration: t.duration, tweens: [], createTween: function (e, t) {var n = S.Tween (o, l.opts, e, t , l.opts.specialEasing [e] || l.opts.easing); retornar l.tweens.push (n), n}, parar: função (e) {var t = 0, n = e? l.tweens .length: 0; se (a) retornar isso; para (a =! 0; t <n; t ++) l.tweens [t] .run (1); retornar e? (s.notifyWith (o, [l, 1,0]), s.resolveWith (o, [l, e])): s.rejectWith (o, [l, e]), este}}), c = l.props; for (! Função (e , t) {var n, r, i, o, a; para (n em e) if (i = t [r = X (n)], o = e [n], Array.isArray (o) && ( i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, excluir e [n]), (a = S.cssHooks [r]) && "expandir" em a) para (n em o = a.expandir (o), excluir e [r], o) n em e || (e [n] = o [n], t [n] = i );else t [r] = i} (c, l.opts.specialEasing); r <i; r ++) if (n = ft.prefilters [r] .call (l, o, c, l.opts)) return m (n.stop) && (S._queueHooks (l.elem, l.opts.queue) .stop = n.stop.bind (n)), n; return S.map (c, ct, l), m ( l.opts.start) && l.opts.start.call (o, l), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts .fail) .always (l.opts.always), S.fx.timer (S.extend (u, {elem: o, anim: l, queue: l.opts.queue})), l} S.Animation = S.extend (ft, {tweeners: {"*": [function (e, t) {var n = this.createTween (e, t); return se (n.elem, e, te.exec (t) , n), n}]}, interpolador: função (e, t) {m (e)? (t = e, e = ["*"]): e = e.match (P); para (var n , r = 0, i = e.length; r <i; r ++) n = e [r], ft.tweeners [n] = ft.tweeners [n] || [], ft.tweeners [n] .unshift (t)}, pré-filtros: [função (e, t, n) {var r, i, o, a, s, u, l, c, f = "largura" em t || "altura" em t, p = this, d = {}, h = e.style, g = e.nodeType && ae (e), v = Y.get (e,"fxshow"); for (r in n.queue || (null == (a = S._queueHooks (e, "fx")). não enfileirado && (a.unqueued = 0, s = a.empty.fire, a .empty.fire = function () {a.unqueued || s ()}), a.unqueued ++, p.always (function () {p.always (function () {a.unqueued -, S.queue ( e, "fx"). comprimento || a.empty.fire ()})})), t) if (i = t [r], ot.test (i)) {if (delete t [r], o = o || "toggle" === i, i === (g? "hide": "show")) {if ("show"! == i ||! v || void 0 === v [r]) continue; g =! 0} d [r] = v && v [r] || S.style (e, r)} if ((u =! S.isEmptyObject (t)) ||! S. isEmptyObject (d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y .get (e, "exibir")), "nenhum" === (c = S.css (e, "exibir")) && (l? c = l: (le ([e] ,! 0), l = e.style.display || l, c = S.css (e, "exibir"), le ([e]))), ("inline "=== c ||" inline-block "=== c && null! = l) &&" none "=== S.css (e," float ") && (u || (p.done (function ( ) {h.display = l}), null == l && (c = h.display, l = "none" === c? "": c)), h.display = "inline-block")), n.overflow && (h.overflow = "escondido", p.always (function () {h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [ 2]})), u =! 1, d) u || (v? "Oculto" em v && (g = v.hidden): v = Y.access (e, "fxshow", {display: l}) , o && (v.hidden =! g), g && le ([e] ,! 0), p.done (function () {for (r in g || le ([e]), Y.remove (e, " fxshow "), d) S.style (e, r, d [r])})), u = ct (g? v [r]: 0, r, p), r em v || (v [r ] = u.start, g && (u.end = u.start, u.start = 0))}], pré-filtro: função (e, t) {t? ft.prefilters.unshift (e): ft.prefilters. push (e)}}), S. velocidade = função (e, t, n) {var r = e && "objeto" == typeof e? S.extend ({}, e): {complete: n ||! n && t || m (e) && e, duration: e, easing: n && t || t &&! m (t) && t}; return S.fx.off?r.duration=0:"number"!=typeof r.duration && (r.duration in S.fx.speeds? r.duration = S.fx.speeds [r.duration] : r.duration = S.fx.speeds._default), null! = r.queue &&! 0! == r.queue || (r.queue = "fx"), r.old = r.complete, r. complete = function () {m (r.old) && r.old.call (this), r.queue && S.dequeue (this, r.queue)}, r}, S.fn.extend ({fadeTo: function (e , t, n, r) {return this.filter (ae) .css ("opacity", 0) .show (). end (). animate ({opacity: t}, e, n, r)}, anime : função (t, e, n, r) {var i = S.isEmptyObject (t), o = S.velocidade (e, n, r), a = função () {var e = ft (this, S. extend ({}, t), o); (i || Y.get (this, "terminar")) && e.stop (! 0)}; retornar a.finish = a, i ||! 1 === o.queue? this.each (a): this.queue (o.queue, a)}, stop: function (i, e, o) {var a = function (e) {var t = e.stop; delete e.stop, t (o)}; return "string "! = typeof i && (o = e, e = i, i = void 0), e && this.queue (i ||" fx ", []), this.each (function () {var e =! 0, t = null! = i && i + "queueHooks", n = S.timers, r = Y.get (this); if (t) r [t] && r [t] .stop && a (r [t]); else for (t in r) r [t] && r [t] .parar && at.test (t) && a (r [t]); para (t = n.length; t -;) n [t] .elem! == isto || null! = i && n [t] .queue! == i || (n [t] .anim.stop (o), e =! 1, n.splice (t, 1)) ;! e && o || S.dequeue (this, i)})}, termine: function (a) {return! 1! == a && (a = a || "fx"), this.each (function () {var e, t = Y.get (this), n = t [a + "queue"], r = t [a + "queueHooks"], i = S.timers, o = n? n.length: 0; for (t.finish =! 0, S .queue (this, a, []), r && r.stop && r.stop.call (this,! 0), e = i.length; e -;) i [e].elem === this && i [e] .queue === a && (i [e] .anim.stop (! 0), i.splice (e, 1)); para (e = 0; e <o; e ++) n [e] && n [e] .finish && n [e] .finish.call (this); delete t.finish})}}), S.each (["alternar", "mostrar", "ocultar"], função (e, r) {var i = S.fn [r]; S.fn [r] = função (e, t, n) {return null == e || "booleano" == typeof e? i.apply (isto, argumentos): this.animate (lt (r,! 0), e, t, n)}}), S.each ({slideDown: lt ("show"), slideUp: lt ("ocultar") , slideToggle: lt ("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (e, r) {S. fn [e] = função (e, t, n) {retornar este.animado (r, e, t, n)}}), S.timers = [], S.fx.tick = função () {var e , t = 0, n = S.timers; para (tt = Date.now (); t <n.length; t ++) (e = n [t]) () || n [t]! == e | | n.splice (t -, 1); n.length || S.fx.stop (), tt = vazio 0}, S.fx.temporizador = função (e) {S.timers.push (e), S.fx.start ()}, S.fx.interval = 13, S.fx.start = função () {nt || (nt =! 0, st ())}, S.fx.stop = function () {nt = null}, S.fx.speeds = {slow: 600, fast: 200, _default: 400}, S.fn.delay = function (r, e) {return r = S.fx && S.fx.speeds [r] || r, e = e || "fx", this.queue (e, função (e, t) {var n = C. setTimeout (e, r); t.stop = function () {C.clearTimeout (n)}})}, rt = E.createElement ("input"), it = E.createElement ("select"). appendChild ( E.createElement ("option")), rt.type = "checkbox", y.checkOn = ""! == rt.value, y.optSelected = it.selected, (rt = E.createElement ("input") ) .value = "t", rt.type = "radio", y.radioValue = "t" === rt.value; var pt, dt = S.expr.attrHandle; S.fn.extend ({attr: function (e, t) {return $ (this, S.attr, e, t, 1 <arguments.length)}, removeAttr: function (e) {return this.each (function () {S.removeAttr (this, e)})}}), S.extend ({attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2 ! == o) return "undefined" == typeof e.getAttribute? S.prop (e, t, n) :( 1 === o && S.isXMLDoc (e) || (i = S.attrHooks [t.toLowerCase ()] || (S.expr.match.bool.test (t)? Pt: void 0)), void 0! == n? Null === n? Void S.removeAttr (e, t): i && "set" in i && void 0! == (r = i.set (e, n, t))? r: (e.setAttribute (t, n + ""), n): i && "get" in i && null! == (r = i.get (e, t))? r: null == (r = S.find.attr (e, t))? void 0: r)}, attrHooks: {type: {set: function ( e, t) {if (! y.radioValue && "radio" === t && A (e, "input")) {var n = e.value; return e.setAttribute ("type", t), n && (e. valor = n), t}}}}, removeAttr: função (e, t) {var n, r = 0, i = t && t.match (P); if (i && 1 === e.nodeType) enquanto (n = i [r ++]) e.removeAttribute (n)}}), pt = {set: function (e, t, n) {return! 1 === t? S.removeAttr (e, n): e.setAttribute (n, n), n} }, S.each (S.expr.match.bool.source.match (/ \ w + / g), função (e, t) {var a = dt [t] || S.find.attr; dt [t ] = função (e, t, n) {var r, i, o = t.toLowerCase (); retornar n || (i = dt [o], dt [o] = r, r = nulo! = a ( e, t, n)? o: nulo, dt [o] = i), r}}); var ht = / ^ (?: input | select | textarea | botão) $ / i, gt = / ^ (? : a | area) $ / i; função vt (e) {return (e.match (P) || []). join ("")} função yt (e) {return e.getAttribute && e.getAttribute ("class ") ||" "} função mt (e) {return Array.isArray (e)? e:" string "== typeof e && e.match (P) || []} S.fn.extend ({prop: function (e, t) {return $ (this, S.prop, e, t, 1 <arguments.length)}, removeProp: function (e) {return this.each (function () {delete this [S.propFix [ e] || e]})}}), S.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o &&2! == o) return 1 === o && S.isXMLDoc (e) || (t = S.propFix [t] || t, i = S.propHooks [t]), void 0! == n? I && "definir" em i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "obter" em i && null! == (r = i.get (e , t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = S.find.attr (e, "tabindex"); return t? parseInt (t, 10 ): ht.test (e.nodeName) || gt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {"for": "htmlFor", "class": "className" }}), y.optSelected || (S.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null}, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), S.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding "," rowSpan "," colSpan "," useMap "," frameBorder "," contentEditable "], function () {S.propFix [this.toLowerCase ()] = this}), S.fn.extend ({ addClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) return this.each (function (e) {S (this) .addClass ( t.call (this, e, yt (this)))}); if ((e = mt (t)). length) while (n = this [u ++]) if (i = yt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; enquanto (o = e [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + " "); i! == (s = vt (r)) && n.setAttribute (" class ", s)} retornar isso}, removeClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) retorna this.each (function (e) {S (this) .removeClass (t.call (this, e, yt (this)))}); if (! argumentos.comprimento) retornam this.attr ("classe", ""); if ((e = mt (t)). comprimento) enquanto (n = isto [u ++]) if (i = yt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; while (o = e [a ++]) while (-1 <r.indexOf ("" + o + "")) r = r.replace (" "+ o +" "," "); i! == (s = vt (r)) && n.setAttribute (" class ", s)} retornar isso}, toggleClass: function (i, t) {var o = typeof i, a = "string" === o || Array.isArray (i); return "boolean" == typeof t && a? t? this.addClass (i): this.removeClass (i): m (i)? this.each (function (e) {S (this) .toggleClass (i.call (this, e, yt (this), t), t)}): this.each (function () {var e, t, n, r; se (a) {t = 0, n = S (este), r = mt (i); enquanto (e = r [t ++]) n.hasClass (e)? n.removeClass (e): n.addClass (e)} else void 0! == i && "boolean"! == o || ((e = yt (this)) && Y.set (this, "__ className __", e), this.setAttribute && this.setAttribute ("class", e ||! 1 === i? "": Y.get (this, "__ className__") || ""))})}, hasClass: function (e) {var t, n, r = 0; t = "" + e + ""; enquanto (n = this [r ++]) if (1 == = n.nodeType && - 1 <("" + vt (yt (n)) + "") .indexOf (t)) return! 0; return! 1}}); var xt = / \ r / g; S. fn.extend ({val: function (n) {var r, e, i, t = this [0]; retornar argumentos.length? (i = m (n), this.each (function (e) {var t ; 1 === this.nodeType && (null == (t = i? N.call (this, e, S (this) .val ()): n)? T = "": "number" == typeof t ? t + = "": Array.isArray (t) && (t = S.map (t, função (e) {return null == e? "": e + ""})), (r = S.valHooks [ this.type] || S.valHooks [this.nodeName.toLowerCase ()]) && "set" in r && void 0! == r.set (this, t, "value") || (this.value = t) )})): t? (r = S.valHooks [t.type] || S.valHooks [t.nodeName.toLowerCase ()]) && "get" in r && void 0! == (e = r.get ( t, "valor "))? e:" string "== typeof (e = t.value)? e.replace (xt," "): null == e?" ": e: void 0}}), S.extend ({valHooks: {opção: {obter: função (e) {var t = S.find.attr (e, "valor"); retornar nulo! = t? t: vt (S.text (e))}} , selecione: {get: function (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a? null: [], u = a? o + 1: i.length; for (r = o <0? u: a? o: 0; r <u; r ++) if (((n = i [r]). selecionado || r === o) &&! n.disabled && (! n.parentNode.disabled ||! A (n.parentNode, "optgroup"))) {if (t = S (n) .val (), a ) retornar t; s.push (t)} retornar s}, definir: função (e, t) {var n, r, i = e.options, o = S.makeArray (t), a = i.length; while (a -) ((r = i [a]). selected = -1 <S.inArray (S.valHooks.option.get (r), o)) && (n =! 0); return n | | (e.selectedIndex = -1), o}}}}), S.each (["radio", "checkbox"], function () {S.valHooks [this] = {set: function (e, t ) {if (Array.isArray (t)) return e.checked = -1 <S.inArray (S (e) .val (), t)}}, y.checkOn || (S.valHooks [this] .get = function (e) {return null === e.getAttribute ("value")? "on": e.value})}), y.focusin = "onfocusin" em C; var bt = / ^ (?: focusinfocus | focusoutblur) $ /,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i, o, a, s, u, l , c, f, p = [n || E], d = v.call (e, "tipo")? e.type: e, h = v.call (e, "namespace")? e.namespace. split ("."): []; if (o = f = a = n = n || E, 3! == n.nodeType && 8! == n.nodeType &&! bt.test (d + S.event.triggered ) && (- 1 <d.indexOf (".") && (d = (h = d.split (".")). Shift (), h.sort ()), u = d.indexOf (": ") <0 &&" on "+ d, (e = e [S.expando]? E: novo S.Event (d," object "== typeof e && e)). IsTrigger = r? 2: 3, e.namespace = h.join ("."), e.rnamespace = e.namespace? new RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") + "(\\. | $)") : null, e.result = void 0, e.target || (e.target = n), t = null == t? [e]: S.makeArray (t, [e]), c = S.event .special [d] || {}, r ||! c.trigger ||! 1! == c.trigger.apply (n, t))) {if (! r &&! c.noBubble &&! x (n) ) {for (s = c.delegateType || d, bt.test (s + d) || (o = o.parentNode); o; o = o.parentNode) p.push (o), a = o; a === (n.ownerDocument || E) && p.push (a.defaultView || a.parentWindow || C)} i = 0; while ((o = p [i ++]) &&! e.isPropagationStopped () ) f = o, e.type = 1 <i? s: c.bindType || d, (l = (Y.get (o, "events") || Object.create (null)) [e.type] && Y.get (o, "lidar")) && l.apply (o, t), (l = u && o [u]) && l.apply && V (o) && (e.result = l.apply (o, t) ,! 1 === e.result && e.preventDefault ()); retornar e.type = d, r || e.isDefaultPrevented () || c._default &&!1! == c._default.apply (p.pop (), t) ||! V (n) || u && m (n [d]) &&! X (n) && ((a = n [u]) && (n [u] = null), S.event.triggered = d, e.isPropagationStopped () && f.addEventListener (d, wt), n [d] (), e.isPropagationStopped () && f.removeEventListener (d, wt), S.event.triggered = void 0, a && (n [u] = a)), e.result}}, simular: função (e, t, n) {var r = S.extend (novo S. Evento, n, {type: e, isSimulated:! 0}); S.event.trigger (r, null, t)}}), S.fn.extend ({trigger: function (e, t) {return this .each (function () {S.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; if (n) return S.event.trigger (e, t, n,! 0)}}), y.focusin || S.each ({focus: "focusin", blur: "focusout"}, função (n, r) {var i = function (e ) {S.event.simulate (r, e.target, S.event.fix (e))}; S.event.special [r] = {setup: function () {var e = this.ownerDocument || this .documento || this, t = Y.access (e, r); t || e.addEventListener (n, i,! 0), Y.access (e, r, (t || 0) +1)}, desmontagem: function () {var e = this.ownerDocument || this.document || this, t = Y.access (e, r) -1; t? Y.access (e, r, t) :( e.removeEventListener (n, i,! 0), Y.remove (e, r))}} }); var Tt = C.location, Ct = {guid: Date.now ()}, Et = / \? /; S.parseXML = function (e) {var t; if (! e || "string" ! = typeof e) return null; try {t = (new C.DOMParser) .parseFromString (e, "text / xml")} catch (e) {t = void 0} return t &&! t.getElementsByTagName ("parsererror" ) .length || S.error ("XML inválido:" + e), t}; var St = / \ [\] $ /, kt = / \ r? \ n / g, At = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, Nt = / ^ (?: input | select | textarea | keygen) / i; função Dt (n, e, r, i) {var t; if (Array .isArray (e)) S.each (e, function (e, t) {r || St.test (n)? i (n, t): Dt (n + "[" + ("objeto" == typeof t && null! = t? e: "") + "]", t, r, i)}); else if (r || "objeto"!== w (e)) i (n, e); senão para (t in e) Dt (n + "[" + t + "]", e [t], r, i)} S.param = função (e , t) {var n, r = [], i = função (e, t) {var n = m (t)? t (): t; r [comprimento r] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (null == e) return ""; if (Array.isArray (e) || e.jquery &&! S.isPlainObject (e)) S.each (e, function () {i (this.name, this.value)}); else for (n in e) Dt (n, e [n], t, i); return r.join ("&") }, S.fn.extend ({serialize: function () {return S.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = S.prop ( this, "elements"); return e? S.makeArray (e): this}). filter (function () {var e = this.type; return this.name &&! S (this) .is (": disabled" ) && Nt.test (this.nodeName) &&! At.test (e) && (this.checked ||! Pe.test (e))}). Map (function (e, t) {var n = S (this ) .val ();return null == n? null: Array.isArray (n)? S.map (n, function (e) {return {name: t.name, value: e.replace (kt, "\ r \ n")} }): {name: t.name, value: n.replace (kt, "\ r \ n")}}). get ()}}); var jt = /% 20 / g, qt = / #. * $ /, Lt = / ([? &]) _ = [^ &] * /, Ht = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm , Ot = / ^ (?: GET | HEAD) $ /, Pt = / ^ \ / \ //, Rt = {}, Mt = {}, It = "* /". Concat ("*"), Wt = E.createElement ("a"); função Ft (o) {função de retorno (e, t) {"string"! = Tipo de e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase (). match (P) || []; if (m (t)) while (n = i [r ++]) "+" === n [0]? (n = n.slice (1) || "*", (o [n] = o [n] || []). Unshift (t)) :( o [n] = o [n] || []). Push (t )}} função Bt (t, i, o, a) {var s = {}, u = t === Mt; função l (e) {var r; return s [e] =! 0, S.each (t [e] || [], função (e, t) {var n = t (i, o, a); retornar "string"! = tipo de n || u || s [n]? u ?! (r = n): vazio 0: (i.dataTypes.unshift (n), l (n) ,! 1)}),r} return l (i.dataTypes [0]) ||! s ["*"] && l ("*")} função $ t (e, t) {var n, r, i = S.ajaxSettings.flatOptions | | {}; para (n em t) vazio 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); retornar r && S.extend (! 0, e, r), e} Wt.href = Tt.href, S.extend ({ativo: 0, lastModified: {}, etag: {}, ajaxSettings: {url: Tt.href, tipo: "GET", isLocal: / ^ (?: about | app | app-storage |. + - extension | file | res | widget): $ /. test (Tt.protocol), global:! 0, processData: ! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", aceita: {"*": It, text: "text / plain", html: "text / html ", xml:" application / xml, text / xml ", json:" application / json, text / javascript "}, contents: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON "}, conversores: {" * text ": String," text html ":! 0," text json ": JSON.parse," text xml ": S.parseXML}, flatOptions: {url:! 0, contexto :! 0}}, ajaxSetup: function (e, t) {return t? $ T ($ t (e, S.ajaxSettings), t): $ t (S.ajaxSettings, e)}, ajaxPrefilter: Ft (Rt ), ajaxTransport: Ft (Mt), ajax: function (e, t) {"objeto" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p , n, d, r, h, g, i, o, v = S.ajaxSetup ({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery )? S (y): S.event, x = S.Deferred (), b = S.Callbacks ("uma vez na memória"), w = v.statusCode || {}, a = {}, s = {} , u = "cancelado", T = {readyState: 0, getResponseHeader: function (e) {var t; if (h) {if (! n) {n = {}; while (t = Ht.exec (p) ) n [t [1] .toLowerCase () + ""] = (n [t [1] .toLowerCase () + ""] || []). concat (t [2])} t = n [e .toLowerCase () + ""]} return null == t? null: t.join (",")}, getAllResponseHeaders: function () {return h? p: null}, setRequestHeader: function (e, t) {return null == h && (e = s [e.toLowerCase ()] = s [e.toLowerCase ( )] || e, a [e] = t), este}, overrideMimeType: function (e) {return null == h && (v.mimeType = e), this}, statusCode: function (e) {var t; if (e) if (h) T.sempre (e [T.status]); else for (t in e) w [t] = [w [t], e [t]]; retornar isso}, abortar: função (e) {var t = e || u; retornar c && c.abort (t), l (0, t), este}}; se (x.promessa (T), v.url = ((e || v.url || Tt.href) + ""). substituir (Pt, Tt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*"). toLowerCase (). match (P) || [""], null == v.crossDomain) {r = E.createElement ("a"); tente {r.href = v.url, r.href = r.href, v.crossDomain = Wt.protocol + "//" + Wt.host! = r.protocol + "//" + r.host} catch (e) {v.crossDomain =! 0}} if (v.data && v.processData && "string"! = typeof v.data && (v.data = S.param (v.data, v.traditional)), Bt (Rt, v, t, T), h) return T; para (i in ( g = S.event && v.global) && 0 == S.active ++ && S.event.trigger ("ajaxStart"), v.type = v.type.toUpperCase (), v.hasContent =! Ot.test (v. type), f = v.url.replace (qt, ""), v.hasContent? v.data && v.processData && 0 === (v.contentType || ""). indexOf ("application / x-www-form- urlencoded ") && (v.data = v.data.replace (jt," + ")) :( o = v.url.slice (f.length), v.data && (v.processData ||" string "= = typeof v.data) && (f + = (Et.test (f)? "&": "?") + v.data, delete v.data) ,! 1 === v.cache && (f = f. substituir (Lt, "$ 1"), o = (Et.test (f)? "&": "?") + "_ =" + Ct.guid +++ o), v.url = f + o) , v.ifModificado && (S.lastModified [f] && T.setRequestHeader ("If-Modified-Since", S.lastModified [f]), S.etag [f] && T.setRequestHeader ("If-None-Match", S.etag [f])) , (v.data && v.hasContent &&! 1! == v.contentType || t.contentType) && T.setRequestHeader ("Content-Type", v.contentType), T.setRequestHeader ("Aceitar", v.dataTypes [0] && v.accepts [v.dataTypes [0]]? v.accepts [v.dataTypes [0]] + ("*"! == v.dataTypes [0]? "," + It + "; q = 0,01": ""): v.accepts ["*"]), v.headers) T.setRequestHeader (i, v.headers [i]); if (v.beforeSend && (! 1 === v.beforeSend.call (y , T, v) || h)) return T.abort (); if (u = "abortar", b.add (v.complete), T.done (v.success), T.fail (v.error ), c = Bt (Mt, v, t, T)) {if (T.readyState = 1, g && m.trigger ("ajaxSend", [T, v]), h) return T; v.async && 0 <v.timeout && (d = C.setTimeout (function () {T.abort ("timeout")}, v.timeout)); tente {h =! 1, c.send (a, l)} catch (e) {if (h) lance e; l (-1, e)}} else l (-1, "Sem transporte"); função l (e, t, n, r) {var i, o, a, s, u, l = t; h || (h =! 0, d && C.clearTimeout (d), c = vazio 0, p = r || "", T.readyState = 0 <e? 4: 0, i = 200 <= e && e <300 || 304 === e, n && (s = função (e, t, n) {var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Content-Type")); if (r) for (i in s) if (s [i] && s [i] .test (r)) {u.unshift (i); break} if (u [0] in n) o = u [0]; else {for (i in n) {if (! u [0] || e.conversores [i + "" + u [0]]) {o = i; quebrar} a || (a = i)} o = o || a} if (o ) return o! == u [0] && u.unshift (o), n [o]} (v, T, n)) ,! i && - 1 <S.inArray ("script", v.dataTypes) && ( v.converters ["script de texto "] = função () {}), s = função (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.slice () ; if (c [1]) para (a em e.conversores) l [a.toLowerCase ()] = e.conversores [a]; o = c.shift (); while (o) if (e.responseFields [ o] && (n [e.responseFields [o]] = t) ,! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift ()) if ( "*" === o) o = u; else if ("*"! == u && u! == o) {if (! (a = l [u + "" + o] || l ["*" + o])) para (i em l) if ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] || l ["* "+ s [0]])) {! 0 === a? a = l [i] :! 0! == l [i] && (o = s [0], c.unshift (s [1] )); break} if (! 0! == a) if (a && e ["throws"]) t = a (t); caso contrário, tente {t = a (t)} catch (e) {return {state: " parsererror ", erro: a? e:" Sem conversão de "+ u +" para "+ o}}} return {state:" success ", data: t}} (v, s, T, i), i? ( v.ifModified && ((u = T.getResponseHeader ("Last-Modified")) && (S.lastModified [f] = u), (u = T.getResponseHeader ("etag")) && (S.etag [f] = u )), 204 === e || "HEAD" === v.type? L = "nocontent": 304 === e? L = "notmodified" :( l = s.state, o = s.data , i =! (a = s.error))) :( a = l,! e && l || (l = "erro", e <0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i? x.resolveWith (y, [o, l, T]): x.rejectWith (y, [T, l, a]), T.statusCode (w), w = void 0, g && m.trigger (i? "ajaxSuccess": "ajaxError", [T, v, i? o: a]), b.fireWith (y, [T, l]), g && (m.trigger ("ajaxComplete", [T, v]), - S.active || S.event.trigger ("ajaxStop")))} return T}, getJSON: function (e, t, n) {return S. get (e, t, n, "json")}, getScript: function (e, t) {return S.get (e, void 0, t, "script")}}), S.each (["get ","post"], função (e, i) {S [i] = função (e, t, n, r) {retornar m (t) && (r = r || n, n = t, t = vazio 0 ), S.ajax (S.extend ({url: e, type: i, dataType: r, data: t, success: n}, S.isPlainObject (e) && e))}}), S.ajaxPrefilter (função (e) {var t; for (t em e.headers) "content-type" === t.toLowerCase () && (e.contentType = e.headers [t] || "")}), S. _evalUrl = function (e, t, n) {return S.ajax ({url: e, type: "GET", dataType: "script", cache:! 0, assíncrono:! 1, global:! 1, conversores: {"script de texto": function () {}}, dataFilter: function (e) {S.globalEval (e, t, n)}})}, S.fn.extend ({wrapAll: function (e) {var t; retornar este [0] && (m (e) && (e = e.call (este [0])), t = S (e, este [0] .ownerDocument) .eq (0) .clone (! 0), este [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; return e}). Append ( esta)),this}, wrapInner: function (n) {return m (n)? this.each (function (e) {S (this) .wrapInner (n.call (this, e))}): this.each (function ( ) {var e = S (this), t = e.contents (); t.length? t.wrapAll (n): e.append (n)})}, wrap: function (t) {var n = m (t); retornar this.each (function (e) {S (this) .wrapAll (n? t.call (this, e): t)})}, desembrulhar: function (e) {return this.parent ( e) .not ("corpo"). each (function () {S (this) .replaceWith (this.childNodes)}), this}}), S.expr.pseudos.hidden = function (e) {return! S.expr.pseudos.visible (e)}, S.expr.pseudos.visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). Length)}, S .ajaxSettings.xhr = function () {try {return new C.XMLHttpRequest} catch (e) {}}; var _t = {0: 200,1223: 204}, zt = S.ajaxSettings.xhr (); y. cors = !! zt && "withCredentials" em zt, y.ajax = zt = !! zt, S.ajaxTransport (function (i) {var o, a; if (y.cors || zt &&! i.crossDomain) return { enviar:função (e, t) {var n, r = i.xhr (); if (r.open (i.type, i.url, i.async, i.username, i.password), i.xhrFields) para (n em i.xhrFields) r [n] = i.xhrFields [n]; para (n em i.mimeType && r.overrideMimeType && r.overrideMimeType (i.mimeType), i.crossDomain || e ["X-Requested-With" ] || (e ["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader (n, e [n]); o = function (e) {return function () {o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abortar" === e? r.abort (): "erro" === e? "número"! = typeof r.status? t (0, "error"): t (r.status, r.statusText): t (_t [r.status] || r.status, r.statusText, "text"! == (r.responseType || "text") || "string"! = typeof r.responseText? {binary: r.response}: {text: r.responseText}, r.getAllResponseHeaders ()))}}, r. onload = o (), a = r.onerror = r.ontimeout = o ("erro"), void 0! == r.onabort? r.onabort = a: r.onreadystatechange = function () {4 === r.readyState && C.setTimeout (function () {o && a ()} )}, o = o ("abortar"); tente {r.send (i.hasContent && i.data || null)} catch (e) {if (o) throw e}}, abort: function () {o && o ( )}}}), S.ajaxPrefilter (function (e) {e.crossDomain && (e.contents.script =! 1)}), S.ajaxSetup ({aceita: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript "}, conteúdo: {script: / \ b (?: java | ecma) script \ b /}, conversores: {" script de texto ": function (e) {return S.globalEval (e), e}}}), S.ajaxPrefilter ("script", função (e) {void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET ")}), S.ajaxTransport (" script ", função (n) {var r, i; if (n.crossDomain || n.scriptAttrs) return {enviar:function (e, t) {r = S ("<script>") .attr (n.scriptAttrs || {}). prop ({charset: n.scriptCharset, src: n.url}). on ("carregar erro ", i = função (e) {r.remove (), i = nulo, e && t (" erro "=== e.type? 404: 200, e.type)}), E.head.appendChild (r [0])}, aborta: function () {i && i ()}}}); var Ut, Xt = [], Vt = / (=) \? (? = & | $) | \? \? /; S.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var e = Xt.pop () || S.expando + "_" + Ct.guid ++; return this [e] =! 0, e}} ), S.ajaxPrefilter ("json jsonp", função (e, t, n) {var r, i, o, a =! 1! == e.jsonp && (Vt.test (e.url)? "Url" : "string" == typeof e.data && 0 === (e.contentType || ""). indexOf ("application / x-www-form-urlencoded") && Vt.test (e.data) && "data") ; if (a || "jsonp" === e.dataTypes [0]) retorna r = e.jsonpCallback = m (e.jsonpCallback)? e.jsonpCallback (): e.jsonpCallback, a? e [a] = e [a] .replace (Vt, "$ 1" + r) :! 1! == e.jsonp && (e.url + = (Et.test (e .url)? "&": "?") + e.jsonp + "=" + r), e.converters ["script json"] = function () {return o || S.error (r + "não foi chamado "), o [0]}, e.dataTypes [0] =" json ", i = C [r], C [r] = função () {o = argumentos}, n.sempre (função () {void 0 === i? S (C) .removeProp (r): C [r] = i, e [r] && (e.jsonpCallback = t.jsonpCallback, Xt.push (r)), o && m (i) && i (o [0]), o = i = void 0}), "script"}), y.createHTMLDocument = ((Ut = E.implementation.createHTMLDocument (""). body) .innerHTML = "<form> < /form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e? [] :( " boolean "== typeof t && (n = t, t =! 1), t || (y.createHTMLDocument? ((r = (t = E.implementation.createHTMLDocument ("")). createElement ("base")). href = E.location.href, t.head.appendChild (r)): t = E) , o =! n && [], (i = N.exec (e))? [t.createElement (i [1])] :( i = xe ([e], t, o), o && o.length && S (o ) .remove (), S.merge ([], i.childNodes))); var r, i, o}, S.fn.load = função (e, t, n) {var r, i, o, a = this, s = e.indexOf (""); return-1 <s && (r = vt (e.slice (s)), e = e.slice (0, s)), m (t)? ( n = t, t = void 0): t && "object" == typeof t && (i = "POST"), 0 <a.length && S.ajax ({url: e, type: i || "GET", dataType: "html", data: t}). done (function (e) {o = arguments, a.html (r? S ("<div>") .append (S.parseHTML (e)). find (r) : e)}). always (n && function (e, t) {a.each (function () {n.apply (this, o || [e.responseText, t, e])})}), this}, S.expr.pseudos.animated = function (t) {return S.grep (S.timers, function (e) {return t === e.elem}). length}, S.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l = S.css (e, "posição"), c = S (e), f = {}; "estático" === l && (e.style .position = "relative"), s = c.offset (), o = S.css (e, "top"), u = S.css (e, "left"), ("absoluto" === l || "fixo" === l) && - 1 <(o + u) .indexOf ("auto")? (a = (r = c.position ()). top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0), m (t) && (t = t.call (e, n, S.extend ({}, s))), nulo ! = t.top && (f.top = t.top-s.top + a), null! = t.left && (f.left = t.left-s.left + i), "usando" em t? t .using.call (e, f) :( "número" == typeof f.top && (f.top + = "px"), "number" == typeof f.left && (f.left + = "px"), c .css (f))}}, S.fn.extend ({deslocamento: função (t) {if (argumentos.length) return void 0 === t? this: this.each (function (e) {S.offset.setOffset (this, t, e)}); var e, n, r = this [0]; return r ? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {top: e.top + n.pageYOffset, left: e.left + n.pageXOffset}): { topo: 0, esquerda: 0}: vazio 0}, posição: função () {if (this [0]) {var e, t, n, r = this [0], i = {top: 0, left: 0}; if ("fixed" === S.css (r, "position")) t = r.getBoundingClientRect (); else {t = this.offset (), n = r.ownerDocument, e = r. offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "estático" === S.css (e, "posição")) e = e. parentNode; e && e! == r && 1 === e.nodeType && ((i = S (e) .offset ()). top + = S.css (e, "borderTopWidth",! 0), i.left + = S.css (e, "borderLeftWidth",! 0))} return {top: t.top-i.top-S.css (r, "marginTop",! 0), left: t.left-i.left-S.css (r, "marginLeft",! 0)}}}, offsetParent: function () {return this.map (function () {var e = this.offsetParent; while (e && "static" === S.css (e, "position")) e = e.offsetParent; return e || re})}}), S.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (t, i) {var o = "pageYOffset" === i; S.fn [t] = função (e) {return $ (this, function (e, t, n) {var r; if (x (e)? r = e: 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r? r [i]: e [t]; r? r.scrollTo (o? r.pageXOffset : n, o? n: r.pageYOffset): e [t] = n}, t, e, arguments.length)}}), S.each (["top", "left"], function (e, n) {S.cssHooks [n] = $ e (y.pixelPosition, função (e, t) {if (t) return t = Be (e, n), Me.test (t)? S (e). position () [n] + "px": t})}), S.each ({Height: "height", Width: "width"}, function (a, s) {S.each ({padding: " interno "+ a,conteúdo: s, "": "externo" + a}, função (r, o) {S.fn [o] = função (e, t) {var n = argumentos.comprimento && (r || "booleano"! = typeof e), i = r || (! 0 === e ||! 0 === t? "margin": "border"); return $ (this, function (e, t, n) {var r ; return x (e)? 0 === o.indexOf ("externo")? e ["interno" + a]: e.document.documentElement ["cliente" + a]: 9 === e.nodeType? (r = e.documentElement, Math.max (e.body ["scroll" + a], r ["scroll" + a], e.body ["offset" + a], r ["offset" + a] , r ["cliente" + a])): vazio 0 === n? S.css (e, t, i): S.style (e, t, n, i)}, s, n? e: void 0, n)}})}), S.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], função (e, t) {S. fn [t] = function (e) {return this.on (t, e)}}), S.fn.extend ({bind: function (e, t, n) {return this.on (e, null, t,n)}, desvincular: função (e, t) {retornar this.off (e, nulo, t)}, delegar: função (e, t, n, r) {retornar isso.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)}, hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}), S.each ("blur focus focusin focusout redimensionar scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter deixar o mouse alterar selecionar enviar tecla pressionada tecla pressionada tecla contexto menu ".split (" "), função (e, n) {S.fn [n] = função (e, t) {retornar 0 <argumentos.length? this.on (n , nulo, e, t): this.trigger (n)}}); var Gt = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; S.proxy = função (e, t) {var n, r, i; if ("string" == tipo de t && (n = e [t], t = e, e = n), m (e)) return r = s. chamar (argumentos, 2), (i = função () {retornar e.aplicar (t || this, r.concat (s.call (argumentos)))}). guid = e.guid = e.guid || S.guid ++, i}, S.holdReady = function (e) {e? S.readyWait ++: S.ready (! 0)}, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) {var t = S.type (e); return ("número" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, S.trim = função (e ) {return null == e? "" :( e + ""). replace (Gt, "")}, "function" == typeof define && define.amd && define ("jquery", [], function () {return S} ); var Yt = C.jQuery, Qt = C. $; return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C .jQuery = Yt), S}, "indefinido" == typeof e && (C.jQuery = C. $ = S), S});nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) {var t = S. type (e); return ("número" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, S.trim = função (e) {return null == e? "" :( e + ""). replace (Gt, "")}, "function" == typeof define && define.amd && define ("jquery", [], function () {return S}); var Yt = C .jQuery, Qt = C. $; return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "indefinido" == typeof e && (C.jQuery = C. $ = S), S});nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) {var t = S. type (e); return ("número" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, S.trim = função (e) {return null == e? "" :( e + ""). replace (Gt, "")}, "function" == typeof define && define.amd && define ("jquery", [], function () {return S}); var Yt = C .jQuery, Qt = C. $; return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "indefinido" == typeof e && (C.jQuery = C. $ = S), S});": (e +" "). replace (Gt," ")}," function "== typeof define && define.amd && define (" jquery ", [], function () {return S}); var Yt = C.jQuery, Qt = C. $; Return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "undefined" == typeof e && (C.jQuery = C. $ = S), S});": (e +" "). replace (Gt," ")}," function "== typeof define && define.amd && define (" jquery ", [], function () {return S}); var Yt = C.jQuery, Qt = C. $; Return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "undefined" == typeof e && (C.jQuery = C. $ = S), S});
/ *
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Licença dupla sob as licenças MIT e GPL.
 * http://benalman.com/about/license/
 * /
(função (b, c) {var $ = b.jQuery || b.Cowboy || (b.Cowboy = {}), a; $. throttle = a = function (e, f, j, i) {var h, d = 0; if (typeof f! == "boolean") {i = j; j = f; f = c} função g () {var o = this, m = + new Date () - d, n = argumentos; função l () {d = + new Date (); j.apply (o, n)} função k () {h = c} if (i &&! h) {l ()} h && clearTimeout (h) ; if (i === c && m> e) {l ()} else {if (f! == true) {h = setTimeout (i? k: l, i === c? em: e)}}} if ($. guid) {g.guid = j.guid = j.guid || $ .guid ++} return g}; $. debounce = function (d, e, f) {return f === c? a ( d, e, falso): a (d, f, e! == falso)}}) (este);
/ *!
 * imagesLoaded PACKAGED v4.1.4
 * JavaScript é como "Suas imagens ainda estão prontas ou o quê?"
 * Licença MIT
 * /
! function (e, t) {"function" == typeof define && define.amd? define ("ev-emitter / ev-emitter", t): "object" == typeof module && module.exports? module.exports = t () : e.EvEmitter = t ()} ("undefined"! = typeof window? window: this, function () {function e () {} var t = e.prototype; return t.on = function (e, t) {if (e && t) {var i = this._events = this._events || {}, n = i [e] = i [e] || []; return n.indexOf (t) == - 1 && n.push (t), este}}, t.uma vez = função (e, t) {if (e && t) {this.on (e, t); var i = this._onceEvents = this._onceEvents || {}, n = i [e] = i [e] || {}; retornar n [t] =! 0, este}}, t.off = função (e, t) {var i = este._eventos && este._eventos [e]; if (i && i.length) {var n = i.indexOf (t); return n! = - 1 && i.splice (n, 1), this}}, t.emitEvent = function (e, t) {var i = this ._eventos && this._events [e]; if (i && i.length) {i = i.slice (0), t = t || []; para (var n = this._onceEvents && this._onceEvents [e], o = 0; o <i.length; o ++) {var r = i [o], s = n && n [r]; s && (this.off (e, r), delete n [r ]), r.apply (this, t)} return this}}, t.allOff = function () {delete this._events, delete this._onceEvents}, e}), function (e, t) {"use estrito ";" função "== typeof define && define.amd? define ([" ev-emitter / ev-emitter "], function (i) {return t (e, i)}):" object "== typeof module && module.exports ? module.exports = t (e, require ("ev-emitter")): e.imagesLoaded = t (e, e.EvEmitter)} ("undefined"! = typeof window? window: this, function (e, t ) {função i (e, t) {para (var i em t) e [i] = t [i]; retornar e} função n (e) {if (Array.isArray (e)) retornar e; var t = "objeto" == typeof e && "number" == typeof e.length; return t? d.call (e): [e]} função o (e, t, r) {if (! (this instanceof o) ) retornar novo o (e, t, r);var s = e; return "string" == typeof e && (s = document.querySelectorAll (e)), s? (this.elements = n (s), this.options = i ({}, this.options), "função" == typeof t? r = t: i (this.options, t), r && this.on ("always", r), this.getImages (), h && (this.jqDeferred = new h.Deferred), void setTimeout (this.check.bind (this))): void a.error ("Elemento inválido para imagesLoaded" + (s || e))} função r (e) {this.img = e} função s (e , t) {this.url = e, this.element = t, this.img = new Image} var h = e.jQuery, a = e.console, d = Array.prototype.slice; o.prototype = Object. create (t.prototype), o.prototype.options = {}, o.prototype.getImages = function () {this.images = [], this.elements.forEach (this.addElementImages, this)}, o.prototype .addElementImages = function (e) {"IMG" == e.nodeName && this.addImage (e), this.options.background ===! 0 && this.addElementBackgroundImages (e); var t = e.nodeType; if (t && u [t]) {for (var i = e.querySelectorAll ("img"), n = 0; n <i.length; n ++) {var o = i [n]; this.addImage (o)} if ("string" == typeof this.options.background) {var r = e.querySelectorAll (this.options.background); for (n = 0; n <r .length; n ++) {var s = r [n]; this.addElementBackgroundImages (s)}}}}; var u = {1:! 0,9:! 0,11:! 0}; retornar o.protótipo. addElementBackgroundImages = function (e) {var t = getComputedStyle (e); if (t) for (var i = / url \ ((['"])? (. *?) \ 1 \) / gi, n = i .exec (t.backgroundImage); null! == n;) {var o = n && n [2]; o && this.addBackground (o, e), n = i.exec (t.backgroundImage)}}, o.protótipo. addImage = function (e) {var t = new r (e); this.images.push (t)}, o.prototype.addBackground = function (e, t) {var i = new s (e, t); this.images.push (i)}, o.prototype.check = function () {function e (e, i, n) {setTimeout (function () {t.progress (e,i, n)})} var t = this; return this.progressedCount = 0, this.hasAnyBroken =! 1, this.images.length? void this.images.forEach (function (t) {t.once ("progress ", e), t.check ()}): void this.complete ()}, o.prototype.progress = função (e, t, i) {this.progressedCount ++, this.hasAnyBroken = this.hasAnyBroken ||! e.isLoaded, this.emitEvent ("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify (this, e), this.progressedCount == this.images.length && this.complete (), this.options.debug && a && a.log ("progress:" + i, e, t)}, o.prototype.complete = function () {var e = this.hasAnyBroken? "fail": "done"; se (this.isComplete =! 0, this.emitEvent (e, [this]), this.emitEvent ("always", [this]), this.jqDeferred) {var t = this.hasAnyBroken? "rejeitar": "resolver ";esta.jqDeferred [t] (this)}}, r.prototype = Object.create (t.prototype), r.prototype.check = function () {var e = this.getIsImageComplete (); return e? void this.confirm ( 0! == this.img.naturalWidth, "naturalWidth") :( this.proxyImage = new Image, this.proxyImage.addEventListener ("load", this), this.proxyImage.addEventListener ("error", this), this .img.addEventListener ("load", this), this.img.addEventListener ("error", this), void (this.proxyImage.src = this.img.src))}, r.prototype.getIsImageComplete = function ( ) {return this.img.complete && this.img.naturalWidth}, r.prototype.confirm = function (e, t) {this.isLoaded = e, this.emitEvent ("progress", [this, this.img, t] )}, r.prototype.handleEvent = function (e) {var t = "on" + e.type; this [t] && this [t] (e)}, r.prototype.onload = function () {this. confirme (! 0, "onload"), isso.unbindEvents ()}, r.prototype.onerror = function () {this.confirm (! 1, "onerror"), this.unbindEvents ()}, r.prototype.unbindEvents = function () {this.proxyImage.removeEventListener ( "load", this), this.proxyImage.removeEventListener ("error", this), this.img.removeEventListener ("load", this), this.img.removeEventListener ("error", this)}, s.prototype = Object.create (r.prototype), s.prototype.check = function () {this.img.addEventListener ("carregar", isso), this.img.addEventListener ("erro", isso), isso.img. src = this.url; var e = this.getIsImageComplete (); e && (this.confirm (0! == this.img.naturalWidth, "naturalWidth"), this.unbindEvents ())}, s.prototype.unbindEvents = function () {this.img.removeEventListener ("load", this), this.img.removeEventListener ("error", this)}, s.prototype.confirm = function (e,t) {this.isLoaded = e, this.emitEvent ("progress", [this, this.element, t])}, o.makeJQueryPlugin = function (t) {t = t || e.jQuery, t && (h = t, h.fn.imagesLoaded = function (e, t) {var i = new o (this, e, t); return i.jqDeferred.promise (h (this))})}, o.makeJQueryPlugin () , o});
/ *! lz-string-1.3.3-min.js | (c) 2013 Pieroxy | Licenciado sob uma licença WTFPL * /
var LZString = {_ keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + / =", _ f: String.fromCharCode, compressToBase64: function (e var) {if (e == nulo, r "retorno" i var t = "i var t ="; , o, u, a; var f = 0; e = LZString.compress (e); enquanto (f <e.length * 2) {if (f% 2 == 0) {n = e.charCodeAt (f / 2) >> 8; r = e.charCodeAt (f / 2) & 255; if (f / 2 + 1 <e.length) i = e.charCodeAt (f / 2 + 1) >> 8; senão i = NaN } else {n = e.charCodeAt ((f-1) / 2) & 255; if ((f + 1) / 2 <e.length) {r = e.charCodeAt ((f + 1) / 2) >> 8; i = e.charCodeAt ((f + 1) / 2) & 255} else r = i = NaN} f + = 3; s = n >> 2; o = (n & 3) << 4 | r >> 4; u = (r & 15) << 2 | i >> 6; a = i & 63; if (isNaN (r)) {u = a = 64} else if (isNaN (i)) {a = 64} t = t + LZString ._keyStr.charAt (s) + LZString._keyStr.charAt (o) + LZString._keyStr.charAt (u) + LZString._keyStr.charAt (a)} return t}, decompressFromBase64: function (e) {if (e = = null) return ""; var t =" ", n = 0, r, i, s, o, u, a, f, l, c = 0, h = LZString._f; e = e.replace (/ [^ A-Za -z0-9 \ + \ / \ =] / g, ""); enquanto (c <e.length) {u = LZString._keyStr.indexOf (e.charAt (c ++)); a = LZString._keyStr.indexOf (e.charAt (c ++)); f = LZString._keyStr.indexOf (e.charAt (c ++)); l = LZString._keyStr.indexOf (e.charAt (c ++)); i = u << 2 | a> > 4; s = (a & 15) << 4 | f >> 2; o = (f & 3) << 6 | l; if (n% 2 == 0) {r = i << 8; if (f! = 64) {t + = h (r | s)} if (l! = 64) {r = o << 8}} else {t = t + h (r | i); if (f! = 64) {r = s << 8} if (l! = 64) {t + = h (r | o)}} n + = 3} return LZString.decompress (t)}, compressToUTF16: function (e) {if (e == null ) retornar ""; var t = "", n, r, i, s = 0, o = LZString._f; e = LZString.compress (e); para (n = 0; n <e.length; n ++) {r = e.charCodeAt (n); switch (s ++) {case 0: t + = o ((r >> 1) +32); i = (r & 1) << 14; break; case 1: t + = o ( i + (r >> 2) +32); i = (r & 3) << 13; quebra; caso 2:t + = o (i + (r >> 3) +32); i = (r & 7) << 12; quebra; caso 3: t + = o (i + (r >> 4) +32); i = (r & 15) < <11; quebra; caso 4: t + = o (i + (r >> 5) +32); i = (r & 31) << 10; quebra; caso 5: t + = o (i + (r >> 6) +32 ); i = (r & 63) << 9; quebrar; caso 6: t + = o (i + (r >> 7) +32); i = (r & 127) << 8; quebrar; caso 7: t + = o (i + (r >> 8) +32); i = (r & 255) << 7; quebrar; caso 8: t + = o (i + (r >> 9) +32); i = (r & 511) << 6; quebrar; caso 9: t + = o (i + (r >> 10) +32); i = (r & 1023) << 5; quebra; caso 10: t + = o (i + (r >> 11) +32); i = ( r & 2047) << 4; quebrar; caso 11: t + = o (i + (r >> 12) +32); i = (r & 4095) << 3; quebrar; caso 12: t + = o (i + (r >> 13 ) +32); i = (r & 8191) << 2; quebrar; caso 13: t + = o (i + (r >> 14) +32); i = (r & 16383) << 1; quebrar; caso 14: t + = o (i + (r >> 15) +32, (r & 32767) +32); s = 0; quebrar}} retornar t + o (i + 32)}, descompactarFromUTF16: função (e) {if (e == nulo )Retorna""; var t =" ", n, r, i = 0, s = 0, o = LZString._f; enquanto (s <e.length) {r = e.charCodeAt (s) -32; switch (i ++) {caso 0: n = r << 1; quebra; caso 1: t + = o (n | r >> 14); n = (r & 16383) << 2; quebra; caso 2: t + = o (n | r> > 13); n = (r & 8191) << 3; quebrar; caso 3: t + = o (n | r >> 12); n = (r & 4095) << 4; quebrar; caso 4: t + = o (n | r >> 11); n = (r & 2047) << 5; quebra; caso 5: t + = o (n | r >> 10); n = (r & 1023) << 6; quebra; caso 6: t + = o ( n | r >> 9); n = (r & 511) << 7; quebra; caso 7: t + = o (n | r >> 8); n = (r & 255) << 8; quebra; caso 8: t + = o (n | r >> 7); n = (r & 127) << 9; quebrar; caso 9: t + = o (n | r >> 6); n = (r & 63) << 10; quebrar; caso 10: t + = o (n | r >> 5); n = (r & 31) << 11; quebra; caso 11: t + = o (n | r >> 4); n = (r & 15) << 12; quebra; caso 12: t + = o (n | r >> 3); n = (r & 7) << 13; quebra; caso 13: t + = o (n | r >> 2); n = (r & 3) << 14; quebra ;caso 14: t + = o (n | r >> 1); n = (r & 1) << 15; quebrar; caso 15: t + = o (n | r); i = 0; quebrar} s ++} return LZString.decompress (t)}, comprimir: função (e) {if (e == null) return ""; var t, n, r = {}, i = {}, s = "", o = "", u = "", a = 2, f = 3, l = 2, c = "", h = 0, p = 0, d, v = LZString._f; para (d = 0; d <e.length; d + = 1) {s = e.charAt (d); if (! Object.prototype.hasOwnProperty.call (r, s)) {r [s] = f ++; i [s] = true} o = u + s; if (Object.prototype.hasOwnProperty.call (r, o)) {u = o} else {if (Object.prototype.hasOwnProperty.call (i, u)) {if (u.charCodeAt (0) <256) {para (t = 0; t <l; t ++) {h = h << 1; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++}} n = u .charCodeAt (0); para (t = 0; t <8; t ++) {h = h << 1 | n & 1; if (p == 15) {p = 0; c + = v (h); h = 0 } else {p ++} n = n >> 1}} else {n = 1; for (t = 0; t <l; t ++) {h = h << 1 | n; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = 0} n = u.charCodeAt (0); para (t = 0; t <16; t ++) {h = h << 1 | n & 1; if (p == 15) {p = 0;c + = v (h); h = 0} else {p ++} n = n >> 1}} a -; if (a == 0) {a = Math.pow (2, l); l ++} delete i [u]} else {n = r [u]; for (t = 0; t <l; t ++) {h = h << 1 | n & 1; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = n >> 1}} a -; if (a == 0) {a = Math.pow (2, l); l ++} r [o] = f ++; u = String (s)}} if (u! == "") {if (Object.prototype.hasOwnProperty.call (i, u)) {if (u.charCodeAt (0) <256) {for ( t = 0; t <l; t ++) {h = h << 1; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++}} n = u. charCodeAt (0); for (t = 0; t <8; t ++) {h = h << 1 | n & 1; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = n >> 1}} else {n = 1; for (t = 0; t <l; t ++) {h = h << 1 | n; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = 0} n = u.charCodeAt (0); para (t = 0; t <16; t ++) {h = h << 1 | n & 1; if (p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = n >> 1}} a -; if (a == 0) {a = Math.pow (2, l); l ++} excluir i [u]} else {n = r [u]; for (t = 0; t <l; t ++) {h = h << 1 | n & 1; se (p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = n >> 1}} a--;if (a == 0) {a = Math.pow (2, l); l ++}} n = 2; for (t = 0; t <l; t ++) {h = h << 1 | n & 1; if ( p == 15) {p = 0; c + = v (h); h = 0} else {p ++} n = n >> 1} enquanto (verdadeiro) {h = h << 1; if (p == 15 ) {c + = v (h); quebrar} else p ++} retornar c}, descompactar: ​​função (e) {if (e == nulo) retornar ""; if (e == "") retornar nulo; var t = [], n, r = 4, i = 4, s = 3, o = "", u = "", a, f, l, c, h, p, d, v = LZString._f, m = { string: e, val: e.charCodeAt (0), posição: 32768, índice: 1}; para (a = 0; a <3; a + = 1) {t [a] = a} l = 0; h = Math.pow (2,2); p = 1; enquanto (p! = H) {c = m.val & m.position; m.position >> = 1; if (m.position == 0) {m.position = 32768; m.val = m.string.charCodeAt (m.index ++)} l | = (c> 0? 1: 0) * p; p << = 1} switch (n = l) {case 0: l = 0; h = Math.pow (2,8); p = 1; enquanto (p! = H) {c = m.val & m.position; m.position >> = 1; if (m.position == 0 ) {m.position = 32768; m.val = m.string.charCodeAt (m.index ++)} l | = (c> 0? 1: 0) * p; p << = 1} d = v (l) ; quebra; caso 1: l = 0; h = Math.pow (2,16); p = 1; enquanto (p! = H) {c = m.val & m.position; m.position >> = 1; if (m.position == 0) {m.position = 32768; m.val = m.string.charCodeAt (m.index ++)} l | = (c> 0? 1: 0) * p; p << = 1} d = v (l); quebrar; caso 2: retornar ""} t [3] = d; f = u = d; enquanto (verdadeiro) {if (m.index> m.string.length) {return ""} l = 0; h = Math.pow (2, s); p = 1; enquanto (p! = H) {c = m.val & m.position; m.position >> = 1; if (m.position == 0) {m.position = 32768; m.val = m.string .charCodeAt (m.index ++)} l | = (c> 0? 1: 0) * p; p << = 1} switch (d = l) {case 0: l = 0; h = Math.pow (2 , 8); p = 1; enquanto (p! = H) {c = m.val & m.position; m.position >> = 1; if (m.position == 0) {m.position = 32768; m. val = m.string.charCodeAt (m.index ++)} l | = (c> 0? 1: 0) * p; p << = 1} t [i ++] = v (l); d = i-1; r -; quebrar; caso 1: l = 0; h = Math.pow (2,16); p = 1; enquanto (p! = h) {c = m.val & m.position; m.position >> = 1; if (m.position == 0) {m.position = 32768; m.val = m.string.charCodeAt (m.index ++)} l | = (c>0? 1: 0) * p; p << = 1} t [i ++] = v (l); d = i-1; r -; quebrar; caso 2: retornar u} if (r == 0) {r = Math.pow (2, s); s ++} if (t [d]) {o = t [d]} else {if (d === i) {o = f + f.charAt (0) } else {return null}} u + = o; t [i ++] = f + o.charAt (0); r -; f = o; if (r == 0) {r = Math.pow (2, s ); s ++}}}}; if (módulo typeof! == "undefined" && module! = null) {module.exports = LZString}
/ *! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/dist/FileSaver.js * /
(função (a, b) {if ("function" == typeof define && define.amd) define ([], b); else if ("undefined"! = typeof extensions) b (); else {b (), a .FileSaver = {exportações: {}}. Exportações}}) (this, function () {"use strict"; function b (a, b) {return "undefined" == typeof b? B = {autoBom:! 1 }: "objeto"! = typeof b && (console.warn ("Obsoleto: terceiro argumento esperado para ser um objeto"), b = {autoBom:! b}), b.autoBom && / ^ \ s * (?: text \ /\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob (["\ uFEFF", a], {type: a.type}): a} função c (a, b, c) {var d = new XMLHttpRequest; d.open ("GET", a), d .responseType = "blob", d.onload = function () {g (d.response, b, c)}, d.onerror = function () {console.error ("não foi possível baixar o arquivo")}, d. send ()} função d (a) {var b = new XMLHttpRequest; b.open ("HEAD ", a,! 1); tente {b.send ()} catch (a) {} return 200 <= b.status && 299> = b.status} função e (a) {try {a.dispatchEvent (new MouseEvent ("click"))} catch (c) {var b = document.createEvent ("MouseEvents"); b.initMouseEvent ("click",! 0,! 0, window, 0,0,0,80,20, ! 1,! 1,! 1,! 1,0, null), a.dispatchEvent (b)}} var f = "object" == typeof window && window.window === window? Window: "object" == typeof self && self.self === self? self: "object" == typeof global && global.global === global? global: void 0, a = / Macintosh / .test (navigator.userAgent) && / AppleWebKit / .test (navigator. userAgent) &&! / Safari / .test (navigator.userAgent), g = f.saveAs || ("object"! = typeof window || window! == f? function () {}: "download" em HTMLAnchorElement. protótipo &&! a? função (b, g, h) {var i = f.URL || f.webkitURL,j = document.createElement ("a"); g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b? (j. href = b, j.origin === location.origin? e (j): d (j.href)? c (b, g, h): e (j, j.target = "_ blank")) :( j.href = i.createObjectURL (b), setTimeout (function () {i.revokeObjectURL (j.href)}, 4E4), setTimeout (function () {e (j)}, 0))}: "msSaveOrOpenBlob" no navegador? função (f, g, h) {if (g = g || f.name || "download", "string"! = typeof f) navigator.msSaveOrOpenBlob (b (f, h), g); else if (d (f)) c (f, g, h); else {var i = document.createElement ("a"); i.href = f, i.target = "_ blank", setTimeout (function () {e (i)})}}: função (b, d, e, g) {if (g = g || open ("", "_ blank"), g && (g.document.title = g.document. body.innerText = "baixando ..."), "string" == typeof b) return c (b, d, e); var h = "application / octet-stream "=== b.type, i = / constructor / i.test (f.HTMLElement) || f.safari, j = / CriOS \ / [\ d] + /. test (navigator.userAgent ); if ((j || h && i || a) && "undefined"! = typeof FileReader) {var k = new FileReader; k.onloadend = function () {var a = k.result; a = j? a: a.replace (/ ^ data: [^;] *; /, "data: attachment / file;"), g? g.location.href = a: location = a, g = null}, k.readAsDataURL (b )} else {var l = f.URL || f.webkitURL, m = l.createObjectURL (b); g? g.location = m: location.href = m, g = null, setTimeout (function () {l .revokeObjectURL (m)}, 4E4)}}); f.saveAs = g.saveAs = g, "undefined"! = typeof module && (module.exports = g)});onloadend = function () {var a = k.result; a = j? a: a.replace (/ ^ data: [^;] *; /, "data: attachment / file;"), g? g.location .href = a: location = a, g = null}, k.readAsDataURL (b)} else {var l = f.URL || f.webkitURL, m = l.createObjectURL (b); g? g.location = m: location.href = m, g = null, setTimeout (function () {l.revokeObjectURL (m)}, 4E4)}}); f.saveAs = g.saveAs = g, "undefined"! = typeof module && ( module.exports = g)});onloadend = function () {var a = k.result; a = j? a: a.replace (/ ^ data: [^;] *; /, "data: attachment / file;"), g? g.location .href = a: location = a, g = null}, k.readAsDataURL (b)} else {var l = f.URL || f.webkitURL, m = l.createObjectURL (b); g? g.location = m: location.href = m, g = null, setTimeout (function () {l.revokeObjectURL (m)}, 4E4)}}); f.saveAs = g.saveAs = g, "undefined"! = typeof module && ( module.exports = g)});
/ *! seedrandom.js v2.3.3 | (c) 2013 David Bau, todos os direitos reservados. | Licenciado sob uma licença de estilo BSD * /
! função (a, b, c, d, e, f, g, h, i) {função j (a) {var b, c = a.length, e = this, f = 0, g = ei = ej = 0, h = eS = []; para (c || (a = [c ++]); d> f;) h [f] = f ++; para (f = 0; d> f; f ++) h [f ] = h [g = r & g + a [f% c] + (b = h [f])], h [g] = b; (por exemplo, = função (a) {para (var b, c = 0, f = ei, g = ej, h = eS; a -;) b = h [f = r & f + 1], c = c * d + h [r & (h [f] = h [g = r & g + b] ) + (h [g] = b)]; retornar ei = f, ej = g, c}) (d)} função k (a, b) {var c, d = [], e = tipo de a; se (b && "objeto" == e) para (c em a) tente {d.push (k (a [c], b-1))} catch (f) {} return d.length? d: "string" == e? a: a + "\ 0"} função l (a, b) {para (var c, d = a + "", e = 0; e <d.length;) b [r & e] = r & (c ^ = 19 * b [r & e]) + d.charCodeAt (e ++); return n (b)} função m (c) {try {return a.crypto.getRandomValues ​​(c = new Uint8Array (d)), n (c )} catch (e) {return [+ new Date, a, (c = a.navigator) && c.plugins, a.screen, n (b)]}} function n (a) {return String.fromCharCode.apply ( 0, a)} var o = c.pow (d, e),p = c.pow (2, f), q = 2 * p, r = d-1, s = c ["semente" + i] = função (a, f, g) {var h = [], r = l (k (f? [a, n (b)]: nulo == a? m (): a, 3), h), s = novo j (h); retornar l (n (sS), b ), (g || function (a, b, d) {return d? (c [i] = a, b): a}) (function () {for (var a = sg (e), b = o , c = 0; p> a;) a = (a + c) * d, b * = d, c = sg (1); para (; a> = q;) a / = 2, b / = 2 , c >>> = 1; return (a + c) / b}, r, this == c)}; l (c [i] (), b), g && g.exports? g.exports = s: h && h .amd && h (function () {return s})} (this, [], Math, 256,6,52, "object" == typeof module && module, "function" == typeof define && define, "random");return (a + c) / b}, r, this == c)}; l (c [i] (), b), g && g.exports? g.exports = s: h && h.amd && h (function () {return s})} (this, [], Math, 256,6,52, "objeto" == typeof module && module, "function" == typeof define && define, "random");return (a + c) / b}, r, this == c)}; l (c [i] (), b), g && g.exports? g.exports = s: h && h.amd && h (function () {return s})} (this, [], Math, 256,6,52, "objeto" == typeof module && module, "function" == typeof define && define, "random");
/ *! console_hack.js | (c) 2015 Thomas Michael Edwards | Licenciado sob a licença Simple BSD do SugarCube * /
! function () {for (var methods = ["assert", "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed" , "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "table", "time", "timeEnd", "timeline", "timelineEnd", "timeStamp", " trace "," warn "], length = methods.length, noop = function () {}, console = window.console = window.console || {}; length -;) {var method = methods [length]; console [método] || (console [método] = noop)}} ();
} else {document.documentElement.setAttribute ("data-init", "falta");}
</script>
<style id = "style-normalize" type = "text / css"> / *! normalize.css v3.0.3 | Licença MIT | github.com/necolas/normalize.css * / html {font-family: sans-serif; -ms-text-size-ajustar: 100%; - webkit-text-size-ajustar: 100%} corpo {margem: 0 } artigo, à parte, detalhes, figcaption, figura, rodapé, cabeçalho, hgroup, principal, menu, nav, seção, resumo {display: block} audio, canvas, progress, video {display: inline-block; vertical-align: baseline } audio: not ([controles]) {display: none; height: 0} [oculto], template {display: none} a {background-color: transparent} a: active, a: hover {outline: 0} abbr [ título] {border-bottom: 1px dotted} b, strong {font-weight: 700} dfn {font-style: italic} h1 {font-size: 2em; margin: .67em 0} mark {background: # ff0; color : # 000} small {font-size: 80%} sub, sup {font-size: 75%; line-height: 0; position: relative; vertical-align: baseline} sup {top: -. 5em} sub { inferior: -. 25em} img {borda: 0} svg: not (:prata sólida; margem: 0 2px; preenchimento: .35em .625em .75em} legend {border: 0; padding: 0} textarea {overflow: auto} optgroup {font-weight: 700} table {border-collapse: collapse; border -spacing: 0} td, th {padding: 0} </style>
<style id = "style-init-screen" type = "text / css"> @ - webkit-keyframes init-loading-spin {0% {- webkit-transform: rotate (0); transform: rotate (0)} 100% {- webkit-transform: rotate (360deg); transform: rotate (360deg)}} @ - o-keyframes init-loading-spin {0% {- o-transform: rotate (0); transform: rotate (0 )} 100% {- o-transform: rotate (360deg); transform: rotate (360deg)}} @ keyframes init-loading-spin {0% {- webkit-transform: rotate (0); - o-transform: rotate (0); transform: rotate (0)} 100% {- webkit-transform: rotate (360deg); - o-transform: rotate (360deg); transform: rotate (360deg)}} # init-screen {display: none ; índice z: 500000; posição: fixa; superior: 0; esquerda: 0; altura: 100%; largura: 100%; fonte: 28px / 1 Capacete, Freesans, sem serifa; peso da fonte: 700; cor: #eee; background-color: # 111; text-align: center} # init-screen> div {display: none; position: relative; margin: 0 auto; max-width: 1136px; top:25%} html [data-init = falta] # init-screen, html [data-init = loading] # init-screen, html [data-init = no-js] # init-screen {display: block} html [ data-init = falta] # init-falta, html [data-init = no-js] # init-no-js {display: bloco; preenchimento: 0 1em} html [data-init = no-js] # init- no-js {color: red} html [data-init = loading] # init-loading {display: block; border: 24px solid transparent; border-radius: 50%; border-top-color: # 7f7f7f; border-bottom -color: # 7f7f7f; largura: 100px; altura: 100px; -webkit-animation: init-loading-spin 2s linear infinito; -o-animation: init-loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinito} html [data-init = loading] # init-loading> div {text-indent: 9999em; overflow: hidden; white-space: nowrap} html [data-init = loading] # passagens, html [data-init = carregando] # ui-bar {display: none} </style>html [data-init = no-js] # init-screen {display: block} html [data-init = falta] # init-falta, html [data-init = no-js] # init-no-js {display : block; padding: 0 1em} html [data-init = no-js] # init-no-js {color: red} html [data-init = loading] # init-loading {display: block; border: 24px sólido transparente; raio da borda: 50%; cor da borda superior: # 7f7f7f; cor da borda inferior: # 7f7f7f; largura: 100px; altura: 100px; -webkit-animation: init-loading-spin 2s linear infinito; - o-animation: init-loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinito} html [data-init = loading] # init-loading> div {text-indent: 9999em; estouro: oculto; branco -space: nowrap} html [data-init = loading] # passagens, html [data-init = loading] # ui-bar {display: none} </style>html [data-init = no-js] # init-screen {display: block} html [data-init = falta] # init-falta, html [data-init = no-js] # init-no-js {display : block; padding: 0 1em} html [data-init = no-js] # init-no-js {color: red} html [data-init = loading] # init-loading {display: block; border: 24px sólido transparente; raio da borda: 50%; cor da borda superior: # 7f7f7f; cor da borda inferior: # 7f7f7f; largura: 100px; altura: 100px; -webkit-animation: init-loading-spin 2s linear infinito; - o-animation: init-loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinito} html [data-init = loading] # init-loading> div {text-indent: 9999em; estouro: oculto; branco -space: nowrap} html [data-init = loading] # passagens, html [data-init = loading] # ui-bar {display: none} </style>0 1em} html [data-init = no-js] # init-no-js {color: red} html [data-init = loading] # init-loading {display: block; border: 24px solid transparente; border-radius : 50%; border-top-color: # 7f7f7f; border-bottom-color: # 7f7f7f; width: 100px; height: 100px; -webkit-animation: init-loading-spin 2s linear infinito; -o-animation: init -loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinite} html [data-init = loading] # init-loading> div {text-indent: 9999em; overflow: hidden; white-space: nowrap} html [data-init = loading] # passagens, html [data-init = loading] # ui-bar {display: none} </style>0 1em} html [data-init = no-js] # init-no-js {color: red} html [data-init = loading] # init-loading {display: block; border: 24px solid transparente; border-radius : 50%; border-top-color: # 7f7f7f; border-bottom-color: # 7f7f7f; width: 100px; height: 100px; -webkit-animation: init-loading-spin 2s linear infinito; -o-animation: init -loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinite} html [data-init = loading] # init-loading> div {text-indent: 9999em; overflow: hidden; white-space: nowrap} html [data-init = loading] # passagens, html [data-init = loading] # ui-bar {display: none} </style>init-loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinito} html [data-init = loading] # init-loading> div {text-indent: 9999em; overflow: hidden; white-space: nowrap } html [data-init = loading] # passagens, html [data-init = loading] # ui-bar {display: none} </style>init-loading-spin 2s linear infinito; animação: init-loading-spin 2s linear infinito} html [data-init = loading] # init-loading> div {text-indent: 9999em; overflow: hidden; white-space: nowrap } html [data-init = loading] # passagens, html [data-init = loading] # ui-bar {display: none} </style>
<style id = "style-font" type = "text / css"> @ font-face {font-family: tme-fa-icons; src: url (data: application / octet-stream; base64,d09GRgABAAAAADLAAA8AAAAAWHgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY + IEkIY21hcAAAAdgAAAG8AAAF3rob9jFjdnQgAAADlAAAABMAAAAgBtX / BGZwZ20AAAOoAAAFkAAAC3CKkZBZZ2FzcAAACTgAAAAIAAAACAAAABBnbHlmAAAJQAAAI6gAADv + gJOpzGhlYWQAACzoAAAAMwAAADYY1IZaaGhlYQAALRwAAAAgAAAAJAfCBClobXR4AAAtPAAAAJEAAAFMBfb / 0WxvY2EAAC3QAAAAqAAAAKhjiHI5bWF4cAAALngAAAAgAAAAIAFjDA9uYW1lAAAumAAAAY0AAAL94 + zEpHBvc3QAADAoAAACHAAAA11cG / YjcHJlcAAAMkQAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZNZgnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4vGF4EMgf9z2KIYg5imAYUZgTJAQDSIQumAHic7dTVbltRAETR7dpNCikzQ8rMzMxt / M39mHnsU1 / TfZz5jFpaV7pXJunMDLAZmOqaZjD5y4Tx + uPTyeL5lG2L5zN + L94zG8 + ztr7ulXH1fra4bvK9M79xiWW2sNXPbWeFHexkF7vZw172sZ8DHOQQhznCUY5xnBOc5BSnOcNZVjnHeS5wkUtc5gpX / f3r3OAmt7jNHe5yj / s84CGPeMwTnvKM57zgJa94zRve8o73fOAjn / jMF77yje / 84Ce / WGPun1zi / 2tlXKbp3Xyc44bFyZanSWokJDXOOjXSk / LUSXn + pEwCKTNBaqQqZU5IjX + XMjukTBEp80TKZJEyY6RMGylzR8oEkjKLpEwlKfNJyqSSMrOkTC8pc0zKRJMy26RMOSnzTsrkk7IDpGwDKXtByoaQsiukbA0p + 0PKJpGyU6RsFyl7RmosQcrukbKFpOwjKZtJyo6Ssq2k7C0pG0zKLpOy1aTsNymbTsrOk7L9pNwBUi4CKbeBlCtByr0g5XKQckNIuSak3BVSLgwpt4aUq0PK / SHlEpFyk0i5TqTcKVIuFim3i5QrRso9I + WykXLjXOYNzP8BuAPUwHicY2BAAxIQyBz0PwuEARJsA90AeJytVml300YUHXlJnIQsJQstamHExGmwRiZswYAJQbJjIF2crZWgixQ76b7xid / gX / Nk2nPoN35a7xsvJJC053Cak6N3583VzNtlElqS2AvrkZSbL8XU1iaN7DwJ6YZNy1F8KDt7IWWKyd8FURCtltq3HYdERCJQta6wRBD7HlmaZHzoUUbLtqRXTcotPekuW + NBvVXffho6yrE7oaRmM3RoPbIlVRhVokimPVLSpmWo + itJK7y / wsxXzVDCiE4iabwZxtBI3htntMpoNbbjKIpsstwoUiSa4UEUeZTVEufkigkMygfNkPLKpxHlw / yIrNijnFawS7bT / L4vead3OT + xX29RtuRAH8iO7ODsdCVfhFtbYdy0k + 0oVBF213dCbNnsVP9mj / KaRgO3KzK90IxgqXyFECs / ocz + IVktnE / 5kkejWrKRE0HrZU7sSz6B1uOIKXHNGFnQ3dEJEdT9kjMM9PG + Hvzx3imWCxMCeBzLekclnAgTKWFzNEnaMHJgJWWLKqn1rpg45XVaxFvCfu3a0ZfOaONQd2I8Ww8dWzlRyfFoUqeZTJ3aSc2jKQ2ilHQmeMyvAyg / oklebWM1iZVH0zhmxoREIgIt3EtTQSw7saQpBM2jGb25G6a5di1apMkD9dyj9 / TmVri501PaDvSzRn9Wp2I62AvT6WnkL / Fp2uUiRen66Rl + TOJB1gIykS02w5SDB2 / 9DtLL15YchdcG2O7t8yuofdZE8KQB + xvQHk / VKQlMhZhViFZAYq1rWZbJ1awWqcjUd0OaVr6s0wSKchwXx76Mcf1fMzOWmBK + 34nTsyMuPXPtSwjTHHybdT2a16nFcgFxZnlOp1mW7 + s0x / IDneZZntfpCEtbp6MsP9RpgeVHOh1jeUELmnTfwZCLMOQCDpAwhKUDQ1hegiEsFQxhuQhDWBZhCMslGMLyYxjCchmGsLysZdXUU0nj2plYBmxCYGKOHrnMReVqKrlUQrtoVGpDnhJulVQUz6p / ZaBePPKGObAWSJfIml8xzpWPRuX41hUtbxo7V8Cx6m8fjvY58VLWi4U / BF / V1lQlvWLNw5Or8BuGnmwnqjapeHRNl89VPbr + X1RUWAv0G0iFWCjKsmxwZyKEjzqdhmqglUPMbMw8tOt1y5qfw / 03MUIWUP34NxQaC9yDTllJWe3grNXX27LcO4NyOBMsSTE38 / pW + CIjs9J + kVnKno98HnAFjEpl2GoDrRW82ScxD5neJM8EcVtRNkja2M4EiQ0c84B5850EJmHqqg3kTuGGDfgFYW7BeSdconqjLIfuRezzKKT8W6fiRPaoaIzAs9kbYa / vQspvcQwkNPmlfgxUFaGpGDUV0DRSbqgGX8bZum1Cxg70Iyp2w7Ks4sPHFveVkm0ZhHykiNWjo5 / WXqJOqtx + ZhSX752 + BcEgNTF / e990cZDKu1rJMkdtA1O3GpVT15pD41WH6uZR9b3j7BM5a5puuiceel / TqtvBxVwssPZtDtJSJhfU9WGFDaLLxaVQ6mU0Se + 4BxgWGNDvUIqN / 6v62HyeK1WF0XEk307Ut9HnYAz8D9h / R / UD0Pdj6HINLs / 3mhOfbvThbJmuohfrp + g3MGutuVm6BtzQdAPiIUetjrjKDXynBnF6pLkc6SHgY90V4gHAJoDF4BPdtYzmUwCj + Yw5PsDnzGHQZA6DLeYw2GbOGsAOcxjsMofBHnMYfMGcdYAvmcMgZA6DiDkMnjAnAHjKHAZfMYfB18xh8A1z7gN8yxwGMXMYJMxhsK / p1jDMLV7QXaC2QVWgA1NPWNzD4lBTZcj + jheG / b1BzP7BIKb + qOn2kPoTLwz1Z4OY + otBTP1V050h9TdeGOrvBjH1D4OY + ky / GMtlBr + MfJcKB5RdbD7n74n3D9vFQLkAAQAB // 8AD3icrXsLcFzlleZ // v +++ nb37dfte / VotVrdrW5JltuKpO6WJVluPyXbsmOEbGRjO4KVjWPZlsM4QIU4IYGlgCE2yxqKIQkJg2GreKQCTCZb1CZkiswjzOwOmSTATNVWTZLdDUwSMrVDsomD23vOf69assFAqgbk + 773P4 // nPOdc / 5mwNjFl8WjosbaWblmxiOmIlTGYXzb11M7Z2ohAMbZCcZ5iG9prZl4whfwGju05xtttitUdwXYEUgkbQtWga5lC + XBaqJI285qpb8dVEc8Gnm5L5QM / f58yAlB399a7dD0mWAmdAqaMvBmKPKX9TdDwSjod9yhx03FAPcvI6Gk2lV33XoXUtKgL8C6Wa0WSzXbVjhg6JoqIPShCK0FOvOuE48K1V4B1VUQAVevugmP7Fz2CmTzW5 / 8 + ZGP / + Kp7h / 8oI4MuOZ7M5B9IvujH2Wf + PnCAjzn8ZK6AieMKRcvXnxWWSWCzGARlPcqtqs21WZzEBFgYIVDAYWzVJIrXBlH + hXGlWNM00GAJmYZ8sKBzTJFVZVppijqDFMVdTIWLa0o5JrdaHusPZGIG1IjFhQGK2mAZEe56kJnR1bTY7ZT7eivFGODBTdma3pHtlCNDVbwmgMHx / aO4R8ffeet5 / ZCG6TfuV03IaSJU3oIzKsGO9 + 5PV + BwU5xqnOQx1aO8fW71yvD9fPn55 / fA22PmsaFvfSgwZ8wzPiFvZ2DUMnzJ2hHVDMmHucPsSRrq7UQo4DMAV / AW7CANw / Zru3NIx20bBEpXwukArlxxOPReibaG63 / SyQyiftzcBy3k1HuOHgjEgFHnkYfh4VodDJC4138Ff8hv5PlWbrWmm2O6grNEgGNCWGnbFtRm1Z04gzQPPWvkqMWF4eWU8DB267Df + gNe84bBvfRpfNI5Ny5yAmHDh5 / PPLuByMlekDS9DsRR73nWHetwBShSO5PqCBQONO4E2wGlSvYZG6gMzeQ09SWFZC0tWION3oOVVXGTbGM + hrAzQj0O25yoN8R8YzzRsaZdzLwhpsGPEm783hAJ9 + kq286eDX5pn / VydDjvk7i8EuchU21JJ3DNOqFzeABmywPcNXxhu / BM + 3whrqwVw7Cn1j8vPfdDH6O7PR3fDV / Cb85wua / Wasit309grZJHHOhHEQ9CA7zTGVCUb0ZvXzc1lrRe5Af + 4An0aSL9op0IU9y6vRFtAYGKy7KJGFbQrdg2dXqGAwWilld0zUy9xLqd6A / zeFuy7gzYFmBOwOhZ6NNhZakm8YTI7S1pyM1mM032V26qevXGlzZ8 + TKvROlB / BBkO9ACDalB7OZuBnuC5tRcAItpalENNOfhajVH1A2a1HjbHZ4N4r54oWLz4qPoe4jrMo2sonapm5QRQBQ3XycKVxwRRxjQuVCnWc6mrzOZ5FvBiraOmia5FubYRpok8n0ioRTKOQMNbWiszxYWAFZrQ1sB + dDJTFYghzyiBN3oB857ndIAha4Se / + YGUtjAkXXUO2xPE2eoe3TWPeMOXmzNi + j9w1HghvVbSAmu4c6nFac6MgbzXFU2baDr1241 + 98TfHtU / 9t7df + MzU4msmfPYj06Wbw8Gqohda0 / FkSyiyvtPGG / FsMKq1pLqmPvndkye / + y + 08eYIHEJZpFmJra2Nop / VWuKcCwPvgRhnGlOFps6iIdAEmFVAKh53jblZyBU6nAFdbfX03tGwioZ9oGnEyDSWTQCyFzhoR + s / jdjgWLmc3L2K21zEmXCsM5aDm4g9Ny5v0PZVb + dY9Rcd / sl5eTiPj0nTaeiU + BhhW2qbuzJcUy2Nc2gCrjBkxWCqZiArGgOuwSzjAlDb5L91XfpvfYbpij6ZRIUWYoVcLqC2 + UqNLddsMrekY3GZztVl2uQjpl4xjedIM + Uybc / r5viShuHgcgXuwQtpuoMHz8utCe / s8S + Y / 7xMaYu2DX1yDrez3lp3cyyKdop + HLcLi878Uh9SKOSlj73cOIUFRVKVKHhaSS9JP452RCcYoJ3w85bz8Ckp9VN4xeZj9atpH4FnPCV4OtiDNIVYCrWwsbauK81VxUlaQnA + riFBisoUsiU0LbQpASCmmRAwg1MNJoH19uQ6WpriUV1jIQjphA5QjosiTfiy1tF + kPJKMTFYpAu6lkx40odnTv7VjYtC / QtTJyGH9HmMnKamGrcaqmaagRsMUwR9WeLmwsQREvIRevSvYa8uVFXo9Sc0w5A8 / RP5 + jcxhXLuYAOIx / Pby + ggFp0FV8lNoLNAEQvyDkwBZR9T1ZC6xR0qFgsybix3DJcR7iIGwCsCHHQM0nYKVSBXQZPnqG7KDZiqrn8K524gpN9ghAx42k4GsvF3nohnA0kbnglkC9mrl7h4Db2TommKcVE1QOPRd97K5WJxsKO5nIjHbHtx / og3kK8iWys1he / EkKlqCbFOB6iKQp5Q5Yp6DB0AsjmPvHEFSGsoFraPaVpI2zLc2lmudErjJ / eeQwbKPoRBZulcwhwXYc6i1SdiEpiCF + KrFOIrAzKaHdhQ79tw4MAGuJv4rt8sQQu80jloGnnDfNVJBa + vn1WjSg1d8NHrg44FbTgdJ5 + T77yy / gDI5wY7633yTbI7 + CdyMDyEL2paDd0BvZjyfIYXH2 / H + aqjDfXUisgnk3rFYMePoyZBegWanQpM5hKdlUSU1JnoQH2iG1d90IYADi0JPV2 / oxMEeB7apm + aBngFw / ObMjzHzv7dgzyOh48fHZnmO9c8Wv + 2RAGwHiP20UNnzx46mvYxyaMixDpZX22lQqQgRDqG4kYcMo92cpypAOo0Ti + iSYXJRGc5l8wvQhPfqpE0SYa7nDwkeQyh26OOlbecqVumoCwJ8 + MDM + 9 / 5T4eOyOt + 4wk8WjavYTIG + 7nD5Li2cWv8zGkMYoz51q2u3Y1JQSwfcumSn9JUxW0CZIWQ5isqKCo8zoGFPybx / lyHD2w4AaCBw7Ap1HIxAaHyZlr1tXG1owMt7h5Ox5QmxF4Iv6vDhaQoTFAYADuYIlnLa7b7RwtiOBDtVK1dbyCMXXxn5azOIIKfLFKaQP9K3HKIMYEQosvhkIWH23TQ9wIpCq9M4WxycnJsQIUYrEJ / bPGuOZohfHVzdmMaAmHm418c7DU3xdoyYPebFktPJtpHu7fefjw4R0VHiNTa06ZUTPe09a1sdTUVNrYtbo3nth11VW7tBa1d / U1a1t71rdG2u1IJNkWDYdbUs0pnnFT + OloWzISsdsjqVpvy9prqrNjed41POfPx2 + J7TIXaWP5Wgf5bvToBEvpppQYOXPOJoda4gTQE6TsNK8sAvUSSHBFygfnfM9wL + 8aK / Bddv0tZ8SufyKZ7ml7s20iCWdsPpPu4YVaXuur / 2M6WX8riReTE21vtPUAnn4iyTxdf0vJ + / QM0pwsUL4D5BmUBQEeXpaU4W6RtExzN1In7eT9qHPpIoUdqAzSrdyHIPo1JNRps1uioCWJyIm2U / JG8oO4aZMXozF8b4RupRd5JJv7Nn8ZeUyxjlrakhJHcwO2gHMUDgGLR0MmS0GrIoMRWos0K81LUnPZYgmkw6sM8HtCoQTaT9y0Wu3f / MZuCYfijhMPhUVQNdL2hY8kMroS / 8UvEqqeSfC / xzPV07k3vsqyrL + 2ykYnhJjEz45OLIdbu4ncrbrWhImzltU7oqqaXAEdMWiHxPsSdvuF70K6 / xf6FejjL13YBvFVP + UXrkwnyelZjBcltoLypQIoEmsoiDUw4C2QFS / I / J6yx5ybWOOqaMad0kJlKo + ElAdLqvRTMqOsgucuM64j3hgHU1H1mIkQ084Oje3eXT1lZwL1nwaD0BZMNfFTcHpv + sf7v6LEo4oZMlRbFNqH9tb60nEN0UkQ0mYawZNpR878eFuD1lWsl / Jb9J5iMbPlDKnkh3raBmS66U1M9Jm5rKUmMel1dKLOcxrVSgf5dJqU4o0g0pJyTlV37x4bytpCATOG8VUT4 + m9cPoURiakE34ZMes / wbB0Roun + 2p7h9oLSlwzQqZq2eIr + XE2 / Rhp5QF8hHn5Hh / FfM9ibs32UrNG + l22ZbrnJ8N + fERAcD6YCp6nuPc2Aq / vWXiMfzKaye / BDfzTLPwe33MT8ns4P / y0uiLBdyZw3qRvNvGZegjF6H + escXvreOnkD7zm7IkADTbJEkU4sdw1jmwzpTj42smHLB82ijenjfx9YsXkccR + B5 + I1azGtQk + 4maTpnLlsBL75E7O1IPea + mzfPmUwQt00FJoG + nPxN / zruZzZprTljyx2GpXiHdYWBZtcINeB + 2xVP16 / GT9euDwf00TbqgK5gK7QvCmfp / wPn15WDa3BcM1l / Hy8F9wZQ31nf4Q2IjjrXyG + BnzXnMmqXiTuB5CLa01gINjvb8mesSTwHuSAEtzm8anp + uvwbdprkfhUs0wCNIxH6TP1l / vf6aPDThK0TXI5I + TJJ + SX / 8wIcaPxWX4y + CqsCiEIiAIzhsKrgfh + 6qv + 4L4RETPl6 / zqMKukki9AA96OseZb3Zk7UKVKxZKt65tpR1J9p1sTGgP5Z4ah + KEzl73R / xEfr + I8H5fchlN / Jr0n0c3fSGkrz + vbhd5m2ZWltThDeKUaKh3WTZXWauS + WomBdMkjGvOCRuT9YfcIZxk0x24 / 5cT3q8redxe8TpTsLn03b9LIaFo / I0eQ7uxtjQm6rffI4elnTcJfbwX / qRFyG + VW + SaJdyFIpugk0WXCcnaZFo1323viNAWHZPvk1 + ugfjTf2sbcPR5LDT442bhwPj6Z5z9qi9wr8B85Ji51yXb3tISxlpSUtaZEYnFX8ZbHI6C8vk4ll2h5 / YdRQbM0CUbSmXHsd5rH5zWz7fBnc / 5iA1NLANwyQZ2 + 5JjiYfQ4mle + BxJA1prT9g + 770dv4zTz9RnTPp + JlY4DJKoroOucmyT4fnsGIeFC3H9EtmB + qnGyP6413tPvs4BhIwipskDKakeIg + KKTgbl92JBkkHn1J3c8t + 9ia2vBKhMFkGBJtEjrGDIzKE1SeAgTJiDAVRYpKmSGwMlksJor5gUWgjKlXYS0gurS4neaYflXJnaWBUjDKNAVhkWoF1WhHz7uJ2PapE8NHJkulySPD62 / qVmLapMq10a997JqvnphQarc8dO3UQ2smYr38pfOWszK6fTs + eBKfHy4j8t2uWNrWnbDx5CNfe + TkxrHVE / EEW4ynxM9H2FhtpAeE2tnGFUH1J4xXChxD5hACLNXbLgOA3WU353rI37Y44SipbwdxwED / mEC0rOmuIzmlGkw7SBzNxZ6NN3519 + zXRhV1Uosp3TdtGD68s4eXJo8uzHVtjyXc85gC9MYmRh + euuaRk + vhAG43Tm3RLGW7Clp52Oesq3N7dKVjnW9KxCdWjyFvi / nUs + Ja5CnPxtn + 2t4NnVwLrELw76JqDMz1MacMGJoR0I5RVsA1lR / DLEdonLJLQWnOMcSamKlrszLnWWZ3mzcVOjsrnYWynTfVNmQ6aQFxrWtL9SQtgjqsojbxf5lp + qquSF1rVGyk02qZZEEKRkPdlv9ff3LVQ6MTFMas8xSft3fNVbd + vqg1KaF5w7RwBsirUye24UVXDS3oIcj / NZ + ++ 56mF6qQlUAQ gGoNytcxFG7P98DWMXMoHIL / 6l / Z7p1riv8ko2oiyiru129WsSrmUjO1XdtWc0Pr7miOoWOV9YUQ07WQPmsCisWYDge5puAUAI3NIk6EQACmaQ + BGRaAwOSemV1TH90 + vnlDrZBNFOi / nEUlLL96lYx5VZLqB5zDQLFQzGm6KuUX89L6YqxRuaPsCwXYTlJE1EVJt9ycWTo8bereoW7Wv38ewfOzmgI / N42Kn53LatjTxUCv85zbEyg + Y5hTcDddq99M2ysc8 / 51lABfjZ ++ 8KvSxvUlnpCj7U + mIG3vR8yhXSbXEbaB3cDmatdds4lrhi9Z8hskNo2hkI + RQHWN6fMIUwKGFZiNhDmCNq6BoR1gejCoTzNdD86woB6cPDh33YFr91w99dHJLePr1tp525NylKZkzJtthLplN + ADzhOxjpiN1trRPwb / vhKfqIcMg8Mr3DDqd38o4cM36y9KWa + Tsn7v4 / ocj134Vcg2TZsf / ABFKH4tYwrtObZYYxoF3QiQC + PjATwUho5 + W8MkQlOOqUDxnlMNjZpsfB8zjJCxZe2afKeTjXeuboqT2XcOlsACB6XROFhWch7AeNy / VsZfx4fO5Aj8EjTVRPjLdtrmTS1NX7Azce6kmjZnnHf + 1iuBiG0duzsmQTiZPzfjEoTGAqZ7xqt / nmmai8gXOWb0 / sG9z8vyyPNOZjKDf9DlRgmQR93keVlHOU / 9RTkfH8W8ieTQzWpsc21DGRM0Xw4soAUWDEDPtMB0oS9I5qeXC0PhMySPyTWjuYFctn9JEgWLp6FSXdz71TeSgzuQBmnXVHPXGqWhIhXkF + H2lQXxVqiSO5OthN9CQQSazmBOhdycwSgoZRJvQ28Yz8SVltDiwd3PUxMLN9De1dWehinH5783RvA9xhpyoHgnWAfGvE3sqtqOFT25rGIoMB4GBa0NAaepg2KYyiwVijQqFKGtopEeUFFYgQCboj0jZ8cCk7U1Q2W3MBBLjMRi0SCKxO0od6gD6Muon6Q35JGLDZS9DEpfLNZTA4aqrmrD0rwHCAO8Cs / Ur4a3J0Lql9WU4RfBJiYySfg + cviqaczLvipt59LuhbjXflPdSuRLUUd / 9VV422jRv6SF / NbehYrcQ1p2AZ6jd80L5 + kSRwE3WV + OVGTs9GvnU6yLDbJsrZ2aE + iijskqPtuHgTAktgz0r + xtaUaslZRRH6FKlRJrBwO9bK + lef8YXipg7j8GSJjM + GRPmSApRv6n // T4VrH3qqbRaNxoqoxSNMfwD6MV18yPulftrX + xZ7gXeka7vMCPgf2aQ8 + N4bPuaKz7lg2LIGjjTT3x4T4jvubPYKL + cFtPTxscwm0DA + yVNaMjbFNt / cE9k + sUpoxgas8Gu1qjhG7GqUu ​​+ oAFel8B2gTDcgt + 54If2XXv1VVsmVvRkM4m4TnnrYCGLtt5foc4F2rWO / NrIbxENvBHUy0WJBYqEg8hbyklAxoATvupfHMCZ3wAHaASEAFz / Y7pUPh + ZumWK7z65G1KGftgMJro0NbIzrOvbm1sCuhL9tBGKtrof1aLaZkdRjS4zYhzSDTDVw4bldnrPGtubWgKGiH0adR1JuR9VI / qErSgB72HMk0emp2 + anr6F7kfTydZ + zdKSO0EdDRuTqaip3xAIjapaLa1aWqg / kmqNQEiXzza3ZFbqId3euezR4Iiqbkj5j7ZEIeTX7X4n9vLvLmKL2mAXILVUp0WPoyLCVJVGQ + / yNlGhjP8PNLq4y9vNy9rPrn + eW36OaPmdX0nTF7EIpu9XPlvW1XMgOiHbSHIL1ji1nsbpBdbAyXtlTRwjSHuCqyJvkjfAVEiMe317oeLEURlNKa / CI7tfVLxLp5qb4tFwUFVYJ3R6 / STHqy1Xi1R9RLvvd6lSPIba14rZoo6zwa3w / 7L18OGzRwC + N7B52 + HD2zYPfA8OP3iIH9kyjkd4Fdwj9x85skUPzfXhQd9cSN96mB + 97yjgoYUXvZ7kxYu / UW7mL7Eo + rwKK9byTKWsSWWz6N8VBaZxB5ShgDJZHerscm0J6L1at2fNGPH4CqQNZ + gAGTeaPZVNBB52IJ7nt / uI3N / B0707Do + 8vmEH37rpdTLX8eEDd47Xr564Y3aIj + 67azM8Q4dwYHjpHbJoOu1 / 8OkH ++ lk4s59Y2Lo + tsevG1ukA / N3uHb9f9TbkFebNRET61I / GEuOEtdCkxKcdfISpPptmSn01kdVNF4Y4NjHF1rWnh0cxWZKImsJdKcKPPIkZR5RIoYkcJ7dh665dDOHqV / 4jgc2ILXkYz77zgwypGsH1zKst / L + ir6nJVsPdtR2zaC4aQTZC9CR4p0jigDQ6gmexJcUeeXdbS0xY7WslzDdpPF8uryAPX0L + tqoVNFD5QrFi7rbKGXwYnkJGCpwra4XMZe1th6JZcOCL0VgV445HepqL + l5jVdKMHP1VeH89a / WtYaK2 / 9Z / g4noyFYduzjf6WpSS0FIKDRovrC4aaQ9ZArQ9b1r / K58P0Yhi / 4Msl4WPhFbUuzCTBb1OitsjmCVsAn + Qs3eokTJ1FeEQlI1nGXNlfnbS8tcc / sYz4wU8vsbd + LR / UII5u7mncOYBJ + WKC + 5jsETe / L03AXCfmN4IlTVnCOYiVSxyWr5h45up7d / Lpu568c7ey4zRcu6yjzk9P3Xvu3im5qb9yaf98ab2AwZIsy0Zrq6nXxkG22zi121ScGiC71IoiZwcZqlAmzUCmvaU5GgkkzaQfoNCjlKimWnxvGhtR5b4r0roYFX59BZLFsvVB5NMRIVAGQ65bJoBsRuaFbLJM / 0n3nZCLlZaWYKj + efWy88WezKv + yiG5dKnN23mX2uUJbi5bY + Rc4XgxBrHXGnlYb637gwLPEuXVBmD1ViiIyzgRfl5f9NddvfoB9NDxw0clWD9KV0FbdhMMjzfc + H7uJXEG8fo6Ns4O1q5fU + KCCq16PhXG3JuJcczFw6GwEaLSBXkQwNwF4DgLs1AgHDqA2FToAXEgCDpj + jTudDaDgUmnGsaG9bWx1UOVctJGzBlDf2HJWgZyh1HHkeV53RK5WC6Gc8fr45AzKSByxwlWHShTsxydSgfVLhALUZsXOiS8w0TlVOdJ006bC4ZayA43j7cN9WCqeCgYDTvGJzKnKG0Jn7ou6KSC18Frs8FUk2Jch1frv65 / kWLdMMbf2fWfDKac4HFdaYpb8HY9ZDXZhnEylEgHP7t2L6YMcO46M22b111HA113zoFBDJQUpy / WLx6B36K + MxQdmlHBKerm0BIJKqUu68GgoLY0VSpexdChJiDC1WpC9qwK1cQYpS7U0BW0JAzeMrX6P + hRI2Dy4z / hqqmb4gS3jG8GLT77P1Ue5E4wfOFTFoioAS8NYVYZhv9umJapaPV6hct6wHdkHiowcqVYnvUivt5Qa + 3vK / X2dBXy2Uy6pclBE4pR4XkwxWHTtq93vH + tv0l2U6pFvbNRePWrv51uBFbBWmgHbw / upXv + 0LnRc1AxL / RjLrVgmvx / yP0Fq1KJxarV2A + PHct2HDvWwbvxJIYX60 / THfzHrcdGH7shQm / iC2l6E / fXRumtaPU / ybeyx + p34UkVL0LJv9PAUHOomzL1w8q9uZaYoV3SIOoujHBKKii60eKMxhJHXUMgTQW0InVqqErq22AbYN6BHOMkFCMtlpWLDDc / 0NM23tYLZ1uGMX5ZrWfPtkQj + chQ61lZiH + gZSiai0Sbz4JhDbeswXd2PSVr8E / twqtr8KXdu690Q2KpI6jHMMuhBjdRdbG9iQslEae6YVhDV7gBdOiHgK4iKtSERkv4yOpAP8ZMpimmNqtSRuUFG50FDD2AeaYRNrasGS0P2LTwuGDncpRJNtZ5Fpev85SVhMY6T3ewBJrtjAFIs8XZi95eSXOXLJkW75wKaXmE7afkst1TsjBDJxP3v3I // kG6Z9R + ce7WnfcfrvHRo6fPnT46CpteTMJZ7yXKMb2XTlHieMpspgUYLz + k3UsJV / LFTWNH7vvT08eHlfWHHtx + 69yLSbZMRhHWhDn2SG0oYCC3qE / B0qAKuZqPg + b5XkErlwWmYkKlMkNY2eLmUAqF3OJinmKjrPIhuK1 / W / IJ6z8kh5K1D2aK + / UTWqOzkz1fC4xVOgKKKqgjZqKV9nhTGGOgUGnZjiK4Mq8jJFKOMwJ0UxSLdlO / Ymvrtq8H3 / UG + nBNcG0e7Vh79xt / yOf37KklDMPYaeyc3LZ1y8hwT671KoP8BApooL9agOqYUm2FATeRptTcdeQGxexmC3pWyw2u5ZSr4l9xsLCKW + DaaeqxVskXZql + XdTggY9NDrcHk331MoTzqZSj3fGlCe3GxJQT6IsGjeBkQOGQO53v + VKSb9E1EVMQ5vKs2 / R7axiimWAmiVCh4 / MZ1eYrecvvMWx9oa71KppmNkVhBs6G6m + veHkw8amOFi0QFY4pTI7RrikRxSd1jgBaCeytDEHmYSsUN / HTEEyqQVQ6ppY4937ER / nPmMXaWK6W8TvQy1cj + ++ s28wcIlS70LHqQsSoS5rB18abP70ubwv0VMqrRhJALnb2SJXZ76vg7pAPc9 OF2 + s8XzLyZUMt / 3ajhy35encPGy4n + lIy4Xvvou1JERMJFmTa8zqHldSwlaBa9k6VC63heDzM / 3cYttfndDMiKlbIwCN7eV2F8FS61toUNZhCzHltUoKChwg / yah6WVnr8jIXJer + ultoizj14CWn / GfvvEU5uIjTdtnx8nw86K1TlzWF5QsXBhYXGlw + 3rLk / 5IB / G8 + + gzZuYUagPa8ByoUaWfiRIuA35I4CrJOMVariLtOCaKD Ryq3gvWTwSDci1AAfVtQi7zzsmWE4F5Vq / + RPKDe8714vX5SVSVGuXjxa2K / iCyN42qyOkbLkXwt6FIjmt5sRsHC11VB2yANZQl1HL + GWjFC9Em4Vx7Q2oKTeB2 + oKkeL3xEkBU015zWlri4VEBrpICIlwZ7Eso2mgSVKs8GLeJN5YsLnmn7Lh7 / 45KS6ncSg5I / Por8NcaWi7UW27Te2JeyTGPqPg3VS9j2CzJyeznjn1qaGXCrpsq8ro655n7 + 1zi3WwkBRkGuRl5e3eMyi6L0TvDJcnYwTnM14fWG5Xyh5nXVLya56BmNJRUi25oYoiGRJBGXdaO + Rb1Y9R861mlZYzodsf21K8 / wZ1mC8I75Hr9viTsF + fsW5BzxTSO1IFQNz6DJvnC / lPv9L6Ab4KcvfJU6gC94y9NfMP31s7i5XY5RIn6LJqKRxjAKDuOVppiQA65ycUhaEvVeQya8dVuF6uCYKClVFADVGd5FyGt9RTWAAgg50ahiNFm2YkcCarHv3QTW / 6Jna0TY0VA0FEpnMkbciKJ0RGSrrMN / XzzKfy7p3saOsq21cUl7FVQ2Dboqxg8D38S4hnxooL2bGRU1qurqAtP1Q1M7xzd3Sd4MKlx9aN7cxtWq / 1OQAi25ohrK0s0ilVHwbgmKVNGWD1T / IMmcmd2u68h5MhPsLpW6Mf7ZEUPfceC + 0zfhdXy9uTm5cQffujnZrMQFzmZdv + n0HyDOnl33Z4RjOcFoIL338N50IIpBxBEd9 + 2 + + 7fV vGGHQ5Y18NCTDw1EwkITYRu / JwZe9fPMI + IfxFUsyjbSqvKhAcwt168pdedsTBbTzZxTnRzRxQyV / if8uggP8y2VcpqWw7iyTmgJOy3GuEu5oK35P5xC0L6GZFag308hopD9 / 6r3KyoE7rKG5Tqi3D9z8s6TM / 3 + 7mEeeCxiPDanxdWDjxmRxwKIeebmVFVePajGtTl5VaWLcGDdLdMVpbTvxD0n9pWUyvQtew1RfioQFOU / 1vU / Lotg4KmyMEz9nnuM2OINTVu8ETPuuUeXPuNZUcFYEmd9rFRbYSxfVUjLiN9dFerqyvd2yKWFBEEB548Fup3m1PWnBQHUERnjyKYur0O1v1pBfvl30u2Hnj4EwydOw / CBOyd23vd4 + YefpuUbvHb84elmO9HXD1P3Tq1f48YM5VZ17msH5 / d1fPtmWQndeOwTd1EnZNeXbtwsoBRbcbJ29T3T0GbGDO + 3J95aen6KxViWDVCHL8i5wsPAxPLfE1FDb55RmQnmCYgrEoijOyX + 6KeDoE66Tt5ONjkSgheKBA9LqL6qpqchU0E7QaSYtJ3 + irSVimrrmpLJU3ej0gsK6vTRXbdlEXtnb9u17Z9B + Un9m9Hg5rmoE93YF4zCPwZ31H9b / 6f6b3cEgzvAgAIYO4IwfMe64Q03nOX3fXzD8Lo7brzrLtiCz85tCkajwb6N0b9LJD738MOfSxTs2x7mj3yGsEgjzzBYB9Xw2hGCYAZOzYWG2uR6nFlvxlJeEZfO732ziNsX84be4ffMGz7 / gRmQb1dyTX8Q / dtArU8Hb8Wybmgod53NBlQOilxbg9mPCIstK3sTAzE7O5BMJuTKkvJgwfulBskXM0CBMymXLQrpkSoDMVmJ6aA2QjGG4SJkRk38g5sd61dtYGoQ4St + JHY + U23r4aVWOEjtseoMnDgvfwCEm2 + hp6r / X91AK4zYkU3HMVEaxnR3qBfqPzn + / + wHPnsOreJxjYGRgYABi1vIsoXh m68M3MwvgCIMt5YoxkDp2P9f / 2exVDAHAbkcDEwgUQAz1Qu / AHicY2BkYGAO + p / FwMBS9v / r / 68sFQxAERQQDACh8QbyeJxdT0sVwzAMy49AkAxAkbT3UQiAITGAISmAYQiA9th4ttUs7Q568UeSlVidiwSkB3PUPg + ESd6ZD / + 8v7HyrtzwghY89ZB6BcyrYqc6RZhw48YhaA1Wc / v1PQtdeXJ / HppUmFM597nvBVK7D + Z + E8 / uQZLBgDyaz3Llvxx02S3c / Hv813JrznryZP4F + 6lSfQAAAAAAAAAAUAC2ATABaAGyAfoCJAKwAzYDmgQSBFwExgUyBbQF / AZOBvwHRAe2B / YISgigCPIJGglCCWQJignACgAKQAp2CroLAAtGC4oL8gxcDPINng5iDuYPag / 6EF4RIBGGEeQSShKYEyQTbhOyFAoUYhS + FVoVphYoFooXHBeGGFoYnhjGGOwZChlOGXgZrBneGhwaWhqgGtIbLhvyHHQc2B1QHZ4d / wABAAAAUwBtAAYAAAAAAAIAIAAwAHMAAAB2C3AAAAAAeJx1kN9q2zAUh39q0441YxcbjN3tXJWWEcc1lEGvWkLbXZeSu8JUV / 6T2VKQlY48w95ifYa9zt6jd / vFESUUYiP5O5 / O8ZEE4AP + QWH9nHKsWeEdozXv4A0uIu / Sf488IN9G3sMQPyLv0 / + MfICv + BV5iI / 4wz + owVtGM / yNrPBZfYm8g / fqW + Rd + SVIA / Jd5D18UovI + / S / Ix9gqp4iD3GoniduvvR1WQU5mhxLlmap3C / FUdVWN6IXoXK + k3MpnA2maVySuza0ZlToUZ07292YctFov6k2eWp8VzsrJ0m6qa + NNV4H87Dq1j2WWQiFFN61chX7yNy7mclDUoUwPxuPN / tjAoc5lvCoUaJCgOCI9pjfDGk / BPfMEGaus2pYaDQ0GgtWVP1Kx / ico2BkaQ0zGnKCnHNL09KNuK451721rLqhLfmfht5vzdrmp7Sr3nUfC07YL92afU1r + wrd7 / Dh5WwdHrmLjDawanUK3 + 9acPXqPML7Wq3NaHL6pL + 1QHuGMd8t5 / 8PvPGO3QAAAHicbZLnlpswEIV9DRiwvZtseu89Ib333vvmBWRZYMVC0pHEEufpg8BO / kTncOfTaLgMOtPr97o17P1 / baKPACEiDBAjQYohRhhjDevYhu3YwA7sxC7sxh7sxT7sxwEcxCEcxhEcxTEcxwmcxCmcxhmcxTmcxwVcxCVkuIwruIpruI4buIlbuI07uIt7uI8HeIhHeIwneIpneI4XeIlXeI03eIt3eI8P + IHP + IWV + IPV + I5N / OiF1hEz9JKxUrtFrDl1lWF9NR9QIikToRaVjUouKxvOmNBjLxnlhgo2DbnM1djLKrNGnGPScSUzItzGv93yPP2bSQSX84z9cqFQdJ56yZRmMhW8mLlJJSaBI0XYPDaZKDUviZmvr6DrNjJMi0WcK1MTM02mqpbZlJtEsNx5SI238jSodJtoS7qv + BpPw67IY9xU + dg5TXjROTWwdGrIOzWhT + uA0jolxqjaZrSOnCF2Nmq16651EYpMm1fakAul9SJQeR5QVYQlk1VkZ8SwoVNFIVjWnKQrlBGdMToftdoZjrs77DajqXKrS02YEFxbbtdWkG0x44JJVUS5aBqKSlJwmhDrmOF2Hv9Wqsy4TNqoKhfmSrrQKuNSL5nvPG6p0s0AkEWkSWVZMy1Kx3ljk03qLuZ14lTmB8gNGmByGrGfjLrhlhJV2f7SaIneNF1ypQNbybBUSgZswQaWEUNngeay1 / sD4l / 60HicY / DewXAiKGIjI2Nf5AbGnRwMHAzJBRsZWJ02MTAyaIEYm7mYGDkgLD4GMIvNaRfTAaA0J5DN7rSLwQHCZmZw2ajC2BEYscGhI2Ijc4rLRjUQbxdHAwMji0NHckgESEkkEGzmYWLk0drB + L91A0vRistyle) (formato 'wAMDi0vRi) (' wAMoffdi) = formato 'WAMDi0vAdi)
<style id = "style-core" type = "text / css"> html {font: 16px / 1 Helmet, Freesans, sans-serif} # store-area, tw-storydata {display: none! important; Z-index : 0} .no-transição {-webkit-transição: nenhum! Importante; -o-transição: nenhum! Importante; transição: nenhum! Importante}: - webkit-tela inteira {altura: 100%; largura: 100%} : -ms-fullscreen {height: 100%; width: 100%}: fullscreen {height: 100%; width: 100%} body :: - ms-backdrop {background: 0 0}: focus {outline: thin dotted} : disabled {cursor: not-allowed! important} body {color: #eee; background-color: # 111; overflow: auto} a {cursor: pointer; color: # 68d; text-decoration: none; -webkit-transit -duração: .2s; -o-transição-duração: .2s; transição-duração: .2s} a: hover {color: # 8af; text-decoration: underline} a.link-broken {color: # c22} a .link-broken: hover {color: # e44} a [disabled], span.link-disabled {color: #aaa; cursor: not-allowed! important;text-decoration: none} area {cursor: pointer} button {cursor: pointer; color: #eee; background-color: # 35a; border: 1px solid # 57c; line-height: normal; padding: .4em; -webkit -transição-duração: .2s; -o-transição-duração: .2s; transição-duração: .2s; -webkit-user-select: nenhum; -moz-user-select: nenhum; -ms-user-select: nenhum; seleção do usuário: nenhum} botão: foco {cor de fundo: # 57c; cor da borda: # 79e} botão: desativado {cor de fundo: # 444; borda: 1px sólido # 666} entrada, seleção, área de texto { color: #eee; background-color: transparent; border: 1px solid # 444; padding: .4em} select {padding: .34em .4em} input [type = text] {min-width: 18em} textarea {min-width : 30em; resize: vertical} input [type = checkbox], input [type = file], input [type = radio], selecione {cursor: pointer} input [type = range] {- webkit-aparência: nenhum; min- altura: 1,2em} input [type = range]: focus {outline: 0} input [type = range] :: - webkit-slider-runnable-track {background:# 222; border: 1px sólido # 444; border-radius: 0; cursor: ponteiro; altura: 10px; largura: 100%} input [type = range] :: - webkit-slider-thumb {-webkit-aparência: nenhum ; background: # 35a; border: 1px sólido # 57c; border-radius: 0; cursor: pointer; height: 18px; margin-top: -5px; width: 33px} input [type = range]: focus :: - webkit -slider-runnable-track {background: # 222} input [type = range] :: - moz-range-track {background: # 222; border: 1px solid # 444; border-radius: 0; cursor: ponteiro; altura : 10px; largura: 100%} input [type = range] :: - moz-range-thumb {background: # 35a; border: 1px sólido # 57c; border-radius: 0; cursor: ponteiro; altura: 18px; largura : 33px} input [type = range] :: - ms-track {background: 0 0; border-color: transparent; color: transparent; cursor: pointer; height: 10px; width: calc (100% - 1px)} input [type = range] :: - ms-fill-lower {background: # 222; border: 1px solid # 444; border-radius: 0} input [type = range] :: - ms-fill-upper {background: # 222;border: 1px solid # 444; border-radius: 0} input [type = range] :: - ms-thumb {background: # 35a; border: 1px solid # 57c; border-radius: 0; cursor: ponteiro; altura: 16px; largura: 33px} input: not (: disabled): focus, input: not (: disabled): hover, select: not (: disabled): focus, select: not (: disabled): hover, textarea: not ( : disabled): focus, textarea: not (: disabled): hover {background-color: # 333; border-color: #eee} hr {display: block; height: 1px; border: none; border-top: 1px sólido #eee; margin: 1em 0; padding: 0} audio, canvas, progress, video {max-width: 100%; vertical-align: middle} .error-view {background-color: # 511; border-left :. 5em solid # c22; display: inline-block; margin: .1em; max-width: 100%; padding: 0 .25em; position: relative} .error-view> .error-toggle {background-color: transparent; border : nenhum; altura da linha: herdar; esquerda: 0; preenchimento: 0; posição: absoluto; topo: 0; largura: 1,75em} .error-view> .error {display: inline-block;margin-left: .25em} .error-view> .error-toggle + .error {margin-left: 1.5em} .error-view> .error-source [oculto] {display: none} .error-view> .error -source: not ([hidden]) {background-color: rgba (0,0,0, .2); display: block; margin: 0 0 .25em; overflow-x: auto; padding: .25em} .highlight , .marcado {color: # ff0; font-weight: 700; font-style: italic} .nobr {white-space: nowrap} .error-view> .error-toggle: before, .error-view> .error: before, [data-icon-after]: after, [data-icon-before]: before, [data-icon]: before, a.link-external: after {font-family: tme-fa-icons; font- style: normal; font-weight: 400; font-variant: normal; text-transform: none; line-height: 1; speak: none} [data-icon]: before {content: attr (data-icon)} [ data-icon-before]: before {content: attr (data-icon-before) "\ 00a0 \ 00a0"} [data-icon-after]: after {content: "\ 00a0 \ 00a0" attr (data-icon- after)}. error-view> .error-toggle:before {content: "\ e81a"}. error-view> .error-toggle.enabled: before {content: "\ e818"}. error-view> .error: before {content: "\ e80d \ 00a0 \ 00a0" } a.link-external: after {content: "\ 00a0 \ e80e"} </style>
<style id = "style-core-display" type = "text / css"> # story {z-index: 10; margin: 2.5em} tela @media e (largura máxima: 1136px) {# story {margin- direita: 1.5em}} # passagens {max-width: 54em; margin: 0 auto} </style>
<style id = "style-core-passage" type = "text / css">. passage {line-height: 1,75; text-align: left; -webkit-transit: opacity .4s easy-in; -o-transit : opacidade .4s atenuação; transição: opacidade .4s atenuação} .passage-in {opacidade: 0} .passage ol, .passage ul {margin-left: .5em; padding-left: 1.5em} .passage tabela {margin: 1em 0; border-collapse: collapse; font-size: 100%}. passagem caption, .passage td, .passage th, .passage tr {padding: 3px} </style>
<style id = "style-core-macro" type = "text / css"> @ - webkit-keyframes cursor-piscar {0% {opacidade: 1} 50% {opacidade: 0} 100% {opacidade: 1}} @ -o-keyframes cursor-blink {0% {opacity: 1} 50% {opacity: 0} 100% {opacity: 1}} @ keyframes cursor-blink {0% {opacity: 1} 50% {opacity: 0 } 100% {opacidade: 1}}. Macro-append-insert, .macro-linkappend-insert, .macro-linkprepend-insert, .macro-linkreplace-insert, .macro-prepend-insert, .macro-repeat-insert , .macro-replace-insert, .macro-timed-insert {-webkit-transit: opacity .4s Easy-in; -o-transit: opacity .4s Easy-in; transição: opacity .4s Easy-in} .macro -append-in, .macro-linkappend-in, .macro-linkprepend-in, .macro-linkreplace-in, .macro-prepend-in, .macro-repeat-in, .macro-replace-in, .macro- timed-in {opacity: 0} .macro-type-cursor: after {-webkit-animation: cursor-piscar 1s infinito; -o-animation: cursor-piscar 1s infinito; animação:cursor intermitente 1s infinito; conteúdo: "\ 2590"; opacidade: 1} </style>
<style id = "style-ui-dialog" type = "text / css"> html [data-dialog] body {overflow: hidden} # ui-overlay.open {visibilidade: visível; -webkit-transição: opacidade .2s facilidade de entrada; -o-transição: opacidade .2s facilidade de entrada; transição: opacidade .2s facilidade de entrada} # ui-overlay: não (.open) {- webkit-transição: visibilidade .2s etapa final, opacidade. Facilidade 2s; -o-transição: visibilidade .2s etapa final, opacidade .2s fácil entrada; transição: visibilidade .2s etapa final, opacidade .2s fácil entrada} # ui-overlay {visibilidade: oculto; opacidade : 0; Z-index: 100000; posição: fixa; superior: -50%; esquerda: -50%; altura: 200%; largura: 200%} # ui-dialog.open {display: block; -webkit-transit : opacidade .2s atenuação; -o-transição: opacidade .2s atenuação; transição: opacidade .2s atenuação} # ui-dialog {display: none; opacity: 0; z-index: 100100; posição: fixo; superior: 50px; margem: 0; preenchimento: 0} # ui-dialog> * {- webkit-box-sizing: border-box; box-sizing:border-box} # ui-dialog-titlebar {position: relative} # ui-dialog-close {display: block; position: absolute; right: 0; top: 0; white-space: nowrap} # ui-dialog-body {overflow: auto; min-width: 280px; height: 92%; height: calc (100% - 2.1em)} # ui-overlay {background-color: # 000} # ui-overlay.open {opacity: .8 } # ui-dialog {max-width: 66em} # ui-dialog.open {opacity: 1} # ui-dialog-titlebar {background-color: # 444; min-height: 24px} # ui-dialog-title { margin: 0; padding: .2em 3.5em .2em .5em; font-size: 1.5em; text-align: center; text-transform: uppercase} # ui-dialog-close {cursor: ponteiro; font-size: 120 %; margem: 0; preenchimento: 0; largura: 3,6em; altura: 92%; cor de fundo: transparente; borda: 1px transparente sólido; -webkit-transição-duração: .2s; -o-transição-duração :. 2s; duração da transição: .2s} # ui-dialog-close: hover {background-color: # b44; border-color: # d66} # ui-dialog-body {background-color: # 111; border: 1px sólido # 444;text-align: left; line-height: 1.5; padding: 1em} # ui-dialog-body>: first-child {margin-top: 0} # ui-dialog-body hr {background-color: # 444} # ui-dialog-body ul.buttons {margin: 0; padding: 0; list-style: none} # ui-dialog-body ul.buttons li {display: inline-block; margin: 0; padding: .4em .4em 0 0} # ui-dialog-body ul.buttons> li + li> botão {margin-left: 1em} # ui-dialog-close {-webkit-user-select: none; -moz-user-select: nenhum; -ms-user-select: none; user-select: none} # ui-dialog-close {font-family: tme-fa-icons; font-style: normal; font-weight: 400; font-variant: normal; transformação do texto: nenhum; altura da linha: 1; fala: nenhum} </style>4em 0 0} # ui-dialog-body ul.buttons> li + li> botão {margin-left: 1em} # ui-dialog-close {-webkit-user-select: nenhum; -moz-user-select: nenhum ; -ms-user-select: none; user-select: none} # ui-dialog-close {font-family: tme-fa-icons; font-style: normal; font-weight: 400; font-variant: normal ; transformação do texto: nenhum; altura da linha: 1; fala: nenhum} </style>4em 0 0} # ui-dialog-body ul.buttons> li + li> botão {margin-left: 1em} # ui-dialog-close {-webkit-user-select: nenhum; -moz-user-select: nenhum ; -ms-user-select: none; user-select: none} # ui-dialog-close {font-family: tme-fa-icons; font-style: normal; font-weight: 400; font-variant: normal ; transformação do texto: nenhum; altura da linha: 1; fala: nenhum} </style>
<style id = "style-ui" type = "text / css"> # ui-dialog-body.settings [id | = setting-body]> div: first-child {display: table; width: 100%} # ui-dialog-body.settings [id | = setting-label] {display: table-cell; padding: .4em 2em .4em 0} # ui-dialog-body.settings [id | = setting-label] + div { display: table-cell; min-width: 8em; text-align: right; vertical-align: middle; white-space: nowrap} # ui-dialog-body.list {padding: 0} # ui-dialog-body. list ul {margin: 0; padding: 0; list-style: none; border: 1px solid transparent} # ui-dialog-body.list li {margin: 0} # ui-dialog-body.list li: not (: primeiro filho) {border-top: 1px solid # 444} # ui-dialog-body.list li a {display: block; padding: .25em .75em; border: 1px solid transparent; color: #eee; text-decoration : none} # ui-dialog-body.list li a: hover {background-color: # 333; border-color: #eee} # ui-dialog-body.saves {padding: 0 0 1px} # ui-dialog- body.saves>:not (: first-child) {border-top: 1px solid # 444} # ui-dialog-body.saves table {border-spacing: 0; width: 100%} # ui-dialog-body.saves tr: not ( : first-child) {border-top: 1px solid # 444} # ui-dialog-body.saves td {padding: .33em .33em} # ui-dialog-body.saves td: first-child {min-width: 1.5em; text-align: center} # ui-dialog-body.saves td: nth-child (3) {line-height: 1.2} # ui-dialog-body.saves td: last-child {text-align: right} # ui-dialog-body.saves .empty {color: # 999; speak: none; text-align: center; -webkit-user-select: none; -moz-user-select: none; -ms-user -select: none; user-select: none} # ui-dialog-body.saves .datestamp {font-size: 75%; margin-left: 1em} # ui-dialog-body.saves ul.buttons li {padding: .4em} # ui-dialog-body.saves ul.buttons> li + li> botão {margin-left: .2em} # ui-dialog-body.saves ul.buttons li: last-child {float: right} # ui-dialog-body.settings div [id | = header-body] {margin:1em 0} # ui-dialog-body.settings div [id | = header-body]: first-child {margin-top: 0} # ui-dialog-body.settings div [id | = header-body]: not (: primeiro filho) {border-top: 1px solid # 444; padding-top: 1em} # ui-dialog-body.settings div [id | = header-body]> * {margin: 0} # ui-dialog -body.settings h2 [id | = header-header] {font-size: 1.375em} # ui-dialog-body.settings p [id | = header-desc], # ui-dialog-body.settings p [id | = setting-desc] {font-size: 87,5%; margin: 0 0 0 .5em} # ui-dialog-body.settings div [id | = setting-body] + div [id | = setting-body] { margin: 1em 0} # ui-dialog-body.settings [id | = setting-control] {white-space: nowrap} botão # ui-dialog-body.settings [id | = setting-control] {color: #eee ; background-color: transparent; border: 1px solid # 444; padding: .4em} # ui-dialog-body.settings button [id | = setting-control]: hover {background-color: # 333; border-color: #eee} # ui-dialog-body.settings botão [id | = setting-control].ativado {background-color: # 282; border-color: # 4a4} # ui-dialog-body.settings button [id | = setting-control] .enabled: hover {background-color: # 4a4; border-color: # 6c6} # ui-dialog-body.settings input [type = range] [id | = setting-control] {max-width: 35vw} # ui-dialog-body.list a, # ui-dialog-body.settings span [id | = setting-input] {- webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none} # ui-dialog-body.saves botão [id = saves-clear]: before, # ui-dialog-body.saves botão [id = saves-export]: before, # ui-dialog-body.saves botão [id = saves-import]: before, # botão ui-dialog-body.settings [id | = setting-control] .enabled: after, # ui-dialog-body.settings button [id | = setting-control]: after {font-family: tme-fa-icons ; font-style: normal; font-weight: 400; font-variant: normal; text-transform: none; line-height: 1; speak: none} # ui-dialog-body.saves botão [id = saves-export ]: antes de {conteúdo:"\ e829 \ 00a0"} # ui-dialog-body.saves button [id = saves-import]: before {content: "\ e82a \ 00a0"} # ui-dialog-body.saves button [id = saves-clear ]: before {content: "\ e827 \ 00a0"} # ui-dialog-body.settings button [id | = setting-control]: after {content: "\ 00a0 \ 00a0 \ e830"} # ui-dialog-body botão .settings [id | = setting-control] .enabled: after {content: "\ 00a0 \ 00a0 \ e831"} </style>
<style id = "style-ui-bar" type = "text / css"> # story {margin-left: 20em; -webkit-transit: margin-left .2s Easy-in; -o-transit: margin-left .2s Easy-in; transição: margin-left .2s Easy-in} # ui-bar.stowed ~ # story {margin-left: 4.5em} @media screen e (max-width: 1136px) {# story {margin -esquerda: 19em} # ui-bar.stowed ~ # story {margin-left: 3.5em}} @ media screen e (max-width: 768px) {# story {margin-left: 3.5em}} # ui-bar {position: fixed; z-index: 50; top: 0; left: 0; width: 17.5em; height: 100%; margin: 0; padding: 0; -webkit-transit: left .2s easy-in; - o-transição: left .2s Easy-in; transição: left .2s Easy-in} # ui-bar.stowed {left: -15.5em} # ui-bar-tray {position: absolute; top: .2em; left : 0; direita: 0} # ui-bar-body {altura: 90%; altura: calc (100% - 2,5em); margem: 2,5em 0; preenchimento: 0 1,5em} # ui-bar.stowed #ui -bar-body, # ui-bar.stowed # ui-bar-history {visibilidade: oculto; -webkit-transição:visibilidade .2s etapa final; -o-transição: visibilidade .2s etapa final; transição: visibilidade .2s etapa final} # ui-bar {cor de fundo: # 222; borda direita: 1px sólido # 444; texto -align: center} # ui-bar a {text-decoration: none} # ui-bar hr {border-color: # 444} # ui-bar-history [id | = history], # ui-bar-toggle { font-size: 1.2em; line-height: inherit; color: #eee; background-color: transparent; border: 1px solid # 444} # ui-bar-toggle {display: block; position: absolute; top: 0; right: 0; border-right: none; padding: .3em .45em .25em} # ui-bar.stowed # ui-bar-toggle {padding: .3em .35em .25em .55em} # ui-bar-toggle: hover {background-color: # 444; border-color: #eee} # ui-bar-history {margin: 0 auto} # ui-bar-history [id | = history] {padding: .2em .45em .35em} # ui-bar-history # history-jumpto {padding: .2em .665em .35em} # ui-bar-history [id | = history]: not (: first-child) {margin-left: 1.2em} #ui -bar-history [id | = history]:passe o mouse {background-color: # 444; border-color: #eee} # ui-bar-history [id | = history]: disabled {color: # 444; background-color: transparent; border-color: # 444} # ui-bar-body {line-height: 1.5; overflow: auto} # ui-bar-body>: not (: first-child) {margin-top: 2em} # story-title {margin: 0; font-size : 162,5%} # story-author {margin-top: 2em; font-weight: 700} #menu ul {margin: 1em 0 0; padding: 0; list-style: none; border: 1px solid # 444} #menu ul: empty {display: none} #menu li {margin: 0} #menu li: not (: first-child) {border-top: 1px solid # 444} #menu li a {display: block; padding: .25em .75em; border: 1px solid transparente; color: #eee; text-transform: uppercase} #menu li a: hover {background-color: # 444; border-color: #eee} #menu a, # ui-bar- histórico [id | = histórico], # ui-bar-toggle {-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none} #menu -core li [id | = item de menu] a: antes,# ui-bar-history [id | = history], # ui-bar-toggle: before {font-family: tme-fa-icons; font-style: normal; font-weight: 400; font-variant: normal; text-transform: none; line-height: 1; speak: none} # ui-bar-toggle: before {content: "\ e81d"} # ui-bar.stowed # ui-bar-toggle: before {content: " \ e81e "} # menu-item-salva a: before {content:" \ e82b \ 00a0 "} # menu-item-settings a: before {content:" \ e82d \ 00a0 "} # menu-item-restart a: before {content: "\ e82c \ 00a0"} # menu-item-share a: before {content: "\ e82f \ 00a0"} </style>} # menu-item-settings a: before {content: "\ e82d \ 00a0"} # menu-item-restart a: before {content: "\ e82c \ 00a0"} # menu-item-share a: before {content : "\ e82f \ 00a0"} </style>} # menu-item-settings a: before {content: "\ e82d \ 00a0"} # menu-item-restart a: before {content: "\ e82c \ 00a0"} # menu-item-share a: before {content : "\ e82f \ 00a0"} </style>
<style id = "style-ui-debug" type = "text / css"> # debug-bar {background-color: # 222; border-left: 1px solid # 444; border-top: 1px solid # 444; inferior : 0; margem: 0; altura máxima: 75%; preenchimento: .5em; posição: fixa; direita: 0; índice z: 99900} # barra de depuração> div: não ([id]) + div {margem -top: .5em} # debug-bar> div> label {margin-right: .5em} # debug-bar> div> input [type = text] {min-width: 0; width: 8em} # debug-bar > div> selecione {largura: 15em} # debug-bar-toggle {color: #eee; background-color: # 222; border: 1px solid # 444; height: 101%; height: calc (100% + 1px); esquerda: -2em; esquerda: calc (-2em - 1px); posição: absoluto; topo: -1px; largura: 2em} # debug-bar-toggle: hover {background-color: # 333; border-color: #eee } # debug-bar-hint {bottom: .175em; font-size: 4.5em; opacidade: .33; ponteiro-eventos: nenhum; posição: fixo; direito: .6em; -webkit-user-select: nenhum; - moz-user-select: none; -ms-user-select: none; user-select:nenhum; espaço em branco: nowrap} # debug-bar-watch {background-color: # 222; border-left: 1px solid # 444; border-top: 1px solid # 444; bottom: 102%; bottom: calc (100 % + 1px); font-size: .9em; left: -1px; max-height: 650%; max-height: 65vh; position: absoluto; overflow-x: hidden; overflow-y: scroll; right: 0; z-index: 99800} # debug-bar-watch [oculto] {display: none} # debug-bar-watch div {color: # 999; font-style: italic; margin: 1em auto; text-align: center} # debug-bar-watch table {width: 100%} # debug-bar-watch tr: nth-child (2n) {background-color: rgba (127,127,127, .15)} # debug-bar-watch td {padding: .2em 0} # debug-bar-watch td: first-child + td {padding: .2em .3em .2em .1em} # debug-bar-watch .watch-delete {background-color: transparent; border: none; color: # c00} # debug-bar-watch-all, # debug-bar-watch-none {margin-left: .5em} # debug-bar-views-toggle, # debug-bar-watch-toggle {color: #eee; cor de fundo: transparente; borda:1px sólido # 444; margin-right: 1em; padding: .4em} # debug-bar-views-toggle: hover, # debug-bar-watch-toggle: hover {background-color: # 333; border-color: # eee} # debug-bar-watch: not ([oculto]) ~ div # debug-bar-watch-toggle, html [data-debug-view] # debug-bar-views-toggle {background-color: # 282; border-color: # 4a4} # debug-bar-watch: not ([oculto]) ~ div # debug-bar-watch-toggle: hover, html [data-debug-view] # debug-bar-views-toggle: hover {background-color: # 4a4; border-color: # 6c6} # debug-bar-hint: after, # debug-bar-toggle: before, # debug-bar-views-toggle: after, # debug-bar- watch .watch-delete: before, # debug-bar-watch-add: before, # debug-bar-watch-all: before, # debug-bar-watch-none: before, # debug-bar-watch-toggle: após {font-family: tme-fa-icons; font-style: normal; font-weight: 400; font-variant: normal; text-transform: none; line-height: 1; speak: none} # debug-bar -toggle: antes de {content: "\ e838"} # debug-bar-hint: after {content: "\ e838 \ 202f \ e822"} # debug-bar-watch .watch-delete: before {content: "\ e804"} # debug-bar-watch-add: antes de {content: "\ e805"} # debug-bar-watch-all: before {content: "\ e83a"} # debug-bar-watch-none: before {content: "\ e827"} # debug-bar- views-toggle: after, # debug-bar-watch-toggle: after {content: "\ 00a0 \ 00a0 \ e830"} # debug-bar-watch: not ([oculto]) ~ div # debug-bar-watch- toggle: after, html [data-debug-view] # debug-bar-views-toggle: after {content: "\ 00a0 \ 00a0 \ e831"} html [data-debug-view] .debug {padding: .25em; background-color: # 234} html [data-debug-view] .debug [título] {cursor: help} html [data-debug-view] .debug.block {display: inline-block; vertical-align: middle} html [data-debug-view] .debug.invalid {text-decoration: line-through} html [data-debug-view] .debug.hidden, html [data-debug-view] .debug.hidden .debug {background-color: # 555} html: not ([data-debug-view]) .debug.hidden {display: none} html [data-debug-view] .debug [data-name] [data- type] .nonvoid: after, html [data-debug-view] .debug [data-name] [data-type]: before {background-color: rgba (0,0,0, .25); font-family: monoespaço, monoespaço; espaço em branco: pre} html [data-debug-view] .debug [data-name] [data-type]: before {content: attr (data-name)} html [data-debug-view] .debug [data-name] [data-type | = macro]: before {content: "<<" attr (data-name) ">>"} html [data-debug-view] .debug [data-name] [data-type | = macro] .nonvoid: after {content: "<< /" attr (data-name) ">>"} html [data-debug-view] .debug [data-name] [data-type | = html]: before {content: "<" attr (data-name) ">"} html [data-debug-view] .debug [data-name] [data-type | = html] .nonvoid: after { conteúdo: "</ "attr (data-name)"> "} html [data-debug-view] .debug [data-name] [data-type]: not (: empty): before {margin-right: .25em} html [ data-debug-view] .debug [data-name] [data-type] .nonvoid: not (: empty): after {margin-left: .25em} html [data-debug-view] .debug [data-name ] [data-type | = special], html [data-debug-view] .debug [data-name] [data-type | = special]: before {display: block} </style>
</head>
<body>
	<div id = "init-screen">
		<div id = "init-no-js"> <noscript> JavaScript é necessário. Ative-o para continuar. </noscript> </div>
		<div id = "init-missinging"> Seu navegador não possui os recursos necessários. Atualize-o ou mude para outro para continuar. </div>
		<div id = "init-loading"> <div> Carregando & hellip; </div> </div>
	</div>
	<tw-storydata name = "FT-RIDDLE" startnode = "9" creator = "Twine" creator-version = "2.3.13" ifid = "5DCD6661-5E3D-4096-B6F3-1F9C07453854" zoom = "1" format = "SugarCube" format-version = "2.34.1" options = "" hidden> <style role = "stylesheet" id = "twine-user-stylesheet" type = "text / twine-css"> body {
  cor de fundo: # 368049;
} </style> <script role = "script" id = "twine-user-script" type = "text / twine-javascript"> </script> <tw-passagedata pid = "1" name = "Tela principal" tags = "" position = "750.400" size = "100,100"> OLÁ, & lt; strong & gt; $ nomeplayer & lt; / strong & gt;

[[MULTIPLAYER]]
[[INSTRUÇÕES]] 
[[CONFIGURAÇÃO]] 
[[CRÉDITOS]] 


Versão 0.15 - 29/03/2021 13:50 </tw-passagedata> <tw-passagedata pid = "2" name = "MULTIPLAYER" tags = "" position = "750.600" size = "100,100"> [img [Home .png] [Tela principal]] [img [Config.png] [CONFIGURAÇÃO]]

& lt; & lt; caixa de texto & quot; $ codigosala & quot; & quot; Digite código da sala & quot; & gt; & gt;
[[BUSCAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "3" name = "CRÉDITOS" tags = "" position = "550,400" size = "100,100"> [img [Home.png] [Tela principal]] [img [Config.png] [CONFIGURAÇÃO]]

Francine Régis Duarte
Thiago Paim Alflen
Boi da cara preta

& lt; forte & gt; - INSPIRAÇÕES - & lt; / forte & gt;
Livros do autor Dan Brown, especialmente & quot; Enigma perdido & quot ;, & quot; O Código Da Vinci & quot; e & quot; Fortaleza Digital & quot;

& lt; forte & gt; - MÚSICAS - & lt; / forte & gt;
https://www.youtube.com/watch?v=g9aDotEGP4w

& lt; forte & gt; - IMAGENS - & lt; / forte & gt;
https://www.pngwing.com

& lt; strong & gt; - FONTES - & lt; / strong & gt;
https://www.motoslave.net/sugarcube/2/docs/

& lt; forte & gt; - OUTROS - & lt; / forte & gt;
https://pt.wikihow.com
https://brasilescola.uol.com.br
https://pt.wikipedia.org
https://pontodoconhecimento.blogspot.com
https://mundoeducacao.uol.com.br

8ª fase do curso de Telecomunicações - IFSC / SJ - Turma 2017/1
</tw-passagedata> <tw-passagedata pid = "4" name = "Sala Multiplayer" tags = "" position = "750,800" size = "100,100"> [img [Home.png] [Tela principal]] [img [Config.png] [CONFIGURAÇÃO]]


& lt; & lt; botão & quot; JOGAR & quot; & gt; & gt;

		& lt; & lt; set $ desafios = [& quot; D1 & quot;, & quot; D2 & quot;, & quot; D3 & quot;, & quot; D4 & quot;, & quot; D5 & quot;, & quot; D6 & quot;] & gt; & gt;


		& lt; & lt; set _storyEvent = $ desafios.random () & gt; & gt;

		& lt; & lt; if _storyEvent == & quot; D1 & quot; & gt; & gt;

			& lt; & lt; goto & quot; D1 & quot; & gt; & gt;

		& lt; & lt; elseif _storyEvent == & quot; D2 & quot; & gt; & gt;

			& lt; & lt; goto & quot; D2 & quot; & gt; & gt;

		& lt; & lt; elseif _storyEvent == & quot; D3 & quot; & gt; & gt;

			& lt; & lt; goto & quot; D3 & quot; & gt; & gt;

		& lt; & lt; elseif _storyEvent == & quot; D4 & quot; & gt; & gt;

			& lt; & lt; goto & quot; D4 & quot; & gt; & gt;
			
		& lt; & lt; elseif _storyEvent == & quot; D5 & quot; & gt; & gt;

			& lt; & lt; goto & quot; D5 & quot; & gt; & gt;
		
		& lt; & lt; elseif _storyEvent == & quot; D6 & quot; & gt; & gt;

			& lt; & lt; goto & quot; D6 & quot; & gt; & gt;
			
		& lt; & lt; / if & gt; & gt;
& lt; & lt; / botão & gt; & gt;

[[VOLTAR | MULTIPLAYER]]
</tw-passagedata> <tw-passagedata pid = "5" name = "CONFIGURAÇÃO" tags = "" position = "950,400" size = "100,100"> [img [Home.png] [Tela principal]]

DESLIGAR MÚSICA & lt; & lt; caixa de seleção & quot; $ stopmusic & quot; falso verdadeiro autocheck & gt; & gt;
\
& lt; & lt; if $ stopmusic == true & gt; & gt; \
	& lt; & lt; áudio & quot; musicadefundo & quot; parar & gt; & gt; \
& lt; & lt; endif & gt; & gt; \
\
& lt; & lt; if $ stopmusic == false & gt; & gt; \
	& lt; & lt; áudio & quot; musicadefundo & quot; reproduzir & gt; & gt; \
& lt; & lt; endif & gt; & gt; \

\
TROCAR NICK & lt; & lt; caixa de seleção & quot; $ changenick & quot; falso verdadeiro autocheck & gt; & gt;
/ * & lt; & lt; if $ nomeplayer == $ nomeplayer & gt; & gt;
	& lt; & lt; & quot; $ changenick & quot; & gt; & gt;
& lt; & lt; endif & gt; & gt; * / \
\
\
& lt; & lt; if $ changenick == true & gt; & gt; \
	& lt; & lt; caixa de texto & quot; $ nomeplayer & quot; $ nomeplayer & gt; & gt; \
& lt; & lt; endif & gt; & gt;


[[SALVAR | CONFIGURAÇÃO]]
</tw-passagedata> <tw-passagedata pid = "6" name = "StoryInit" tags = "" position = "400,100" size = "100,100"> & lt; & lt; cacheaudio & quot; musicadefundo & quot; & quot; Fundo.mp3 & quot; & gt; & gt;
& lt; & lt; cacheaudio & quot; musicadeentrada & quot; & quot; EA.mp3 & quot; & gt; & gt; </tw-passagedata> <tw-passagedata pid = "7" name = "INÍCIO" tags = "" position = "750,200" size = "100,100"> & lt; & lt; áudio & quot; musicadefundo & quot; reprodução em loop & gt; & gt;
INSIRA SEU NOME
& lt; & lt; caixa de texto & quot; $ nomeplayer & quot; & quot; Digite seu nick & quot; & gt; & gt;

[[IR | Tela principal]]
</tw-passagedata> <tw-passagedata pid = "8" name = "INSTRUÇÕES" tags = "" position = "350,400" size = "100,100"> [img [Home.png] [Tela principal]] [img [ Config.png] [CONFIGURAÇÃO]]

FT-RIDDLE É UM JOGO BASEADO NA RESOLUÇÃO DE ENIGMAS, ONDE DOIS JOGADORES SE ENFRENTAM PARA DISPUTAR QUEM É A MENTE MAIS BRILHANTE. CADA RODADA É COMPOSTA POR 3 ENIGMAS, E AQUELE QUE TERMINAR TODOS EM MENOS TEMPO, LEVA O PRÊMIO.

</tw-passagedata> <tw-passagedata pid = "9" name = "ENTRADA" tags = "" position = "750,0" size = "100,100"> & lt; & lt; audio & quot; musicadeentrada & quot; play goto & quot; INÍCIO & quot; & gt; & gt;

& lt; H1 & gt; FT-RIDDLE & lt; / H1 & gt; </tw-passagedata> <tw-passagedata pid = "10" name = "D1" tags = "" position = "350,725" size = "100,100"> DESAFIO 1
[[AJUDA | AD1]]

Quando as táticas de desejavam eram sentidas por meio de mensageiros a cavalo, os riscos de que os mesmos interceptados, e o conteúdo das cartas exposto, eram grandes. Com isso, os generais inimigos criptografaram suas mensagens com o modo & quot; Quadrado perfeito ”de Júlio César. Nossos batedores conseguiram roubar a carta com o próximo movimento do inimigo, decifre e descubra qual é a próxima jogada deles, para que possamos nos preparar.

DQAPLEUSAOSETSRLSRPIOUOEO 

& lt; & lt; caixa de texto & quot; $ resultadoD1 & quot; & quot; Digite a resposta em letras maiusculas & quot; & gt; & gt;

  & lt; & lt; botão & quot; RESPONDER & quot; & gt; & gt;
/
		  & lt; & lt; if $ resultadoD1 == & quot; DESLOQUE SUAS TROPAS PELO RIO & quot; & gt; & gt; /
/
			   & lt; & lt; goto & quot; WIN & quot; & gt; & gt; /
/
		  & lt; & lt; elseif $ resultadoD1! == & quot; DESLOQUE SUAS TROPAS PELO RIO & quot; & gt; & gt; /
/
			& lt; & lt; goto & quot; D1 & quot; & gt; & gt; /
/
		  & lt; & lt; / if & gt; & gt; /
  & lt; & lt; / botão & gt; & gt;
[[VOLTAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "11" name = "D2" tags = "" position = "350.825" size = "100,100"> DESAFIO 2
[[AJUDA | AD2]]

O ano é 1942, como tropas alemãs fazem frente oriental especificam uma nova ordem, atacar e dominar uma cidade a todo custo. A inteligência aliada conseguiu interceptar essa mensagem contendo o nome da cidade no alvo dos nazistas, decifre ela antes que seja tarde demais !!

... - .- .- .. .. -. -_. .-. .- - .. -_-

& lt; & lt; caixa de texto & quot; $ resultadoD2 & quot; & quot; Digite a resposta em letras maiusculas & quot; & gt; & gt;

  & lt; & lt; botão & quot; RESPONDER & quot; & gt; & gt;
/
		  & lt; & lt; if $ resultadoD2 == & quot; STALINGRADO & quot; & gt; & gt; /
/
			   & lt; & lt; goto & quot; WIN & quot; & gt; & gt; /
/
		  & lt; & lt; elseif $ resultadoD2! == & quot; STALINGRADO & quot; & gt; & gt; /
/
			& lt; & lt; goto & quot; D2 & quot; & gt; & gt; /
/
		  & lt; & lt; / if & gt; & gt; /
  & lt; & lt; / botão & gt; & gt;
[[VOLTAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "12" name = "D3" tags = "" position = "350,925" size = "100,100"> DESAFIO 3
[[AJUDA | AD3]]

Um avô está ensinando ao seu neto a arte da criptografia, e para isso ele criou um código com o modo mais simples de criptografar da história, conhecida como & quot; Cifra de César ”. Descubra e desvende a mensagem que o neto revelada.

P EFOUF EP MFBP F CSBODP DPNP P EFOUF EF MFBP 


& lt; & lt; caixa de texto & quot; $ resultadoD3 & quot; & quot; Digite a resposta em letras maiusculas & quot; & gt; & gt;

  & lt; & lt; botão & quot; RESPONDER & quot; & gt; & gt;
/
		  & lt; & lt; if $ resultadoD3 == & quot; O DENTE DO LEAO E BRANCO COMO O DENTE DE LEAO & quot; & gt; & gt; /
/
			   & lt; & lt; goto & quot; WIN & quot; & gt; & gt; /
/
		  & lt; & lt; elseif $ resultadoD3! == & quot; O DENTE DO LEAO E BRANCO COMO O DENTE DE LEAO & quot; & gt; & gt; /
/
			& lt; & lt; goto & quot; D3 & quot; & gt; & gt; /
/
		  & lt; & lt; / if & gt; & gt; /
  & lt; & lt; / botão & gt; & gt;
[[VOLTAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "13" name = "D4" tags = "" position = "350,1025" size = "100,100"> DESAFIO 4
[[AJUDA | AD4]]

Em uma aula de história no segundo ano de ensino médio, o professor propôs aos alunos um desafio, o mesmo consistia em decifrar um anagrama, e quem fizesse isso primeiro iria ganhar um ponto na média final. Ajude os alunos a completar esse desafio, uma frase passada pelo professor era a seguinte:

QLUA EA ORC OD AVLCAO BORCNA ED AOILNSP 

& lt; & lt; caixa de texto & quot; $ resultadoD4 & quot; & quot; Digite a resposta em letras maiusculas & quot; & gt; & gt;

  & lt; & lt; botão & quot; RESPONDER & quot; & gt; & gt;
/
		  & lt; & lt; if $ resultadoD4 == & quot; QUAL EA COR DO CAVALO BRANCO DE NAPOLIS & quot; & gt; & gt; /
/
			   & lt; & lt; goto & quot; WIN & quot; & gt; & gt; /
/
		  & lt; & lt; elseif $ resultadoD4! == & quot; QUAL EA COR DO CAVALO BRANCO DE NAPOLIS & quot; & gt; & gt; /
/
			& lt; & lt; goto & quot; D4 & quot; & gt; & gt; /
/
		  & lt; & lt; / if & gt; & gt; /
  & lt; & lt; / botão & gt; & gt;

[[VOLTAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "14" name = "WIN" tags = "" position = "750,1000" size = "100,100"> PARABÉNS
VOCÊ CONCLUIU COM ÊXITO OS DESAFIOS PROPOSTOS NESSE JOGO, SEGUE ABAIXO SEUS TEMPOS:

[img [T.png]] [img [F.png]] </tw-passagedata> <tw-passagedata pid = "15" name = "D5" tags = "" position = "350,1125" size = " 100,100 "> DESAFIO 5
[[AJUDA | AD5]]

Um hacker está invadindo uma rede de computadores da inteligência, ele colocou um sniffer para capturar os pacotes que transitam na topologia da rede. Uma das mensagens que ele capturou, durante a conversa de dois computadores do alto escalão, revelando a localidade da próxima base militar em solo estrangeiro. Qual é a localidade da nova base?

01001000 01000001 01010100 01010100 01001111 01001110 01010011 01010010 01001001 00100000 01001100 01000001 01001110 01001011 01000001 

Para o programa de decodificação aceitar sua resposta, escreva conforme o exemplo: 
CIDADE, PAÍS 

& lt; & lt; caixa de texto & quot; $ resultadoD5 & quot; & quot; Digite a resposta em letras maiusculas & quot; & gt; & gt;

  & lt; & lt; botão & quot; RESPONDER & quot; & gt; & gt;
/
		  & lt; & lt; if $ resultadoD5 == & quot; HATTON, SRI LANKA & quot; & gt; & gt; /
/
			   & lt; & lt; goto & quot; WIN & quot; & gt; & gt; /
/
		  & lt; & lt; elseif $ resultadoD5! == & quot; HATTON, SRI LANKA & quot; & gt; & gt; /
/
			& lt; & lt; goto & quot; D5 & quot; & gt; & gt; /
/
		  & lt; & lt; / if & gt; & gt; /
  & lt; & lt; / botão & gt; & gt;

[[VOLTAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "16" name = "D6" tags = "" position = "350,1225" size = "100,100"> DESAFIO 6
[[AJUDA | AD6]]

O professor Felipe de geografia está na Europa com seu fuca e pretende dar umas bandas por lá, porém ele não sabe para onde ir. Para ajudar na sua indecisão, o professor foi até o Google Earth e pediu uma coordenada geográfica aleatória para o site, o mesmo respondeu com a mostrada abaixo. Qual vai ser o lugar que o fuca vai cortar giro?

48 ° 51 & # 39; 41 & quot; N, 2 ° 20 & # 39; 6 & quot; E

& lt; & lt; caixa de texto & quot; $ resultadoD6 & quot; & quot; Digite a resposta em letras maiusculas & quot; & gt; & gt;

  & lt; & lt; botão & quot; RESPONDER & quot; & gt; & gt;
/
          & lt; & lt; if $ resultadoD6 == & quot; MUSEU DO LOUVRE & quot; & gt; & gt; /
/
               & lt; & lt; goto & quot; WIN & quot; & gt; & gt; /
/
          & lt; & lt; elseif $ resultadoD6! == & quot; MUSEU DO LOUVRE & quot; & gt; & gt; /
/
            & lt; & lt; goto & quot; D6 & quot; & gt; & gt; /
/
          & lt; & lt; / if & gt; & gt; /
  & lt; & lt; / botão & gt; & gt;

[[VOLTAR | Sala Multiplayer]] </tw-passagedata> <tw-passagedata pid = "17" name = "AD1" tags = "" position = "150,725" size = "100,100"> AJUDA DESAFIO 1
[[VOLTAR | D1]]

Júlio César foi uma das primeiras pessoas a escrever em código. Ele inventou uma cifra de César, em que cada letra era substituída por outra letra com um número fixo de posições no alfabeto. A seguinte cifra não é a de César, mas o que os criptógrafos chamam de & quot; cifra de transposição colunar & quot; ou & quot; Caixa de César & quot ;, apesar de ser incerto se o código foi de fato usado por César.

COMO DECODIFICAR:

GTYORJOTEDUIABGT

1) Conte o número de caracteres no código. Aqui temos 16: GTYORJOTEOUIABGT

2) Defina em linhas linhas você pode dividir como letras igualmente (encontre a raiz quadrada do número do passo 1. Se a raiz quadrada não for um número inteiro, arredonde). Nós podemos por 16 em 4 linhas de 4 (ou seja, a raiz quadrada de 16 que é 4). Se tivéssemos 25 letras poderíamos fornecer-las em 5 linhas de 5 (a raiz quadrada de 25 é 5) e assim por diante. Em casos em que o número não é divisível de forma exata, use os números das linhas para o próximo número & quot; encaixável & quot; (raiz perfeita). Os números & quot; encaixáveis ​​& quot; são 9, 16, 25, 36, 49, etc. Se o código possuir 22 letras (a raiz quadrada de 22 é 4.69), o próximo número é 25, que significaria ter 5 linhas (4.69 arredonda para 5).

3) Escreva como letras preenchendo as linhas. Com o exemplo dado, seria escrito da seguinte forma: GTYORJOTEOUIABGT.

GTYO
RJOT
EOUI
ABGT

4) Comece da letra da esquerda superior e leia descendo, então com o topo da próxima coluna e leia descendo novamente e assim por diante. Esse exemplo tem a mensagem: & quot; ÓTIMO TRABALHO, VOCÊ CONSEGUIU & quot; (BOM TRABALHO VOCÊ CONSEGUIU). </tw-passagedata> <tw-passagedata pid = "18" name = "AD2" tags = "" position = "150.825" size = "100,100"> AJUDA DESAFIO 2
[[VOLTAR | D2]]

Desenvolvido em 1835, pelo pintor e inventor Samuel Finley Breese Morse, o Código Morse é um sistema binário de representação à distância de números, letras e sinais gráficos, utilizando-se de filhos curtos e longos, além de pontos e traços para transmitir mensagens.

Esse sistema é composto por todas as letras do alfabeto e todos os números. Os caracteres são representados por uma combinação específica de pontos e traços, conforme exposto na tabela abaixo. Para formar as palavras, basta realizar uma combinação correta de símbolos.

TABELA: 

[img [Morse.png]]
</tw-passagedata> <tw-passagedata pid = "19" name = "AD3" tags = "" position = "150,925" size = "100,100"> AJUDA DESAFIO 3
[[VOLTAR | D3]]

Em criptografia, uma Cifra de César, também conhecida como cifra de troca, código de César ou troca de César, é uma das mais simples e técnicas de criptografia. É um tipo de cifra de substituição na qual cada letra do texto é substituída por outra, que se apresenta no alfabeto abaixo dela um número fixo de vezes. Por exemplo, com uma troca de três posições, A seria substituído por D, B se tornaria E, e assim por diante. O nome do método é em homenagem para Júlio César, que o comunicou para se comunicar com os seus generais.

EXEMPLO

Normal: a ligeira raposa marrom saltou sobre o cachorro cansado
Cifrado: D OLJHLUD UDSRVD PDUURP VDOWRX VREUH R FDFKRUUR FDQVDGR </tw-passagedata> <tw-passagedata pid = "20" name = "AD4" tags = "" position = "150,1025" size = "100,100"> AJUDA DESAFIO 4
[[VOLTAR | D4]]

Um anagrama é uma espécie de jogo de palavras criado com uma reorganização das letras de uma palavra ou expressão para produzir outras palavras ou expressões, utilizando todas as letras originais exatamente uma vez. Um exemplo é o prenome da escritora brasileira Nélida Piñón, anagrama do prenome de seu avô materno Daniel Cuiñas.

EXEMPLO:

PALAVRA: PATO

ANAGRAMAS POSSÍVEIS: 
PATO PAOT POTA POAT PTOA PTAO
APTO APOT ATPO ATOP AOTP AOPT
TAPO TAOP TOPA TOAP TPAO TPOA
OAPT OATP OPTA OPAT OTPA OTAP </tw-passagedata> <tw-passagedata pid = "21" name = "AD5" tags = "" position = "150,1125" size = "100,100"> AJUDA DESAFIO 5
[[VOLTAR | D5]]

Em rede de computadores, um analisador de pacotes (também conhecido como sniffer de pacotes, em português, farejador de pacotes) é um programa de computador ou hardware que pode interceptar e registrar que passa sobre uma rede digital ou parte de uma rede.

TABELA: 

[img [Binario.png]]
</tw-passagedata> <tw-passagedata pid = "22" name = "AD6" tags = "" position = "150,1225" size = "100,100"> AJUDA DESAFIO 6
[[VOLTAR | D6]]

Coordenadas Geográficas são linhas imaginárias que cortam o planeta Terra nos sentidos horizontais e verticais, servindo para a localização de qualquer ponto na superfície terrestre.

A distância das coordenadas geográficas são medidas em graus, minutos e segundos. Um grau corresponde a 60 minutos, e um minuto corresponde a 60 segundos.

Dessa maneira, temos dois tipos de coordenadas geográficas:

Latitude: São as linhas que tracejam a Terra no sentido horizontal, também marcados como paralelas. O máximo círculo da esfera terrestre, na horizontal, é chamado de Equador. O Equador corresponde à latitude 0 °, dividindo o planeta em hemisférios Norte e Sul. Como as latitudes variam de 0 a 90 °, tanto ao Norte quanto ao Sul. A latitude, além de servir para localização geográfica, é uma variável importante para estudar os tipos de clima da Terra, pois um número de raios solares no planeta é maior nos lugares com latitudes menores, isto é, mais próximo à linha do Equador.

Longitude: São as coordenadas geográficas que cortam a Terra no sentido vertical, também compatível como Meridianos. A distância das longitudes varia de 0 ° a 180 °, nos sentidos Leste e Oeste. Como padronização internacional, adotou-se o Meridiano de Greenwich como ponto de partida, a longitude de 0 °. Assim, tal meridiano divide a Terra em Ocidental (a Oeste) e Oriental (a leste). Foi a partir das longitudes que se criaram os fusos horários. Todos os meridianos se encontram e se cruzam nos polos Norte e Sul.

Exemplo:

As coordenadas geográficas do Pão de Açucar, no Rio de Janeiro, são as seguintes:

Latitude: -9,7327 Longitude: -37,4352 </tw-passagedata> </tw-storydata>
	<script id = "script-sugarcube" type = "text / javascript">
	/ *! SugarCube JS * /
	"; i + = a?" Abortando. ":" Você pode continuar, mas algumas partes podem não funcionar corretamente. ", Null == t && null == r || (i + =" \ n \ nError ", null! = T && (i + =" [ "+ t +"] "), i + = null! = r?": "+ r.replace (errorPrologRegExp," ") +". ":": erro desconhecido. ")," objeto "=== (vazio 0 === n? "undefined": _ typeof (n)) && null! == n && n.stack && (i + = "\ n \ nStack Trace: \ n" + n.stack), window.alert (i)} função t ( t, r, n) {e (nulo, t, r, n)} função r (t, r, n) {e ("fatal", t, r, n)} função de retorno (e) {janela.onerror = function (n, a, i, o, s) {"complete" === document.readyState? t (null, n, s) :( r (null, n, s), window.onerror = e, " função "== typeof window.onerror && window.onerror.apply (this, arguments))}} (window.onerror), Object.freeze (Object.isFinite (n) || n> = e? n = e-1: n <0 && (n = e + n) <0 && (n = e-1), _ random (r, n)} função _getCodePointStartAndEnd (e, t ) {var r = e.charCodeAt (t); if (Number.isNaN (r)) return {char: "", start: -1, end: -1}; if (r <55296 || r> 57343) return {char: e.charAt (t), start: t, end: t}; if (r> = 55296 && r <= 56319) {var n = t + 1; if (n> = e.length) lançar novo erro ("substituto alto sem substituto baixo posterior"); var a = e.charCodeAt (n); if (a <56320 || a> 57343) lançar novo erro ("substituto alto sem substituto substituto baixo"); retornar {char: e.charAt (t) + e.charAt (n), início: t, fim: n}} if (0 === t) lançar novo Erro ("substituto baixo sem substituto alto líder"); var i = t- 1, o = e.charCodeAt (i); if (o <55296 || o> 56319) lançar novo Erro ("substituto baixo sem substituto alto líder"); retornar {char: e.charAt (i) + e.charAt (t), início: i, fim:t}} var _nativeMathRandom = Math.random; Object.defineProperty (Array, "random", {configurável:! 0, gravável:! 0, valor: função (e) {if ("objeto"! == (void 0 = == e? "undefined": _ typeof (e)) || null === e ||! Object.prototype.hasOwnProperty.call (e, "length")) throw new TypeError ("Array.random array parâmetro deve ser um array ou objeto array-lke "); var t = e.length >>> 0; if (0! == t) {return e [0 === arguments.length? _random (0, t-1): _randomIndex (t, Array.prototype.slice.call (argumentos, 1))]}}}), Object.defineProperty (Array.prototype, "concatUnique", {configurável:! 0, gravável:! 0, valor: função ( ) {if (null == this) throw new TypeError ("Array.prototype.concatUnique chamado em nulo ou indefinido"); var e = Array.from (this); if (0 === argumentos.length) return e; var t = Array.prototype.reduce.call (argumentos, função (e, t) {retornar e.concat (t)}, []), r = t.length; if (0 === r) retornar e; para (var n = Array.prototype.indexOf, a = Array.prototype.push, i = 0; i <r; ++ i) {var o = t [i]; - 1 === n.call (e, o) && a.call (e, o)} return e}}), Object.defineProperty (Array .prototype, "count", {configurável:! 0, gravável:! 0, value: function () {if (null == this) throw new TypeError ("Array.prototype.count chamado em nulo ou indefinido"); para (var e = Array.prototype.indexOf, t = argumentos [0], r = Número (argumentos [1]) || 0, n = 0; -1! == (r = e.call (this, t, r));) ++ n, ++ r; return n}}), Object.defineProperty (Array.prototype, "delete", {configurável:! 0, gravável:! 0, valor: função () {if ( null == this) lançar new TypeError ("Array.prototype.delete chamado em nulo ou indefinido"); if (0 === arguments.length) return []; var e = this.length >>> 0; if ( 0 === e) return []; for (var t = Array.prototype.concat.apply ([], argumentos), r = t.length, n = [], a = 0;a <e; ++ a) para (var i = this [a], o = 0; o <r; ++ o) {var s = t [o]; if (i === s || i! == i && s! == s) {n.push (a); quebra}} para (var u = [], l = 0, c = n.length; l <c; ++ l) u [l] = this [n [l]]; para (var d = Array.prototype.splice, f = n.length-1; f> = 0; - f) d.call (this, n [f], 1); return u}}), Object.defineProperty (Array.prototype, "deleteAt", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError ("Array.prototype .deleteAt chamado em caso de nulo ou indefinido "); if (0 === argumentos.comprimento) retornar []; var e = este.comprimento >>> 0; if (0 === e) retornar []; for (var t = Array.prototype.splice, r = []. concat (_toConsumableArray (new Set (Array.prototype.concat.apply ([], argumentos) .map (função (t) {return t <0? Math.max ( 0, e + t): t})). Valores ())), n = []. Concat (_toConsumableArray (r)). Sort (função (e, t) {return te}), a = [], i = 0, o = r.length; i <o; ++ i) a [i] = this [r [i]]; para (var s = 0, u = n.length; s <u;++ s) t.call (this, n [s], 1); retornar a}}), Object.defineProperty (Array.prototype, "deleteWith", {configurável:! 0, gravável:! 0, valor: função (e, t) {if (null == this) lançar new TypeError ("Array.prototype.deleteWith chamado em nulo ou indefinido"); if ("função"! = typeof e) lançar novo Error ("Array.prototype. deleteWith predicate parâmetro deve ser uma função "); var r = this.length >>> 0; if (0 === r) return []; for (var n = Array.prototype.splice, a = [], i = [], o = 0; o <r; ++ o) e.call (t, este [o], o, este) && (i.push (este [o]), a.push (o)) ; para (var s = a.length-1; s> = 0; - s) n.call (this, a [s], 1); return i}}), Object.defineProperty (Array.prototype, " primeiro ", {configurável:! 0, gravável:! 0, valor: função () {if (null == this) lance new TypeError (" Array.prototype.first chamado em nulo ou indefinido "); if (0! = this.length >>> 0) retornar este [0]}}),Object.defineProperty (Array.prototype, "includesAll", {configurável:! 0, gravável:! 0, value: function () {if (null == this) throw new TypeError ("Array.prototype.includesAll chamado em null ou undefined "); if (1 === arguments.length) return Array.isArray (arguments [0])? Array.prototype.includesAll.apply (this, arguments [0]): Array.prototype.includes.apply (this , argumentos); para (var e = 0, t = argumentos.comprimento; e <t; ++ e) if (! Array.prototype.some.call (this, function (e) {return e === this. val || e! == e && this.val! == this.val}, {val: argumentos [e]})) return! 1; return! 0}}), Object.defineProperty (Array.prototype, "includesAny" , {configurável:! 0, gravável:! 0, valor: função () {if (null == this) throw new TypeError ("Array.prototype.includesAny chamado em nulo ou indefinido"); if (1 === argumentos .length) return Array.isArray (argumentos [0])? Array.prototype.includesAny.aplicar (isto, argumentos [0]): Array.prototype.includes.apply (isto, argumentos); for (var e = 0, t = argumentos.comprimento; e <t; ++ e) if (Matriz.protótipo. some.call (this, function (e) {return e === this.val || e! == e && this.val! == this.val}, {val: arguments [e]})) return! 0; return! 1}}), Object.defineProperty (Array.prototype, "último", {configurável:! 0, gravável:! 0, valor: função () {if (null == this) lançar novo TypeError ("Array. prototype.last chamado em nulo ou indefinido "); var e = this.length >>> 0; if (0! == e) retornar este [e-1]}}), Object.defineProperty (Array.prototype," pluck ", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError (" Array.prototype.pluck chamado em nulo ou indefinido "); var e = this. comprimento >>> 0; if (0! == e) {var t = 0 === arguments.length? _random (0, e-1): _ randomIndex (e, []. concat (Array.prototype.slice.chamar (argumentos))); retornar Array.prototype.splice.call (this, t, 1) [0]}}}), Object.defineProperty (Array.prototype, "pluckMany", {configurável:! 0, gravável: ! 0, value: function (e) {if (null == this) throw new TypeError ("Array.prototype.pluckMany chamado em nulo ou indefinido"); var t = this.length >>> 0; if (0 = == t) return []; var r = Math.trunc (e); if (! Number.isInteger (r)) lançar novo Error ("Array.prototype.pluckMany parâmetro desejado deve ser um inteiro"); if (r <1) return []; r> t && (r = t); var n = Array.prototype.splice, a = [], i = t-1; faça {a.push (n.call (this, _random ( 0, i -), 1) [0])} while (a.length <r); retornar a}}), Object.defineProperty (Array.prototype, "pushUnique", {configurável:! 0, gravável :! 0, valor: function () {if (null == this) throw new TypeError ("Array.prototype.pushUnique chamado em nulo ou indefinido"); var e = arguments.length;if (0 === e) retorna this.length >>> 0; for (var t = Array.prototype.indexOf, r = Array.prototype.push, n = 0; n <e; ++ n) {var a = argumentos [n]; - 1 === t.call (this, a) && r.call (this, a)} return this.length >>> 0}}), Object.defineProperty (Array.prototype, " random ", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError (" Array.prototype.random chamado em nulo ou indefinido "); var e = this. length >>> 0; if (0! == e) {return this [0 === arguments.length? _random (0, e-1): _ randomIndex (e, []. concat (Array.prototype.slice. chamar (argumentos)))]}}}), Object.defineProperty (Array.prototype, "randomMany", {configurável:! 0, gravável:! 0, valor: função (e) {if (null == this) jogar new TypeError ("Array.prototype.randomMany chamado em nulo ou indefinido"); var t = this.length >>> 0; if (0 === t) return []; var r = Math.trunc (e); E se(!Number.isInteger (r)) throw new Error ("Array.prototype.randomMany parâmetro desejado deve ser um inteiro"); if (r <1) return []; r> t && (r = t); var n = novo Mapa , a = [], i = t-1; faça {var o = void 0; faça {o = _random (0, i)} enquanto (n.has (o)); n.set (o,! 0) , a.push (this [o])} while (a.length <r); retornar a}}), Object.defineProperty (Array.prototype, "shuffle", {configurável:! 0, gravável:! 0, valor : function () {if (null == this) throw new TypeError ("Array.prototype.shuffle chamado em nulo ou indefinido"); var e = this.length >>> 0; if (0 === e) return isto; para (var t = e-1; t> 0; - t) {var r = Math.floor (_nativeMathRandom () * (t + 1)); if (t! == r) {var n = this [t]; this [t] = this [r], this [r] = n}} return this}}), Object.defineProperty (Array.prototype, "unshiftUnique", {configurável:! 0, gravável :! 0, valor: function () {if (null == this) throw new TypeError ("Array.prototype.unshiftUnique chamado em nulo ou indefinido "); var e = argumentos.length; if (0 === e) retornar this.length >>> 0; para (var t = Array.prototype.indexOf, r = Array.prototype. unshift, n = 0; n <e; ++ n) {var a = argumentos [n]; - 1 === t.call (this, a) && r.call (this, a)} return this.length> >> 0}}), Object.defineProperty (Function.prototype, "partial", {configurável:! 0, gravável:! 0, value: function () {if (null == this) throw new TypeError ("Function. prototype.partial chamado em nulo ou indefinido "); var e = Array.prototype.slice, t = this, r = e.call (argumentos, 0); função de retorno () {for (var n = [], a = 0, i = 0; i <r.length; ++ i) n.push (r [i] === indefinido? Argumentos [a ++]: r [i]); retornar t.apply (this, n.concat (e.call (argumentos, a)))}}}), Object.defineProperty (Math, "clamp", {configurável:! 0, gravável:! 0, valor: função (e, t, r) {var n = Número (e); retornar Número.isNaN (n)? NaN: n.clamp (t,r)}}), Object.defineProperty (Math, "facilityInOut", {configurável:! 0, gravável:! 0, valor: function (e) {return 1- (Math.cos (Number (e) * Math.PI ) +1) / 2}}), Object.defineProperty (Number.prototype, "clamp", {configurável:! 0, gravável:! 0, value: function () {if (null == this) throw new TypeError ( "Number.prototype.clamp chamado em nulo ou indefinido"); if (2! == argumentos.length) lança novo Error ("Number.prototype.clamp chamado com um número incorreto de parâmetros"); var e = Número (argumentos [0]), t = Número (argumentos [1]); se (e> t) {var r = [t, e]; e = r [0], t = r [1]} retornar Math.min ( Math.max (this, e), t)}}), RegExp.escape || function () {var e = / [\\ ^ $ * + ?. () | [\] {}] / g, t = new RegExp (e.source); Object.defineProperty (RegExp, "escape", {configurável:! 0, gravável:! 0, valor: função (r) {var n = String (r); retornar n && t.test ( n)? n.replace (e, "\\ $ &"): n}})} (),function () {var e = / {(\ d +) (?:, ([+ -]? \ d +))?} / g, t = new RegExp (e.source); Object.defineProperty (String, "formato ", {configurável:! 0, gravável:! 0, valor: função (r) {função n (e, t, r) {se (! t) retornar e; var n = Math.abs (t) -e. comprimento; if (n <1) retornar e; var a = String (r) .repetir (n); retornar t <0? e + a: a + e} if (argumentos.comprimento <2) retornar 0 === argumentos.length? "": r; var a = 2 === argumentos.length && Array.isArray (argumentos [1])? []. concat (_toConsumableArray (argumentos [1])): Array.prototype.slice.call ( argumentos, 1); retornar 0 === a.length? r: t.test (r)? (e.lastIndex = 0, r.replace (e, função (e, t, r) {var i = a [ t]; if (null == i) return ""; for (; "function" == typeof i;) i = i (); switch (void 0 === i? "undefined": _ typeof (i)) {case "string": break; case "object": i = JSON.stringify (i); break; default: i = String (i)} return n (i, r? Number.parseInt (r, 10): 0 , "")})): r}})} (), Object.defineProperty (String.prototype," contém ", {configurável:! 0, gravável:! 0, valor: função () {if (null == this) lançar new TypeError ("String.prototype.contains chamado em nulo ou indefinido"); return-1! == String.prototype.indexOf.apply (this, argumentos)}}), Object.defineProperty (String.prototype, "contagem ", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError (" String.prototype.count chamado em nulo ou indefinido "); var e = String (argumentos [0] || ""); if ("" === e) retorna 0; para (var t = String.prototype.indexOf, r = e.length, n = Número (argumentos [1]) || 0 , a = 0; -1! == (n = t.call (this, e, n));) ++ a, n + = r; retornar a}}), Object.defineProperty (String.prototype, "primeiro ", {configurável:! 0, gravável:! 0, valor: função () {if (null == this) lance new TypeError (" String.prototype.chamado primeiro em nulo ou indefinido "); return _getCodePointStartAndEnd (String (this), 0) .char}}), Object.defineProperty (String.prototype," last ", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError ("String.prototype.last chamado em nulo ou indefinido"); var e = String (this); return _getCodePointStartAndEnd (e, e.length-1) .char }}), Object.defineProperty (String.prototype, "splice", {configurável:! 0, gravável:! 0, valor: função (e, t, r) {if (null == this) throw new TypeError (" String.prototype.splice chamado em nulo ou indefinido "); var n = this.length >>> 0; if (0 === n) return" "; var a = Number (e); Number.isSafeInteger (a) ? a <0 && (a + = n) <0 && (a = 0): a = 0, a> n && (a = n); var i = Número (t); (! Number.isSafeInteger (i) || i < 0) && (i = 0); var o = this.slice (0, a); return void 0! == r &&(o + = r), a + i <n && (o + = this.slice (a + i)), o}}), Object.defineProperty (String.prototype, "splitOrEmpty", {configurável:! 0, gravável :! 0, valor: function () {if (null == this) throw new TypeError ("String.prototype.splitOrEmpty chamado em nulo ou indefinido"); return "" === String (this)? []: String.prototype .split.apply (this, arguments)}}), Object.defineProperty (String.prototype, "toLocaleUpperFirst", {configurável:! 0, gravável:! 0, value: function () {if (null == this) throw new TypeError ("String.prototype.toLocaleUpperFirst chamado em nulo ou indefinido"); var e = String (this), t = _getCodePointStartAndEnd (e, 0), r = t.char, n = t.end; return-1 = == n? "": r.toLocaleUpperCase () + e.slice (n + 1)}}), Object.defineProperty (String.prototype, "toUpperFirst", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError ("String.prototype.toUpperFirst chamado em nulo ou indefinido "); var e = String (this), t = _getCodePointStartAndEnd (e, 0), r = t.char, n = t.end; return-1 === n? "": r.toUpperCase () + e.slice (n + 1)}}), Object.defineProperty (Date.prototype, "toJSON", {configurável:! 0, gravável:! 0, value: function () { return ["(revive: date)", this.toISOString ()]}}), Object.defineProperty (Function.prototype, "toJSON", {configurável:! 0, gravável:! 0, value: function () {return ["(revive: eval)", "(" + this.toString () + ")"]}}), Object.defineProperty (Map.prototype, "toJSON", {configurável:! 0, gravável:! 0, valor: function () {return ["(revive: map)", []. concat (_toConsumableArray (this))]}}), Object.defineProperty (RegExp.prototype, "toJSON", {configurável:! 0, gravável :! 0, valor: função () {return ["(reviver: eval)", isto.toString ()]}}), Object.defineProperty (Set.prototype, "toJSON", {configurável:! 0, gravável:! 0, value: function () {return ["(revive: set)", []. concat (_toConsumableArray (this))]}}), Object.defineProperty (JSON, "reviveWrapper", {configurável:! 0, gravável:! 0, valor: função (e, t) {if ("string"! = typeof e) lançar novo TypeError ("parâmetro de código JSON.reviveWrapper deve ser uma string"); return ["(revive: eval)", [e, t]]}}), Object.defineProperty (JSON, "_ real_stringify", { valor: JSON.stringify}), Object.defineProperty (JSON, "stringify", {configurável:! 0, gravável:! 0, valor: função (e, t, r) {retornar JSON._real_stringify (e, função (e , r) {var n = r; if ("função" == typeof t) try {n = t (e, n)} catch (e) {} return void 0 === n && (n = ["(reviver : eval) "," undefined "]), n}, r)}}), Object.defineProperty (JSON,"_real_parse ", {value: JSON.parse}), Object.defineProperty (JSON," parse ", {configurável:! 0, gravável:! 0, value: function value (text, reviver) {return JSON._real_parse (text, function (key, val) {var value = val; if (Array.isArray (value) && 2 === value.length) switch (value [0]) {case "(revive: set)": value = new Set ( valor [1]); break; case "(revive: map)": value = new Map (value [1]); break; case "(revive: date)": value = new Date (value [1]); break; case "(revive: eval)": try {if (Array.isArray (value [1])) {var $ ReviveData $ = value [1] [1]; value = eval (value [1] [0] )} else value = eval (value [1])} catch (e) {}} else if ("string" == typeof value && "@@ revive @@" === value.slice (0,10)) try {value = eval (value.slice (10))} catch (e) {} if ("function" == typeof reviver) try {value = reviver (key, value)} catch (e) {} return value}) }}),Objeto.defineProperty (Array.prototype, "contém", {configurável:! 0, gravável:! 0, valor: função () {if (null == this) lança novo TypeError ("Array.prototype.contains chamado em nulo ou indefinido" ); return Array.prototype.includes.apply (this, arguments)}}), Object.defineProperty (Array.prototype, "containsAll", {configurável:! 0, gravável:! 0, value: function () {if ( null == this) lançar new TypeError ("Array.prototype.containsAll chamado em nulo ou indefinido"); retornar Array.prototype.includesAll.apply (this, argumentos)}}), Object.defineProperty (Array.prototype, "containsAny ", {configurável:! 0, gravável:! 0, valor: function () {if (null == this) throw new TypeError (" Array.prototype.containsAny chamado em nulo ou indefinido "); retornar Array.prototype.includesAny .apply (this, arguments)}}), Object.defineProperty (Array.prototype, "flatten",{configurável:! 0, gravável:! 0, valor: função () {if (null == this) lançar novo TypeError ("Array.prototype.flatten chamado em nulo ou indefinido"); retornar Array.prototype.flat.call (this, 1/0)}}), Object.defineProperty (String.prototype, "readBracketedList", {configurável:! 0, gravável:! 0, valor: função () {if (null == this) lançar novo TypeError ("String.prototype.readBracketedList chamado em nulo ou indefinido"); for (var e = new RegExp ("(?: \\ [\\ [((?: \\ s | \\ S) *?) \\ ] \\]) | ([^ \ "'\\ s] \\ S *)", "gm"), t = [], r = void 0; nulo! == (r = e.exec (este ));) r [1]? t.push (r [1]): r [2] && t.push (r [2]); retornar t}})} (); var Navegador = função () {var e = navigator.userAgent.toLowerCase (), t = e.includes ("windows phone"), r = Object.freeze ({Android:! t && e.includes ("android"), BlackBerry: / blackberry | bb10 / .test (e), iOS:! t && / ip (?:afiar | ad | od) /. test (e), Opera:! t && ("object" === _ typeof (window.operamini) || e.includes ("opera mini")), Windows: t || / iemobile | wpdesktop / .test (e), any: function () {return r.Android || r.BlackBerry || r.iOS || r.Opera || r.Windows}}), n =! r.Windows &&! /khtml|trident|edge/.test(e) && e.includes ("gecko"), a =! e.includes ("opera") && / msie | trident / .test (e), i = a? função ( ) {var t = / (?: msie \ s + | rv:) (\ d + \. \ d) /. exec (e); retornar t? Número (t [1]): 0} (): nulo, o = e.includes ("opera") || e.includes ("opr /"), s = o? function () {var t = new RegExp ((/ khtml | chrome / .test (e)? "opr" : "versão") + "\\ / (\\ d + \\. \\ d +)"), r = t.exec (e); retornar r? Número (r [1]): 0} (): nulo , u = e.includes ("vivaldi"); return Object.freeze ({userAgent: e, isMobile: r, isGecko: n, isIE: a, ieVersion: i, isOpera: o, operaVersion: s, isVivaldi:u})} (), Has = function () {var e = function () {try {return "function" == typeof document.createElement ("audio"). canPlayType} catch (e) {} return! 1} (), t = function () {try {return "Blob" in window && "File" in window && "FileList" in window && "FileReader" in window && (! Browser.isOpera || Browser.operaVersion> = 15)} catch (e ) {} return! 1} (), r = function () {try {return "geolocalização" in navigator && "function" == typeof navigator.geolocation.getCurrentPosition && "function" == typeof navigator.geolocation.watchPosition} catch (e ) {} return! 1} (), n = function () {try {return "MutationObserver" in window && "function" == typeof window.MutationObserver} catch (e) {} return! 1} (), a = function () {tente {retornar "desempenho" na janela && "function "== typeof window.performance.now} catch (e) {} return! 1} (), i = function () {try {return" ontouchstart "in window || !! window.DocumentTouch && document instanceof window.DocumentTouch | | !! navigator.maxTouchPoints || !! navigator.msMaxTouchPoints} catch (e) {} return! 1} (), o = function () {try {for (var e = new Map ([["transição", " transactionend "], [" MSTransition "," msTransitionEnd "], [" WebkitTransition "," webkitTransitionEnd "], [" MozTransition "," transactionend "]]), t = []. concat (_toConsumableArray (e.keys () )), r = document.createElement ("div"), n = 0; n <t.length; ++ n) if (r.style [t [n]]! == undefined) return e.get (t [n])} catch (e) {} return! 1} (); return Object.freeze ({audio: e, fileAPI: t, geolocalização: r, mutationObserver: n, performance: a, touch: i, transactionEndEvent: o})} (),Visibility = function () {function e () {return a} function t () {return a && document [a.stateProperty] || "visible"} function r () {return Boolean (a)} function n () {return Boolean (a && document [a.hiddenProperty])} var a = function () {try {return Object.freeze ([{hiddenProperty: "hidden", stateProperty: "visibilityState", changeEvent: "visibilitychange"}, {hiddenProperty: "webkitHidden" , stateProperty: "webkitVisibilityState", changeEvent: "webkitvisibilitychange"}, {hiddenProperty: "mozHidden", stateProperty: "mozVisibilityState", changeEvent: "mozvisibilitychange"}, {hiddenProperty: "msHidden", stateProperty: "mozVisibilityState", changeEvent: "mozvisibilitychange"}, {hiddenProperty: "msHidden", stateProperty: "msVisibilityEvent:" msvisibilitychange "}]. find (function (e) {return e.hiddenProperty no documento}))} catch (e) {} return undefined} ();return Object.freeze (Object.defineProperties ({}, {vendor: {get: e}, estado: {get: t}, isEnabled: {value: r}, isHidden: {value: n}, hiddenProperty: {value: a && a.hiddenProperty}, stateProperty: {value: a && a.stateProperty}, changeEvent: {value: a && a.changeEvent}}))} (), Fullscreen = function () {function e (e) {var t = e || document .documentElement; return t === document.documentElement && ("msRequestFullscreen" === f.requestFn || Browser.isOpera && Browser.operaVersion <15) && (t = document.body), t} função t () {return f} função r () {return (f || null) && document [f.element]} function n () {return Boolean (f && document [f.isEnabled])} function a () {return Boolean (f && document [f.element]) } função i (t, r) {var n = this; if (! f) return Promise.reject (new Error ("tela cheia não suportada")); var i = e (r); if ("função"!= typeof i [f.requestFn]) return Promise.reject (new Error ("fullscreen not supported")); if (a ()) return Promise.resolve (); if (p ()) return i [f.requestFn ] (t); var o = ". Fullscreen_requestFullscreen"; retornar nova Promessa (função (e, r) {jQuery (i) .off (o) .one ("" + f.errorEvent + o + "" + f.changeEvent + o, function (t) {jQuery (n) .off (o), t.type === f.errorEvent? r (new Error ("erro de solicitação de tela inteira desconhecido")): e ()}), i [ f.requestFn] (t)})} function o () {var e = this; if (! f || "function"! = typeof document [f.exitFn]) return Promise.reject (new TypeError ("fullscreen not suportado ")); if (! a ()) return Promise.reject (new TypeError (" modo de tela cheia não ativo ")); if (p ()) retornar documento [f.exitFn] (); var t =". Fullscreen_exitFullscreen "; retornar nova Promessa (função (r, n) {jQuery (documento) .off (t) .one (" "+ f.errorEvent + t + "" + f.changeEvent + t, função (a) {jQuery (e) .off (t), a.type === f.errorEvent? n (new Error ("erro de saída de tela inteira desconhecido")) : r ()}), documento [f.exitFn] ()})} função s (e, t) {return a ()? o (): i (e, t)} função u (t, r) { if (f) {var n = e (r); $ (n) .on (f.changeEvent, t)}} função l (t, r) {if (f) {var n = e (r); t ? $ (n) .off (f.changeEvent, t): $ (n) .off (f.changeEvent)}} função c (t, r) {if (f) {var n = e (r); $ (n) .on (f.errorEvent, t)}} função d (t, r) {if (f) {var n = e (r); t? $ (n) .off (f.errorEvent, t) : $ (n) .off (f.errorEvent)}} var f = function () {try {return Object.freeze ([{isEnabled: "fullscreenEnabled", elemento: "fullscreenElement", requestFn: "requestFullscreen", exitFn: "exitFullscreen", changeEvent: "fullscreenchange", errorEvent: "fullscreenerror"}, {isEnabled: "webkitFullscreenEnabled", elemento: "webkitFullscreenElement ", requestFn:" webkitRequestFullscreen ", exitFn:" webkitExitFullscreen ", changeEvent:" webkitfullscreenchange ", errorEvent:" webkitfullscreenerror "}, {isEnabled:" mozFullScreenquestFullscreen ", changeEvent:" webkitfullscreenchange ". mozCancelFullScreen ", changeEvent:" mozfullscreenchange ", errorEvent:" mozfullscreenerror "}, {isEnabled:" msFullscreenEnabled ", elemento:" msFullscreenElement ", requestFn:" msRequestFullscreen ", exitFn:" msEullscreen ", exitventscreen:" msEullscreen "changeventscreen", exitventscreen: "msFullChange" MSFullscreenError "}]. Find (function (e) {return e.isEnabled in document}))} catch (e) {} return undefined} (), p = function () {function e () {if (null! = = t) retorna t; se (t =! 1,f) tente {var e = document.exitFullscreen (); e.catch (function () {}), t = e instanceof Promise} catch (e) {} return t} var t = null; return e} (); return Object.freeze (Object.defineProperties ({}, {vendor: {get: t}, element: {get: r}, isEnabled: {value: n}, isFullscreen: {value: a}, request: {value: i}, saída: {valor: o}, alternar: {valor: s}, onChange: {valor: u}, offChange: {valor: l}, onError: {valor: c}, offError: {valor: d} }))} (), _ ref3 = function () {function e (e) {for (var t = e.cloneNode (! 0), r = document.createDocumentFragment (), n = void 0; null! == ( n = t.firstChild);) {if (n.nodeType === Node.ELEMENT_NODE) ​​switch (n.nodeName.toUpperCase ()) {case "BR": case "DIV": case "P": r.appendChild (document.createTextNode (""))} r.appendChild (n)} return r.textContent} função t (e) {if ("object"! == (void 0 === e? "undefined": _ typeof ( e)) || null === e) return e;if (e instanceof String) return String (e); if (e instanceof Number) return Number (e); if (e instanceof Boolean) return Boolean (e)
} "}))} catch (e) {}})} var n = / \ {\ w + \} / g, a = new RegExp (n.source); retornar Object.freeze (Object.defineProperties ({}, {init: {value: e}, get: {value: t}}))} (), strings = {erros: {}, avisos: {}, debugView: {}, uiBar: {}, jumpto: {} , salva: {}, configurações: {}, reiniciar: {}, compartilhar: {}, carregar automaticamente: {}, macros: {voltar: {}, retornar: {}}}, l10nStrings = {identidade: "jogo", abortando: "Abortando", cancelando: "Cancelar", fechando: "Fechar", ok: "OK", errorTitle: "Erro", errorToggle: "Alternar a visualização do erro", errorNonexistentPassage: 'a passagem "{passage}" faz não existe ', errorSaveMissingData: "o salvamento não contém os dados necessários. O arquivo carregado não é um salvamento ou o salvamento foi corrompido ", errorSaveIdMismatch:" o salvamento é da {identidade} errada ", _ warningIntroLacking:" Seu navegador não tem ou está desabilitado ", _ warningOutroDegraded:", então esta {identidade} está rodando em um modo degradado. Você pode conseguir continuar, no entanto, algumas partes podem não funcionar corretamente. ", WarningNoWebStorage:" {_ warningIntroLacking} a API de armazenamento da Web {_warningOutroDegraded} ", warningDegraded:" {_ warningIntroLacking} alguns dos recursos exigidos por esta {identidade} { _warningOutroDegraded} ", debugBarToggle:" Alternar a barra de depuração ", debugBarNoWatches:" - nenhum relógio definido - ", debugBarAddWatch:" Adicionar relógio ", debugBarDeleteWatch:" Excluir relógio ", debugBarWatchAll:" Excluir todos ", debugBarWatchAll:" Excluir relógio "," , debugBarLabelAdd: "Add", debugBarLabelWatch: "Watch", debugBarLabelTurn: "Turn", debugBarLabelViews: "Views", debugBarViewsToggle: "
savesDisallowed: "O salvamento não foi permitido nesta passagem.", savesIncapable: "{_ warningIntroLacking} os recursos necessários para suportar salvamentos, portanto, os salvamentos foram desativados para esta sessão.", savesLabelAuto: "Autosave", savesLabelDelete: "Delete", savesLabelExport : "Salvar no disco ...", savesLabelImport: "Carregar do disco ...", savesLabelLoad: "Carregar", savesLabelClear: "Excluir tudo", savesLabelSave: "Salvar", savesLabelSlot: "Slot", savesUnavailable: "Nenhum slot para salvar encontrado ... ", savesUnknownDate:" desconhecido ", settingsTitle:" Configurações ", settingsOff:" Off ", settingsOn:" On ", settingsReset:" Reset to Defaults ", restartTitle:" Restart ", restartPrompt:" Tem certeza que deseja reiniciar? O progresso não salvo será perdido. ",shareTitle: "Share", alertTitle: "Alert", autoloadTitle: "Autoload", autoloadCancel: "Go to start", autoloadOk: "Load autosave", autoloadPrompt: "Existe um autosave. Carregar agora ou ir para o início?" , macroBackText: "Voltar", macroReturnText: "Retornar"}, Config = function () {var e =! 1, t =! 1, r =! 1, n = 0, a =! 0, i =! 0, o =! 0, s = 100, u =! 0, l = 1e3, c = "", d =! 0, f = vazio 0, p = vazio 0, h =! 1, g =! 1, m = vazio 0, v = vazio 0, y = vazio 0, b = vazio 0, w = vazio 0, k = "história sem título", S = vazio 0, E = vazio 0, j = vazio 0, x = 8, T =! 0, O = void 0, C = 800, A =! 0, P = "Config.history.mode se tornou obsoleto e não é mais usado pelo SugarCube, remova-o do seu código", _ = "Config .history.tracking tornou-se obsoleto, use Config.history.maxStates em vez disso "; return Object.freeze ({get debug () {return e}, set debug (t) {e = Boolean (t)},get addVisitedLinkClass () {return t}, set addVisitedLinkClass (e) {t = Boolean (e)}, get cleanupWikifierOutput () {return r}, set cleanupWikifierOutput (e) {r = Boolean (e)}, get loadDelay () {return n}, definir loadDelay (e) {if (! Number.isSafeInteger (e) || e <0) lançar novo RangeError ("Config.loadDelay deve ser um inteiro não negativo"); n = e}, áudio : Object.freeze ({get pauseOnFadeToZero () {return a}, set pauseOnFadeToZero (e) {a = Boolean (e)}, get preloadMetadata () {return i}, set preloadMetadata (e) {i = Boolean (e) }}), history: Object.freeze ({get controls () {return o}, set controls (e) {var t = Boolean (e); if (1 === s && t) throw new Error ("Config.history .controls deve ser false quando Config.history.maxStates for 1 "); o = t}, obter maxStates () {return s}, definir maxStates (e) {if (! Number.isSafeInteger (e) || e <0 ) lance novo RangeError ("Config.history.maxStates deve ser um inteiro não negativo "); s = e, o && 1 === e && (o =! 1)}, get mode () {throw new Error (P)}, set mode (e) {throw new Error (P)}, obter rastreamento () {lançar novo erro (_)}, definir rastreamento (e) {lançar novo erro (_)}}), macros: Object.freeze ({obter ifAssignmentError () {retornar u}, definir ifAssignmentError (e) {u = Boolean (e)}, obter maxLoopIterations () {return l}, definir maxLoopIterations (e) {if (! Number.isSafeInteger (e) || e <0) lançar novo RangeError ("Config .macros.maxLoopIterations deve ser um número inteiro não negativo "); l = e}, get typeSkipKey () {return c}, set typeSkipKey (e) {c = String (e)}, get typeVisitedPassages () {return d} , definir typeVisitedPassages (e) {d = Boolean (e)}}), navegação: Object.freeze ({get override () {return f}, set override (e) {if (! (null == e || e instanceof Function)) throw new TypeError ("Config.navigation.override deve ser uma função ou nulo / indefinido (recebido:"+ Util.getType (e) +") "); f = e}}), passagens: Object.freeze ({get descriptions () {return p}, set descriptions (e) {if (null! = E) {var t = Util.getType (e); if ("boolean"! == t && "Object"! == t && "function"! == t) throw new TypeError ("Config.passages.descriptions deve ser um booleano, objeto, função ou nulo / indefinido (recebido: "+ t +") ")} p = e}, obter displayTitles () {return h}, definir displayTitles (e) {h = Boolean (e)}, obter nobr ( ) {return g}, set nobr (e) {g = Boolean (e)}, get onProcess () {return v}, set onProcess (e) {if (null! = e) {var t = Util.getType ( e); if ("function"! == t) throw new TypeError ("Config.passages.onProcess deve ser uma função ou nulo / indefinido (recebido:" + t + ")")} v = e}, começar ( ) {return m}, defina start (e) {if (null! = e) {var t = Util.getType (e); if ("string"!== t) lançar novo TypeError ("Config.passages.start deve ser uma string ou nulo / indefinido (recebido:" + t + ")")} m = e}, obter transiçãoOut () {retornar y}, definir transiçãoOut ( e) {if (null! = e) {var t = Util.getType (e); if ("string"! == t && ("number"! == t ||! Number.isSafeInteger (e) || e <0)) throw new TypeError ("Config.passages.transitionOut deve ser uma string, inteiro não negativo ou nulo / indefinido (recebido:" + t + ")")} y = e}}), salva: Objeto. freeze ({get autoload () {return b}, set autoload (e) {if (null! = e) {var t = Util.getType (e); if ("boolean"! == t && "string"! = = t && "function"! == t) throw new TypeError ("Config.saves.autoload deve ser um booleano, string, função ou nulo / indefinido (recebido:" + t + ")")} b = e}, obter autosave () {return w}, set autosave (e) {if (null! = e) {var t = Util.getType (e); if ("string" === t) return void (w = [e]); if ("boolean"! == t && ("Array"! == t ||! e.every (function (e) {return "string" == typeof e})) && "function"! == t) throw new TypeError ("Config.saves.autosave deve ser um booleano, Array de strings, função ou nulo / indefinido ( recebido: "+ t + (" Array "=== t?" of mixed ":" ") +") ")} w = e}, obter id () {return k}, definir id (e) {if ( "string"! = typeof e || "" === e) throw new TypeError ("Config.saves.id deve ser uma string não vazia (recebido:" + Util.getType (e) + ")"); k = e}, obtenha isAllowed () {return S}, defina isAllowed (e) {if (! (null == e || e instanceof Function)) lance new TypeError ("Config.saves.isAllowed deve ser uma função ou nulo / indefinido (recebido: "+ Util.getType (e) +") "); S = e},get onLoad () {return E}, set onLoad (e) {if (! (null == e || e instanceof Function)) throw new TypeError ("Config.saves.onLoad deve ser uma função ou nulo / indefinido (recebido : "+ Util.getType (e) +") "); E = e}, obter onSave () {return j}, definir onSave (e) {if (! (Null == e || e instanceof Function)) lançar new TypeError ("Config.saves.onSave deve ser uma função ou nulo / indefinido (recebido:" + Util.getType (e) + ")"); j = e}, obter slots () {return x}, definir slots (e) {if (! Number.isSafeInteger (e) || e <0) throw new TypeError ("Config.saves.slots deve ser um número inteiro não negativo (recebido:" + Util.getType (e) + " ) "); x = e}, obter tryDiskOnMobile () {return T}, definir tryDiskOnMobile (e) {T = Boolean (e)}, obter versão () {return O}, definir versão (e) {O = e }}), ui: Object.freeze ({get stowBarInitially () {return C}, set stowBarInitially (e) {var t = Util.getType (e); if ("boolean"!== t && ("número"! == t ||! Number.isSafeInteger (e) || e <0)) throw new TypeError ("Config.ui.stowBarInitially deve ser um inteiro booleano ou não negativo (recebido:" + t + ")"); C = e}, obtenha updateStoryElements () {return A}, defina updateStoryElements (e) {A = Boolean (e)}})})} (), SimpleAudio = function () {function e () {if (arguments.length <2) {var e = []; lançar arguments.length <1 && e.push ("track ID"), arguments.length <2 && e.push ("sources"), new Error (" não "+ e.join (" ou ") +" especificado ")} var t = String (argumentos [0]). trim (), r = 'ID da faixa"' + t + '"'; if (_. teste (t)) lançar um novo erro ("inválido" + r + ": os IDs de faixa não devem conter dois pontos ou espaço em branco"); var n = Array.isArray (argumentos [1])? Array.from (argumentos [1]): Array .de (argumentos) .slice (1), a = vazio 0;tente {a = O (n)} catch (e) {lance novo Erro (r + ": erro durante a inicialização da faixa:" + e.message)} if (Config.debug &&! a.hasSource ()) lance novo Erro (r + ": nenhuma fonte de áudio compatível encontrada"); N.has (t) && N.get (t) ._ destroy (), N.set (t, a)} função t (e) {return N.has (e) && N .get (e) ._ destroy (), N.delete (e)} função r () {N.forEach (function (e) {return e._destroy ()}), N.clear ()} função n (e ) {return N.has (e)} função a (e) {return N.get (e) || null} função i () {if (arguments.length <2) {var e = []; lançar argumentos. length <1 && e.push ("group ID"), arguments.length <2 && e.push ("track IDs"), new Error ("no" + e.join ("ou") + "especificado")} var t = String (argumentos [0]). Trim (), r = 'ID do grupo "' + t + '"'; if (":"! == t [0] || _.test (t.slice (1)) ) lançar novo Erro ("inválido "+ r +": os IDs de grupo devem começar com dois-pontos e não devem conter dois-pontos ou espaço em branco "); if (A.includes (t)) lançar um novo erro (" não é possível sobrepujar especial "+ r); var n = Array. isArray (argumentos [1])? Array.from (argumentos [1]): Array.from (argumentos) .slice (1), a = void 0; tente {a = new Set (n.map (função (e) {if (! N.has (e)) throw new Error ('track "' + e + '" does not exist'); return e}))} catch (e) {throw new Error (r + ": erro durante o grupo inicialização: "+ e.message)} D.set (t, Object.freeze (Array.from (a)))} função o (e) {return D.delete (e)} função s () {D.clear ()} função u (e) {return D.has (e)} função l (e) {return D.get (e) || null} função c () {if (arguments.length <2) {var e = []; lançar argumentos.length <1 && e.push ("list ID"), arguments.length <2 && e.push ("track IDs"), novo Erro ("não" + e.join ("ou") + "especificado")} var t = String (argumentos [0]). trim (), r = 'ID da lista "' + t + '"'; if (_. test (t)) return this.error ("inválido" + r + ": os IDs de lista não devem conter dois pontos ou espaço em branco"); var n = Array.isArray (argumentos [1])? Array.from (argumentos [1]): Array.from (argumentos ) .slice (1), a = void 0; tente {a = new U (n.map (function (e) {if (null === e) throw new Error ("o descritor de faixa deve ser uma string ou objeto ( type: null) "); switch (void 0 === e?" undefined ": _ typeof (e)) {case" string ": e = {id: e}; break; case" objeto ": if (! e .hasOwnProperty ("id") &&! e.hasOwnProperty ("fontes")) lança um novo erro ('o descritor de trilha deve conter uma propriedade de "id" ou "fontes"); if (e.hasOwnProperty (" id ") && e.hasOwnProperty ("sources ")) throw new Error ('o descritor da trilha deve conter um" id "ou uma propriedade" sources ", não ambos'); break; default: throw new Error (" o descritor da trilha deve ser uma string ou objeto (tipo: "+ (void 0 === e?" undefined ": _ typeof (e)) +") ")} var t = void 0, r = void 0, n = void 0; if (e.hasOwnProperty (" id " )) {if ("string"! = typeof e.id) throw new Error ('propriedade "id" deve ser uma string'); if (! N.has (e.id)) throw new Error ('track " '+ e.id +' "não existe '); r = N.get (e.id)} else if (e.hasOwnProperty (" fontes ")) {if (! Array.isArray (e.sources) || 0 === e.sources.length) lançar novo Error ('a propriedade "sources" deve ser um array não vazio'); if (e.hasOwnProperty ("own")) throw new Error ('"own"propriedade não é permitida com a propriedade "sources" '); tente {r = O (e.sources), t =! 0} catch (e) {throw new Error ("erro durante a inicialização da faixa:" + e.message) } if (Config.debug &&! r.hasSource ()) throw new Error ("nenhuma fonte de áudio suportada encontrada")} if (e.hasOwnProperty ("own")) {if ("boolean"! = typeof e.own) lançar um novo Error ('"propriedade" própria deve ser um booleano'); t = e.own, t && (r = r.clone ())} if (e.hasOwnProperty ("volume")) {if ("número" ! = typeof e.volume || Number.isNaN (e.volume) ||! Number.isFinite (e.volume) || e.volume <0) throw new Error ('propriedade "volume" deve ser um não negativo número finito '); n = e.volume} return {own: null! = t && t, track: r, volume: null! = n? n: r.volume ()}}))} catch (e) {jogar novo Erro (r + ": erro durante a inicialização da lista de reprodução:" + e.mensagem)} I.has (t) && I.get (t) ._ destruir (), I.set (t, a)} função d (e) {retorno I.has (e) && I.get (e) ._ destruir (), I.delete (e)} function f () {I.forEach (function (e) {return e._destroy ()}), I.clear ()} function p (e) {return I.has ( e)} função h (e) {return I.get (e) || null} função g () {if (0 === arguments.length) lançar novo Error ("nenhum seletor de faixa especificado"); var e = String (argumentos [0]). Trim (), t = new Set; tente {var r = function e (t) {var r = t.id, a = void 0; switch (r) {case ": all" : a = n; break; case ": loop": a = n.filter (function (e) {return N.get (e) .loop ()}); break; case ": mute": a = n. filter (function (e) {return N.get (e) .mute ()}); break; case ": paused": a = n.filter (function (e) {return N.get (e) .isPaused ( )}); break; case ": playing": a = n.filter (function (e) {return N.get (e) .isPlaying ()});a)} função d (e) {return I.has (e) && I.get (e) ._ destroy (), I.delete (e)} function f () {I.forEach (function (e) {return e ._destroy ()}), I.clear ()} função p (e) {return I.has (e)} função h (e) {return I.get (e) || null} função g () {if (0 === argumentos. Comprimento) lançar um novo Erro ("nenhum seletor de faixa especificado"); var e = String (argumentos [0]). Trim (), t = novo Conjunto; tente {var r = função e (t ) {var r = t.id, a = void 0; switch (r) {case ": all": a = n; break; case ": looped": a = n.filter (function (e) {return N .get (e) .loop ()}); break; case ": mute": a = n.filter (function (e) {return N.get (e) .mute ()}); break; case ": pausado ": a = n.filter (function (e) {return N.get (e) .isPaused ()}); break; case": playing ": a = n.filter (function (e) {return N. get (e) .isPlaying ()});a)} função d (e) {return I.has (e) && I.get (e) ._ destroy (), I.delete (e)} function f () {I.forEach (function (e) {return e ._destroy ()}), I.clear ()} função p (e) {return I.has (e)} função h (e) {return I.get (e) || null} função g () {if (0 === argumentos. Comprimento) lançar um novo Erro ("nenhum seletor de faixa especificado"); var e = String (argumentos [0]). Trim (), t = novo Conjunto; tente {var r = função e (t ) {var r = t.id, a = void 0; switch (r) {case ": all": a = n; break; case ": looped": a = n.filter (function (e) {return N .get (e) .loop ()}); break; case ": mute": a = n.filter (function (e) {return N.get (e) .mute ()}); break; case ": pausado ": a = n.filter (function (e) {return N.get (e) .isPaused ()}); break; case": playing ": a = n.filter (function (e) {return N. get (e) .isPlaying ()});_destroy ()}), I.clear ()} função p (e) {return I.has (e)} função h (e) {return I.get (e) || null} função g () {if ( 0 === argumentos.length) lançar novo Erro ("nenhum seletor de faixa especificado"); var e = String (argumentos [0]). Trim (), t = novo Conjunto; tente {var r = função e (t) {var r = t.id, a = void 0; switch (r) {case ": all": a = n; break; case ": looped": a = n.filter (function (e) {return N. get (e) .loop ()}); break; case ": muted": a = n.filter (function (e) {return N.get (e) .mute ()}); break; case ": paused ": a = n.filter (function (e) {return N.get (e) .isPaused ()}); break; case": playing ": a = n.filter (function (e) {return N.get (e) .isPlaying ()});_destroy ()}), I.clear ()} função p (e) {return I.has (e)} função h (e) {return I.get (e) || null} função g () {if ( 0 === argumentos.length) lançar novo Erro ("nenhum seletor de faixa especificado"); var e = String (argumentos [0]). Trim (), t = novo Conjunto; tente {var r = função e (t) {var r = t.id, a = void 0; switch (r) {case ": all": a = n; break; case ": looped": a = n.filter (function (e) {return N. get (e) .loop ()}); break; case ": muted": a = n.filter (function (e) {return N.get (e) .mute ()}); break; case ": paused ": a = n.filter (function (e) {return N.get (e) .isPaused ()}); break; case": playing ": a = n.filter (function (e) {return N.get (e) .isPlaying ()});tente {var r = função e (t) {var r = t.id, a = vazio 0; switch (r) {caso ": todos": a = n; interromper; caso ": em loop": a = n. filter (function (e) {return N.get (e) .loop ()}); break; case ": mute": a = n.filter (function (e) {return N.get (e) .mute ( )}); break; case ": paused": a = n.filter (function (e) {return N.get (e) .isPaused ()}); break; case ": playing": a = n.filter (função (e) {retornar N.get (e) .isPlaying ()});tente {var r = função e (t) {var r = t.id, a = vazio 0; switch (r) {caso ": todos": a = n; interromper; caso ": em loop": a = n. filter (function (e) {return N.get (e) .loop ()}); break; case ": mute": a = n.filter (function (e) {return N.get (e) .mute ( )}); break; case ": paused": a = n.filter (function (e) {return N.get (e) .isPaused ()}); break; case ": playing": a = n.filter (função (e) {retornar N.get (e) .isPlaying ()});break; default: a = ":" === r [0]? D.get (r): [r]} if (t.hasOwnProperty ("not")) {var i = t.not.map (function (t) {return e (t)}). flat (1/0); a = a.filter (function (e) {return! i.includes (e)})} return a}, n = Array.from (N.keys ()); z (e) .forEach (function (e) {return r (e) .forEach (function (e) {if (! N.has (e)) lançar novo Error ('track " '+ e +' "não existe '); t.add (e)})})} catch (e) {lançar novo erro (" erro durante a inicialização do runner: "+ e.mensagem)} retornar novo B (t) } function m () {T ("load")} função v () {T ("loadwithscreen")} função y (e) {if (null == e) return F; F = !! e, T (" mute ", F)} função b (e) {if (! Visibility.isEnabled ()) return! 1; if (null == e) return R; R = !! e; var t =". SimpleAudio_masterMuteOnHidden "; if (R) {var r = "" + Visibility.changeEvent + t; jQuery (documento) .off (t) .on (r, function () {return y (Visibilidade.isHidden ())}), Visibility.isHidden () && y (! 0)} else jQuery (document) .off (t)} função w (e) {if (null == e) return L; if ("número" ! = typeof e || Number.isNaN (e) ||! Number.isFinite (e)) lance novo Error ("a taxa deve ser um número finito"); L = Math.clamp (e, .2,5), T ("taxa", L)} função k () {T ("parar")} função S () {T ("descarregar")} função E (e) {se (nulo == e) retornar Q; se ("número"! = tipo de e || Número.isNaN (e) ||! Número.isFinito (e)) lançar novo Erro ("o volume deve ser um número finito"); Q = Math.clamp (e, 0, 1), T ("volume", Q)} função j (e, t) {if ("função"! = Tipo de t) lançar novo Erro ("parâmetro de retorno de chamada deve ser uma função"); M.set (e, t)} função x (e) {M.delete (e)} função T (e, t) {M.para cada (função (r) {retorno r (e, t)})} função O (e) {retorno novo V (e.map (função (e) {if ("dados:"! == e.slice (0,5) &&Story.has (e)) {var t = Story.get (e); if (t.tags.includes ("Twine.audio")) return t.text.trim ()} var r = P.exec (e ); return null === r? e: {format: r [1], src: r [2]}}))} var C = Object.freeze (["click", "contextmenu", "dblclick", "keyup", "mouseup", "pointerup", "touchend"]), A = Object.freeze ([": not", ": all", ": looped", ": muted", ": paused", ": jogando"]), P = / ^ ([\ w -] +) \ s * \ | \ s * (\ S. *) $ /, _ = / [: \ s] /, N = novo mapa , D = novo mapa, I = novo mapa, M = novo mapa, L = 1, Q = 1, F =! 1, R =! 1, W = função () {função e () {if (nulo! = = t) retornar t; se (t =! 1, Has.audio) tentar {var e = document.createElement ("audio"); e.muted =! 0; var r = e.play (); r.catch (function () {}), t = r instanceof Promise} catch (e) {} return t} var t = null; return e} (), V = function () {function e (t) {if (_classCallCheck ( este, e),t instanceof Array) this._create (t); else {if (! (t instanceof e)) throw new Error ("o parâmetro de fontes deve ser uma matriz, de URIs ou objetos de origem, ou uma instância de AudioTrack"); isso. _copy (t)}} return _createClass (e, [{key: "_ create", value: function (t) {var r = / ^ data: \ s * audio \ / (?: x -)? ([^; ,] +) \ s * [;,] / i, n = / \. ([^. / \\] +) $ /, a = e.formatos, i = [], o = document.createElement (" audio "); o.preload =" none ", t.forEach (function (e) {var t = null; switch (void 0 === e?" undefined ": _ typeof (e)) {case" string ": var s = void 0; if ("dados:" === e.slice (0,5)) {if (null === (s = r.exec (e))) lançar novo Error ("URI de dados de origem tipo de mídia ausente ")} else if (null === (s = n.exec (Util.parseUrl (e) .pathname))) lançar novo Erro (" URL de origem ausente extensão de arquivo "); a [s [1] ] && (t = e); quebra; caso "objeto":if (null === e) lançar novo Erro ("objeto de origem não pode ser nulo"); if (! e.hasOwnProperty ("src")) lançar novo Erro ('objeto de origem ausente propriedade "src" necessária'); (! e.hasOwnProperty ("format")) lançar novo Erro ('objeto de origem ausente propriedade "formato" necessária'); a [formato eletrônico] && (t = e.src); quebra; padrão: lançar novo Erro ( "valor de fonte inválido (tipo:" + (void 0 === e? "undefined": _ typeof (e)) + ")")} if (null! == t) {var u = document.createElement ("fonte "); u.src = t, o.appendChild (u), i.push (t)}}), o.hasChildNodes () && Config.audio.preloadMetadata && (o.preload =" metadados "), this._finalize ( o, i, clone (t))}}, {key: "_ copy", value: function (e) {this._finalize (e.audio.cloneNode (! 0), clone (e.sources), clone (e .originals))}}, {chave: "_ finalize", valor:function (e, t, r) {var n = this; Object.defineProperties (this, {audio: {configurable:! 0, value: e}, sources: {value: Object.freeze (t)}, originais: { valor: Object.freeze (r)}, _ erro: {gravável:! 0, valor:! 1}, _ faderId: {gravável:! 0, valor: nulo}, _ mute: {gravável:! 0, valor:! 1} , _rate: {gravável:! 0, valor: 1}, _ volume: {gravável:! 0, valor: 1}}), jQuery (this.audio) .on ("loadstart.AudioTrack", function () {return n ._error =! 1}). on ("error.AudioTrack", function () {return n._error =! 0}). find ("source: last-of-type"). on ("error.AudioTrack" , function () {return n._trigger ("error")}), j (this, function (e) {if (! n.audio) return void x (n); switch (e) {case "loadwithscreen": if (n.hasSource ()) {var t = LoadScreen.lock (); n.one ("canplaythrough.AudioTrack_loadwithscreen error.AudioTrack_loadwithscreen", function () {jQuery (this) .off (".AudioTrack_loadwithscreen "), LoadScreen.unlock (t)}). Load ()} break; case" load ": n.load (); break; case" mute ": n._updateAudioMute (); break; case" rate ": n._updateAudioRate (); break; case "stop": n.stop (); break; case "volume": n._updateAudioVolume (); break; case "unload": n.unload ()}}), isso. _updateAudioMute (), this._updateAudioRate (), this._updateAudioVolume ()}}, {key: "_ trigger", value: function (e) {jQuery (this.audio) .triggerHandler (e)}}, {key: " _destroy ", valor: function () {x (this), this.audio && (jQuery (this.audio) .off (), this.unload (), this._error =! 0, delete this.audio)}}, {key: "clone", value: function () {return new e (this)}}, {key: "load", value: function () {var e = this; if (this.fadeStop (), this. audio.pause () ,! this.audio.hasChildNodes ()) {if (0 === this.sources.length) return; this.sources.forEach (function (t) {var r = document.createElement ("source"); r.src = t, e.audio.appendChild (r)})} "auto"! == this.audio.preload && (this. audio.preload = "auto"), this.isLoading () || this.audio.load ()}}, {key: "unload", value: function () {this.fadeStop (), this.stop () ; var e = this.audio; for (e.preload = "none"; e.hasChildNodes ();) e.removeChild (e.firstChild); e.load ()}}, {key: "play", value : function () {var e = this; if (! this.hasSource ()) return Promise.reject (new Error ("nenhuma das fontes candidatas era aceitável")); if (this.isUnloaded ()) return Promise. rejeitar (new Error ("nenhuma fonte foi carregada")); if (this.isFailed ()) retornar Promise.reject (new Error ("falha ao carregar qualquer uma das fontes")); "auto"! == this. audio.preload && (this.audio.preload = "auto"); var t = ".AudioTrack_play "; return W ()? This.audio.play (): new Promise (function (r, n) {e.isPlaying ()? R () :( jQuery (e.audio) .off (t) .one ("error" + t + "playing" + t + "timeupdate" + t, função (a) {jQuery (e) .off (t), "error" === a.type? n (new Error ("áudio desconhecido erro de reprodução ")): r ()}), e.audio.play ())})}}, {tecla:" playWhenAllowed ", valor: função () {var e = this; this.play (). catch (function () {var t = C.map (function (e) {return e + ". AudioTrack_playWhenAllowed"}). join (""); jQuery (documento) .one (t, function () {jQuery (documento). off (". AudioTrack_playWhenAllowed"), e.audio.play ()})})}}, {key: "pause", value: function () {this.audio.pause ()}}, {key: "stop ", valor: função () {this.audio.pause (), this.time (0), this._trigger (": parou ")}}, {tecla:" fade ", valor: função (e, t, r) {var n = isto;if ("número"! = tipo de e) lançar novo TypeError ("parâmetro de duração deve ser um número"); if ("número"! = tipo de t) lançar novo TypeError ("parâmetro de toVolume deve ser um número"); if ( null! = r && "número"! = typeof r) throw new TypeError ("o parâmetro fromVolume deve ser um número"); if (! this.hasSource ()) return Promise.reject (new Error ("nenhuma das fontes candidatas foi aceitável ")); if (this.isUnloaded ()) return Promise.reject (new Error (" nenhuma fonte foi carregada ")); if (this.isFailed ()) return Promise.reject (new Error (" falhou ao carregar qualquer uma das fontes ")); this.fadeStop (); var a = Math.clamp (null == r? this.volume (): r, 0,1), i = Math.clamp (t, 0,1 ); retornar a! == i? (this.volume (a), jQuery (this.audio) .off ("timeupdate.AudioTrack_fade"). one ("timeupdate.AudioTrack_fade",função () {var t = vazio 0, r = vazio 0; a <i? (t = a, r = i) :( t = i, r = a); var o = Math.max (e, 1) , s = (ia) / (o / .025); n._trigger (": fading"), n._faderId = setInterval (function () {if (! n.isPlaying ()) return void n.fadeStop () ; n.volume (Math.clamp (n.volume () + s, t, r)), Config.audio.pauseOnFadeToZero && 0 === n.volume () && n.pause (), n.volume () === i && (n.fadeStop (), n._trigger (": faded"))}, 25)}), this.play ()): void 0}}, {tecla: "fadeIn", valor: função (e, t) {return this.fade (e, 1, t)}}, {key: "fadeOut", value: function (e, t) {return this.fade (e, 0, t)}}, {key: "fadeStop", valor: function () {null! == this._faderId && (clearInterval (this._faderId), this._faderId = null)}}, {chave: "loop", value: function (e) {function t (t) {return e.apply (this, arguments)} return t.toString = function () {return e.toString ()}, t} (function (e) {return null == e? this.audio.loop: (this.audio.loop = !! e, this)})}, {key: "mute", valor: function (e) {return null == e? this._mute: (this._mute = !! e, this._updateAudioMute (), this)}}, {key: "_ updateAudioMute", value: function () {this.audio.muted = this._mute || F}}, {key: "rate", value: function (e) {if (null == e) return this._rate; if ("number"! = typeof e) throw new TypeError ("parâmetro de taxa deve ser um número"); retornar this._rate = Math.clamp ( e, .2,5), this._updateAudioRate (), this}}, {key: "_ updateAudioRate", value: function () {this.audio.playbackRate = Math.clamp (this._rate * L, .2, 5)}}, {key: "time", value: function (e) {var t = this; if (null == e) return this.audio.currentTime; if ("number"! = Typeof e) jogar novo TypeError ("parâmetro de tempo deve ser um número"); retornar this.hasMetadata ()? This.audio.currentTime = e: jQuery (this.audio) .off ("metadados carregados.AudioTrack_time "). One (" startedmetadata.AudioTrack_time ", function () {return t.audio.currentTime = e}), this}}, {key:" volume ", value: function (e) {if (null == e) retornar este._volume; if ("número"! = tipo de e) lançar novo TypeError ("o parâmetro de volume deve ser um número"); retornar este._volume = Math.clamp (e, 0,1), este._updateAudioVolume (), este}}, {chave: "_ updateAudioVolume", valor: função () {this.audio.volume = Math.clamp (this._volume * Q, 0,1)}}, {chave: "duração", valor: function () {return this.audio.duration}}, {key: "restante", value: function () {return this.audio.duration-this.audio.currentTime}}, {key: "isFailed", valor: function () {return this._error}}, {key: "isLoading", value: function () {return this.audio.networkState === HTMLMediaElement.NETWORK_LOADING}}, {key: "isUnloaded", valor:function () {return! this.audio.hasChildNodes ()}}, {key: "isUnavailable", value: function () {return! this.hasSource () || this.isUnloaded () || this.isFailed () }}, {key: "isPaused", value: function () {return! this.audio.paused && this.hasSomeData ()}}, {key: "isPaused", value: function () {return this.audio.paused && ( this.audio.duration === 1/0 || this.audio.currentTime> 0) &&! this.audio.ended}}, {key: "isStopped", value: function () {return this.audio.paused && 0 === this.audio.currentTime}}, {key: "isEnded", value: function () {return this.audio.ended}}, {key: "isFading", value: function () {return null! = = this._faderId}}, {key: "isSeeking", value: function () {return this.audio.seeking}}, {key: "hasSource", value: function () {return this.sources.length> 0 }}, {chave: "hasNoData", valor:function () {return this.audio.readyState === HTMLMediaElement.HAVE_NOTHING}}, {key: "hasMetadata", value: function () {return this.audio.readyState> = HTMLMediaElement.HAVE_METADATA}}, {key: " hasSomeData ", valor: function () {return this.audio.readyState> = HTMLMediaElement.HAVE_CURRENT_DATA}}, {key:" hasData ", value: function () {return this.audio.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA}} , {chave: "on", valor: função () {para (var e = argumentos.comprimento, t = Matriz (e), r = 0; r <e; r ++) t [r] = argumentos [r]; return jQuery.fn.on.apply (jQuery (this.audio), t), this}}, {key: "one", value: function () {for (var e = arguments.length, t = Array (e ), r = 0; r <e; r ++) t [r] = argumentos [r]; retornar jQuery.fn.one.apply (jQuery (this.audio), t), este}}, {chave: "desligado ", valor: função () {para (var e = argumentos.comprimento, t = Matriz (e), r = 0; r <e; r ++) t [r] = argumentos [r];return jQuery.fn.off.apply (jQuery (this.audio), t), this}}]), e} (); Object.defineProperties (V, {formatos: {valor: função () {função e (e ) {return r.has (e) || r.set (e, ""! == t.canPlayType (e) .replace (/ ^ no $ / i, "")), r.get (e)} var t = document.createElement ("audio"), r = new Map; retornar Object.assign (Object.create (null), {aac: e ("audio / aac"), caf: e ("audio / x- caf ") || e (" audio / caf "), flac: e (" audio / x-flac ") || e (" audio / flac "), mp3: e ('audio / mpeg; codecs =" mp3 "') || e (" audio / mpeg ") || e (" audio / mp3 ") || e (" audio / mpa "), mpeg: e (" audio / mpeg "), m4a: e (" audio / x-m4a ") || e (" audio / m4a ") || e (" audio / aac "), mp4: e (" audio / x-mp4 ") || e (" audio / mp4 ") || e ("audio / aac"), ogg: e ("audio / ogg"), oga: e ("audio / ogg"),opus: e ('audio / ogg; codecs = "opus"') || e ("audio / opus"), wav: e ('audio / wave; codecs = "1"') || e ('audio / wav; codecs = "1" ') || e ("áudio / onda") || e ("áudio / onda"), onda: e (' áudio / onda; codecs = "1" ') || e ( 'audio / wav; codecs = "1"') || e ("audio / wave") || e ("audio / wav"), weba: e ("audio / webm"), webm: e ("audio / webm ")})} ()}}); var U = function () {function e (t) {if (_classCallCheck (this, e), t instanceof Array) this._create (t); else {if ( ! (t instanceof e)) throw new Error ("o parâmetro tracks deve ser uma matriz, de objetos track ou uma instância AudioTrack"); this._copy (t)}} return _createClass (e, [{key: "_ create ", valor: function (e) {var t = this; this._finalize (e.map (function (e) {if (" object "! == (void 0 === e?"undefined ": _ typeof (e))) throw new Error (" rastreia os membros da matriz de parâmetros devem ser objetos "); var r = void 0, n = void 0, a = void 0, i = void 0; if (e instanceof V ) r =! 0, n = e.rate (), a = e.clone (), i = e.volume (); else {if (! e.hasOwnProperty ("track")) lança novo Error ('track objeto ausente da propriedade "trilha" obrigatória '); if (! (instância de e.track de V)) lançar novo Error (a propriedade "trilha" do objeto de trilha deve ser um objeto AudioTrack'); r = e.hasOwnProperty (" own ") && e.own, n = e.hasOwnProperty (" taxa ")? e.rate: e.track.rate (), a = e.track, i = e.hasOwnProperty (" volume ")? e.volume : e.track.volume ()} return a.stop (), a.loop (! 1), a.mute (! 1), a.rate (n), a.volume (i), a.on ( "encerrado.AudioList", function () {return t._onEnd ()}), {own: r, track: a, volume: i, rate: n}}))}}, {key: "_ copy", value : função (e) {isso._finalize (clone (e.tracks))}}, {key: "_ finalize", value: function (e) {Object.defineProperties (this, {tracks: {configurable:! 0, value: Object.freeze (e)} , fila: {configurável:! 0, valor: []}, atual: {gravável:! 0, valor: nulo}, _ taxa: {gravável:! 0, valor: 1}, _ volume: {gravável:! 0, valor : 1}, _ mute: {gravável:! 0, valor:! 1}, _ loop: {gravável:! 0, valor:! 1}, _ embaralhar: {gravável:! 0, valor:! 1}})}}, {chave: "_ destroy", value: function () {this.stop (), this.tracks.filter (function (e) {return e.own}). forEach (function (e) {return e.track._destroy ()}), exclua this.tracks, delete this.queue}}, {key: "load", value: function () {this.tracks.forEach (function (e) {return e.track.load ()} )}}, {key: "unload", value: function () {this.stop (), this.tracks.forEach (function (e) {return e.track.unload ()})}}, {key: "play", valor: function () {return null! == this.current &&! this.current.track.isUnavailable () &&! this.current.track.isEnded () || (0 === this.queue.length && this._fillQueue (), this._next ())? this.current.track.play (): Promise.reject (new Error ("nenhuma faixa estava disponível"))}}, {key: "playWhenAllowed", value: function () {var e = this; this.play (). Catch (function () {var t = C.map (function (e) {return e + ". AudioList_playWhenAllowed"}). Join (""); jQuery (document) .one (t, function () {jQuery (document) .off (". AudioList_playWhenAllowed") , e.play ()})})}}, {key: "pause", value: function () {null! == this.current && this.current.track.pause ()}}, {key: "stop" , valor: function () {null! == this.current && (this.current.track.stop (), this.current = null), this._drainQueue ()}}, {key: "skip", value: function () {this._next ()? this.current.track.play (): this._loop && this.play ()}},{chave: "fade", valor: função (e, t, r) {if ("número"! = tipo de e) lançar novo TypeError ("o parâmetro de duração deve ser um número"); if ("número"! = tipo de t) lançar um novo TypeError ("o parâmetro toVolume deve ser um número"); if (null! = r && "número"! = typeof r) lançar um novo TypeError ("o parâmetro fromVolume deve ser um número"); if (0 === this.queue.length && this._fillQueue (), null! == this.current &&! this.current.track.isUnavailable () &&! this.current.track.isEnded () || this._next ()) {var n = Math.clamp (t, 0,1) * this.current.volume, a = void 0; return null! = R && (a = Math.clamp (r, 0,1) * this.current.volume), this. _volume = t, this.current.track.fade (e, n, a)}}}, {key: "fadeIn", value: function (e, t) {return this.fade (e, 1, t)} }, {key: "fadeOut", value: function (e, t) {return this.fade (e, 0, t)}}, {key: "fadeStop ", valor: função () {nulo! == this.current && this.current.track.fadeStop ()}}, {tecla:" loop ", valor: função (e) {função t (t) {retornar e. aplicar (isto, argumentos)} return t.toString = function () {return e.toString ()}, t} (function (e) {return null == e? this._loop: (this._loop = !! e , this)})}, {key: "mute", value: function (e) {return null == e? this._mute: (this._mute = !! e, null! == this.current && this.current. track.mute (this._mute), this)}}, {key: "rate", value: function (e) {if (null == e) return this._rate; if ("number"! = typeof e) lançar novo TypeError ("parâmetro de taxa deve ser um número"); retornar this._rate = Math.clamp (e, .2,5), null! == this.current && this.current.track.rate (this._rate * this .current.rate), this}}, {key: "shuffle", value: function (e) {var t = this; if (null == e) return this._shuffle; if (this._shuffle = !! e , this.queue.comprimento> 0 && (this._fillQueue () ,! this._shuffle && null! == this.current && this.queue.length> 1)) {var r = this.queue.findIndex (function (e) {return e === t. current}); if (-1! == r) {var n; (n = this.queue) .push.apply (n, _toConsumableArray (this.queue.splice (0, r + 1)))}} return this}}, {key: "volume", value: function (e) {if (null == e) return this._volume; if ("number"! = typeof e) throw new TypeError ("parâmetro de volume deve ser um número "); retornar this._volume = Math.clamp (e, 0,1), null! == this.current && this.current.track.volume (this._volume * this.current.volume), this}}, { chave: "duração", valor: função () {if (argumentos.length> 0) lançar novo Erro ("duração não leva parâmetros"); retornar this.tracks.map (função (e) {return e.track.duration ()}). reduzir (função (e, t) {retornar e + t}, 0)}}, {tecla: "restante", valor:function () {if (arguments.length> 0) throw new Error ("o restante não leva parâmetros"); var e = this.queue.map (function (e) {return e.track.duration ()}). (function (e, t) {return e + t}, 0); return null! == this.current && (e + = this.current.track.remaining ()), e}}, {key: "time", valor: function () {if (arguments.length> 0) throw new Error ("o tempo não leva parâmetros"); return this.duration () - this.remaining ()}}, {key: "isPlaying", valor: function () {return null! == this.current && this.current.track.isPlaying ()}}, {key: "isPaused", value: function () {return null === this.current || this.current. track.isPaused ()}}, {key: "isStopped", value: function () {return 0 === this.queue.length && null === this.current}}, {key: "isEnded", value: function () {return 0 === this.queue.length && (null === this.current || this.current.track.isEnded ())}}, {key: "isFading", value: function () {return null! == this.current && this.current.track.isFading ()}}, {key: "_ next", valor: function () {null! == this.current && (this.current.track.stop (), this.current = null); for (var e = void 0; e = this.queue.shift ();) if (! e.track.isUnavailable ()) {this.current = e; break} return null! == this.current && (this.current.track.mute (this._mute), this.current.track.rate ( this._rate * this.current.rate), this.current.track.volume (this._volume * this.current.volume), this.current.track.loop (! 1) ,! 0)}}, {chave : "_ onEnd", valor: function () {if (0 === this.queue.length) {if (! this._loop) return; this._fillQueue ()} this._next () && this.current.track. play ()}}, {chave: "_ DrenoQueue", valor: função () {this.queue.splice (0)}}, {chave: "_ fillQueue", valor: função () {var e; this._drainQueue ( ),(e = this.queue) .push.apply (e, _toConsumableArray (this.tracks.filter (function (e) {return! e.track.isUnavailable ()}))), 0! == this.queue.length && this ._shuffle && (this.queue.shuffle (), this.queue.length> 1 && this.queue [0] === this.current && this.queue.push (this.queue.shift ()))}}]), e} (), B = function () {function e (t) {if (_classCallCheck (this, e),! (T instanceof Set || t instanceof e)) throw new TypeError ("parâmetro de lista deve ser um Set ou um AudioRunner instance "); Object.defineProperties (this, {trackIds: {value: new Set (t instanceof e? t.trackIds: t)}})} return _createClass (e, [{key:" load ", value: function ( ) {e._run (this.trackIds, V.prototype.load)}}, {chave: "descarregar", valor: função () {e._run (this.trackIds, V.prototype.unload)}}, { chave: "play", valor: function () {e._run (this.trackIds, V.prototype.play)}}, {chave: "playWhenAllowed ", value: function () {e._run (this.trackIds, V.prototype.playWhenAllowed)}}, {key:" pause ", value: function () {e._run (this.trackIds, V.prototype .pause)}}, {key: "stop", value: function () {e._run (this.trackIds, V.prototype.stop)}}, {key: "fade", value: function (t, r , n) {if (null == t || null == r) lançar novo Error ("fade requer parâmetros"); e._run (this.trackIds, V.prototype.fade, t, r, n)}} , {chave: "fadeIn", valor: função (t, r) {if (null == t) lançar novo Erro ("fadeIn requer um parâmetro"); e._run (this.trackIds, V.prototype.fadeIn, t, r)}}, {key: "fadeOut", value: function (t, r) {if (null == t) throw new Error ("fadeOut requer um parâmetro"); e._run (this.trackIds, V.prototype.fadeOut, t, r)}}, {chave: "fadeStop", valor: função () {e._run (this.trackIds, V.prototype.fadeStop)}}, {chave: "loop", valor:function (e) {function t (t) {return e.apply (this, arguments)} return t.toString = function () {return e.toString ()}, t} (function (t) {if (null = = t) lançar novo Erro ("loop requer um parâmetro"); retornar e._run (this.trackIds, V.prototype.loop, t), este})}, {chave: "mute", valor: função (t ) {if (null == t) throw new Error ("mute requer um parâmetro"); retornar e._run (this.trackIds, V.prototype.mute, t), este}}, {chave: "taxa", valor: function (t) {if (null == t) throw new Error ("a taxa requer um parâmetro"); retornar e._run (this.trackIds, V.prototype.rate, t), este}}, {chave : "tempo", valor: função (t) {se (nulo == t) lançar novo Erro ("tempo requer um parâmetro"); retornar e._run (this.trackIds, V.prototype.time, t), este }}, {chave: "volume", valor: função (t) {if (null == t) lançar novo Erro ("o volume requer um parâmetro"); retornar e._run (this.trackIds, V.prototype.volume, t), this}}, {key: "on", value: function () {for (var t = arguments.length, r = Array (t), n = 0; n < t; n ++) r [n] = argumentos [n]; retornar e._run.apply (e, [this.trackIds, V.prototype.on] .concat (r)), este}}, {chave: "um ", valor: função () {para (var t = argumentos.comprimento, r = Matriz (t), n = 0; n <t; n ++) r [n] = argumentos [n]; retornar e._run.aplicar (e, [this.trackIds, V.prototype.one] .concat (r)), este}}, {chave: "off", valor: função () {for (var t = arguments.length, r = Array (t), n = 0; n <t; n ++) r [n] = argumentos [n]; retornar e._run.apply (e, [this.trackIds, V.prototype.off] .concat (r)) , este}}], [{tecla: "_ executar", valor: função (e, t) {valor: função () {para (var t = argumentos.comprimento, r = Matriz (t), n = 0; n <t; n ++) r [n] = argumentos [n]; retornar e._run.apply (e , [this.trackIds, V.prototype.one] .concat (r)), este}}, {chave: "off", valor: função () {for (var t = arguments.length, r = Array (t ), n = 0; n <t; n ++) r [n] = argumentos [n]; retornar e._run.apply (e, [this.trackIds, V.prototype.off] .concat (r)), este }}], [{tecla: "_ run", valor: função (e, t) {valor: função () {para (var t = argumentos.comprimento, r = Matriz (t), n = 0; n <t; n ++) r [n] = argumentos [n]; retornar e._run.apply (e , [this.trackIds, V.prototype.one] .concat (r)), este}}, {chave: "off", valor: função () {for (var t = arguments.length, r = Array (t ), n = 0; n <t; n ++) r [n] = argumentos [n]; retornar e._run.apply (e, [this.trackIds, V.prototype.off] .concat (r)), este }}], [{tecla: "_ run", valor: função (e, t) {
para (var r = argumentos.comprimento, n = Matriz (r> 2? r-2: 0), a = 2; a <r; a ++) n [a-2] = argumentos [a]; e.para cada ( função (e) {var r = N.get (e); r && t.apply (r, n)})}}]), e} (), z = função () {função e (e, t) {var a = void 0; if (r.lastIndex = t, null === (a = r.exec (e)) || "("! == a [0]) lançar novo Erro ('inválido ": não ( ) "sintaxe: parênteses ausentes '); n.lastIndex = r.lastIndex; for (var i = r.lastIndex, o = {str:" ", nextMatch: -1}, s = 1; null! == (a = n.exec (e));) if ("(" === a [0]? ++ s: - s, s <1) {o.nextMatch = n.lastIndex, o.str = e. slice (i, o.nextMatch-1); break} return o} função t (r) {for (var n = [], a = / :? [^ \ s: ()] + / g, i = void 0; nulo! == (i = a.exec (r));) {var o = i [0]; if (": não" === o) {if (0 === n.length) lance novo erro ('negação inválida: nenhum ID de grupo precedido de ": not ()"'); var s = n [n.length-1]; if (":"! == s.id [0]) lançar novo erro ('negação inválida da faixa "'+ s.id +'": apenas grupos podem ser negados com ": not ()" '); var u = e (r, a.lastIndex); if (-1 === u.nextMatch ) lançar novo erro ('análise de erro desconhecido ": not ()"'); a.lastIndex = u.nextMatch, s.not = t (u.str)} else n.push ({id: o})} return n} var r = / \ S / g, n = / [()] / g; retornar t} (); retornar Object.freeze (Object.defineProperties ({}, {faixas: {value: Object.freeze (Object .defineProperties ({}, {add: {value: e}, delete: {value: t}, clear: {value: r}, has: {value: n}, get: {value: a}}))} , grupos: {valor: Object.freeze (Object.defineProperties ({}, {adicionar: {valor: i}, excluir: {valor: o}, limpar: {valor: s}, tem: {valor: u}, obter: {valor: l}}))}, listas: {valor: Object.freeze (Object.defineProperties ({}, {adicionar: {valor: c}, excluir: {valor: d}, limpar: {valor: f}, has: {value: p}, get: {value: h}}))}, select: {value: g}, load: {value: m}, loadWithScreen: {value: v}, mute: { valor: y},muteOnHidden: {valor: b}, taxa: {valor: w}, parar: {valor: k}, descarregar: {valor: S}, volume: {valor: E}}))} (), Estado = função ( ) {função e () {sessão.delete ("estado"), $ = [], H = c (), J = -1, G = [], Z = nulo === Z? nulo: novo PRNGWrapper ( Z.seed,! 1)} function t () {if (session.has ("state")) {var e = session.get ("state"); return null! = E && (n (e) ,! 0 )} return! 1} função r (e) {var t = {index: J}; return e? t.history = clone ($): t.delta = A ($), G.length> 0 && (t. expired = []. concat (_toConsumableArray (G))), nulo! == Z && (t.seed = Z.seed), t} função n (e, t) {if (null == e) lançar novo Error ( "objeto de estado é nulo ou indefinido"); if (! e.hasOwnProperty (t? "histórico": "delta") || 0 === e [t? "histórico": "delta"]. comprimento) lançar novo Erro ("objeto de estado não tem histórico ou o histórico está vazio"); if (! E.hasOwnProperty ("índice")) lançar new Error ("objeto de estado não tem índice"); if (null! == Z &&! e.hasOwnProperty ("seed")) lançar new Error ("objeto de estado não tem seed, mas PRNG está habilitado"); if (null === Z && e.hasOwnProperty ("seed")) throw new Error ("objeto de estado tem semente, mas PRNG está desabilitado"); $ = t? clone (e.history): P (e.delta), J = e.index, G = e.hasOwnProperty ("expired")? []. Concat (_toConsumableArray (e.expired)): [], e.hasOwnProperty ("seed") && (Z.seed = e.seed ), g (J)} função a () {retornar r (! 0)} função i (e) {retornar n (e,! 0)} função o () {retornar G} função s () {retornar G. comprimento + v ()} função u () {retornar G.concat ($. slice (0, v ()). map (função (e) {retornar e.título}))} função l (e) {retornar nulo ! = e && ""! == e && (!! G.includes (e) || !! $. slice (0, v ()). some (function (t) {return t.title === e}) )} função c (e,t) {return {title: null == e? "": String (e), variables: null == t? {}: clone (t)}} function d () {return H} function f () {return J} função p () {return H.title} função h () {return H.variables} função g (e) {if (null == e) throw new Error ("tentativa de ativação de momento com nulo ou indefinido"); switch (void 0 === e? "undefined": _ typeof (e)) {case "object": H = clone (e); break; case "number": if (b ()) throw new Error ("momento tentativa de ativação com índice no histórico vazio "); if (e <0 || e> = y ()) lançar novo RangeError (" tentativa de ativação de momento com índice fora dos limites; necessidade [0, "+ (y () -1) + "], obteve" + e); H = clone ($ [e]); interromper; padrão: lançar novo TypeError ('tentativa de ativação de momento com um "' + (vazio 0 === e?" Indefinido ": _typeof (e)) + '"; deve ser um objeto ou índice de pilha de histórico válido')} return null! == Z && (Z = PRNGWrapper.unmarshal ({seed: Z.seed, pull: H.pull})), session.set ("state", r ()), jQuery.event.trigger ( ": historyupdate"), H} função m () {return $} função v () {return J + 1} função y () {return $ .length} função b () {return 0 === $. length} function w () {return $ .length> 0? $ [J]: null} function k () {return $ .length> 0? $ [$. length-1]: null} function S () {return $. comprimento> 0? $ [0]: nulo} função E (e) {retorno b () || e <0 || e> J? nulo: $ [e]} função j (e) {if (b () ) retorna nulo; var t = 1 + (e? Math.abs (e): 0); retorna t> v ()? nulo: $ [v () - t]} função x (e) {if (b ( ) || null == e || "" === e) return! 1; for (var t = J; t> = 0; - t) if ($ [t] .title === e) return ! 0; return! 1} função T (e) {if (v () <y () && $. Splice (v (), y () - v ()), $. Push (c (e, H. variáveis)), Z && (k (). pull = Z.pull), Config.history.maxStates> 0) para (; y ()> Config.history.maxStates;) G.push ($. shift (). title); return J = y () - 1, g (J), v ()} função O (e) {return! (null == e || e <0 || e > = y () || e === J) && (J = e, g (J) ,! 0)} função C (e) {return null! = e && 0! == e && O (J + e)} função A (e) {if (! Array.isArray (e)) retorna nulo; if (0 === e.length) retorna []; para (var t = [e [0]], r = 1, n = e.length; r <n; ++ r) t.push (Diff.diff (e [r-1], e [r])); retornar t} função P (e) {if (! Array.isArray ( e)) retornar nulo; if (0 === e.length) return []; para (var t = [clone (e [0])], r = 1, n = e.length; r <n; + + r) t.push (Diff.patch (t [r-1], e [r])); retornar t} função _ (e, t) {if (! b ()) {var r = void 0; lance r = "the Story JavaScript", new Error ("State.initPRNG deve ser chamado durante a inicialização, dentro de" + r + "ou da passagem especial StoryInit")} Z = new PRNGWrapper (e, t), H.pull = Z.pull} função N () {return null! == Z} função D () {return Z? Z.pull: NaN} função I () {return Z? Z.seed:null} função M () {return Z? Z.random (): Math.random ()} função L () {Y = {}, TempVariables = Y} função Q () {return Y} função F (e) { try {return Scripting.evalTwineScript (e)} catch (e) {}} função R (e, t) {try {return Scripting.evalTwineScript (e + "= evalTwineScript $ Data $", null, t) ,! 0} catch (e) {} return! 1} função W () {storage.delete (K)} função V (e) {if ("string"! = typeof e) lançar um novo parâmetro de chave TypeError ("State.metadata.delete deve ser uma string (recebida: "+ (void 0 === e?" undefined ": _ typeof (e)) +") "); var t = storage.get (K); t && t.hasOwnProperty (e) && (1 === Object.keys (t) .length? Storage.delete (K) :( delete t [e], storage.set (K, t)))} função U (e) {if ("string"! = typeof e) throw new TypeError ("O parâmetro da chave State.metadata.get deve ser uma string (recebido:" + (void 0 === e? "undefined": _ typeof (e)) + ") "); var t = storage.get (K); return t && t.hasOwnProperty (e)? t [e]: undefined} função B (e) {if (" string "! = typeof e) throw new TypeError (" O parâmetro-chave State.metadata.has deve ser uma string (recebido: "+ (void 0 === e?" Undefined ": _ typeof (e)) +") "); var t = storage.get (K); return t && t.hasOwnProperty (e)} função z (e, t) {if ("string"! = typeof e) lançar o novo TypeError ("State.metadata.set key parâmetro deve ser uma string (recebido:" + (void 0 = == e? "undefined": _ typeof (e)) + ")"); if (void 0 === t) V (e); else {var r = storage.get (K) || {}; r [e] = t, storage.set (K, r)}} função q () {var e = storage.get (K); retornar e? Object.keys (e) .length: 0} var $ = [] , H = c (), J = -1, G = [], Z = nulo, Y = {}, K = "metadados"; retornar Object.freeze (Object.defineProperties ({}, {redefinir: {valor: e}, restaurar: {valor: t}, marshalForSave: {valor: a},unmarshalForSave: {value: i}, expired: {get: o}, turnos: {get: s}, passagens: {get: u}, hasPlayed: {value: l}, active: {get: d}, activeIndex: {obter: f}, passagem: {obter: p}, variáveis: {obter: h}, histórico: {obter: m}, comprimento: {obter: v}, tamanho: {obter: y}, isEmpty: {valor : b}, atual: {obter: w}, superior: {obter: k}, inferior: {obter: S}, índice: {valor: E}, peek: {valor: j}, tem: {valor: x }, criar: {valor: T}, goTo: {valor: O}, ir: {valor: C}, deltaEncode: {valor: A}, deltaDecode: {valor: P}, prng: {valor: Object.freeze (Object.defineProperties ({}, {init: {value: _}, isEnabled: {value: N}, pull: {get: D}, seed: {get: I}}))}, random: {value: M}, clearTemporary: {value: L}, temporário: {get: Q}, getVar: {value: F}, setVar: {value: R}, metadados: {value: Object.freeze (Object.defineProperties ({} , {limpar: {valor: W}, excluir: {valor: V}, obter: {valor: U}, tem: {valor: B}, definir: {valor: z}, tamanho: {obter: q}} ))}, initPRNG: {valor: _}, reiniciar: {valor: função () {return Engine.restart ()}}, retroceder: {valor:function () {return Engine.backward ()}}, encaminhar: {value: function () {return Engine.forward ()}}, exibir: {value: function () {return Engine.display.apply (Engine, argumentos )}}, mostrar: {valor: função () {retornar Motor.show.apply (Motor, argumentos)}}, reproduzir: {valor: função () {retornar Motor.play.apply (Motor, argumentos)}}} ))} (), Scripting = function () {function addAccessibleClickHandler (e, t, r, n, a) {if (arguments.length <2) lançar novo Error ("addAccessibleClickHandler número insuficiente de parâmetros"); var i = void 0, o = void 0; if ("função" == typeof t? (i = t, o = {namespace: n, one: !! r}) :( i = r, o = {namespace: a, one: !! n, selector: t}), "function"! = typeof i) throw new TypeError ("addAccessibleClickHandler parâmetro do manipulador deve ser uma função"); return jQuery (e) .ariaClick (o, i)} função insertElement (e, t, r, n, a, i) {var o = jQuery (document.createElement (t));retornar r && o.attr ("id", r), n && o.addClass (n), i && o.attr ("título", i), a && o.text (a), e && o.appendTo (e), função o [0]} insertText (e, t) {jQuery (e) .append (document.createTextNode (t))} função removeChildren (e) {jQuery (e) .empty ()} função removeElement (e) {jQuery (e) .remove ( )} função fade (e, t) {função r () {i + =. 05 * a, n (o, Math.easeInOut (i)), (1 === a && i> = 1 || -1 === a && i <= 0) && (e.style.visibility = "in" === t.fade? "visible": "hidden", o.parentNode.replaceChild (e, o), o = null, window.clearInterval ( s), t.onComplete && t.onComplete ())} função n (e, t) {e.style.zoom = 1, e.style.filter = "alpha (opacity =" + Math.floor (100 * t) + ")", e.style.opacity = t} var a = "in" === t.fade? 1: -1, i = vazio 0, o = e.cloneNode (! 0), s = vazio 0; e.parentNode.replaceChild (o, e), "em "=== t.fade? (i = 0, o.style.visibility =" visible "): i = 1, n (o, i), s = window.setInterval (r, 25)} function scrollWindowTo ( e, t) {função r () {l + = a, window.scroll (0, i + u * (s * Math.easeInOut (l))), l> = 1 && window.clearInterval (c)} função n (e ) {for (var t = 0; e.offsetParent;) t + = e.offsetTop, e = e.offsetParent; return t} var a = nulo! = t? Número (t) :. 1; Number.isNaN (a ) ||! Number.isFinite (a) || a <0? A = .1: a> 1 && (a = 1); var i = window.scrollY? Window.scrollY: document.body.scrollTop, o = function (e) {var t = n (e), r = t + e.offsetHeight, a = window.scrollY? window.scrollY: document.body.scrollTop, i = window.innerHeight? window.innerHeight: document.body. clientHeight, o = a + i; return t> = a && r> o && e.offsetHeight <i? t- (ie.offsetHeight) +20: t} (e), s = Math.abs (io), u = i> o ? -1: 1, l = 0, c = vazio 0; c = window.setInterval (r,25)} função toStringOrDefault (e) {return stringFrom (e)} função ou () {if (0! == arguments.length) return Array.prototype.concat.apply ([], argumentos) .random ()} função esqueça (e) {if ("string"! = typeof e) throw new TypeError ("o parâmetro chave deve ser um string (recebido:" + Util.getType (e) + ")"); State.metadata.delete ( e)} função hasVisited () {if (0 === arguments.length) lança novo Error ("hasVisited chamado com parâmetros insuficientes"); if (State.isEmpty ()) return! 1; for (var e = Array. prototype.concat.apply ([], argumentos), t = State.passages, r = 0, n = e.length; r <n; ++ r) if (! t.includes (e [r])) return ! 1; return! 0} função lastVisited () {if (0 === arguments.length) lançar novo Erro ("lastVisited chamado com parâmetros insuficientes"); if (State.isEmpty ()) return-1; for (var e = Array.prototype.concat.apply ([], argumentos), t = Estado.passagens, r = t.length-1, n = State.turns, a = 0, i = e.length; a <i && n> -1; ++ a) {var o = t.lastIndexOf (e [a]); n = Math.min (n, -1 === o? -1: ro)} return n} função memorizar (e, t) {if ("string"! = typeof e) throw new TypeError ("memorize key parâmetro deve ser uma string ( recebido: "+ Util.getType (e) +") "); State.metadata.set (e, t)} função passage () {return State.passage} função previous () {var e = State.passages; if (argumentos. comprimento> 0) {var t = Número (argumentos [0]); if (! Número.isSafeInteger (t) || t <1) lance novo RangeError ("o parâmetro de deslocamento anterior deve ser um número inteiro positivo maior que zero "); return e.length> t? e [e.length-1-t]:" "} para (var r = e.length-2; r> = 0; - r) if (e [r] ! == State.passage) return e [r]; return ""} função random () {var e = void 0, t = void 0; switch (arguments.length) {case 0: throw new Error ("aleatório chamado com parâmetros insuficientes "); caso 1: e = 0, t = Math.trunc (argumentos [0]); quebra; padrão: e = Math.trunc (argumentos [0]), t = Math.trunc (argumentos [1])} if (! Number.isInteger (e)) lançar novo Erro ("parâmetro mínimo aleatório deve ser um inteiro"); if (! Number.isInteger (t)) lançar novo Erro ("parâmetro máximo aleatório deve ser um inteiro "); se (e> t) {var r = [t, e]; e = r [0], t = r [1]} retornar Math.floor (State.random () * (t-e +1)) + e} função randomFloat () {var e = void 0, t = void 0; switch (arguments.length) {case 0: throw new Error ("randomFloat chamado com parâmetros insuficientes"); caso 1: e = 0, t = Número (argumentos [0]); quebra; padrão: e = Número (argumentos [0]), t = Número (argumentos [1])} if (Número.isNaN (e) ||! Número. isFinite (e)) lançar novo Error ("parâmetro randomFloat mínimo deve ser um número"); if (Number.isNaN (t) ||! Number.isFinite (t)) lançar novo Error ("O parâmetro randomFloat max deve ser um número "); if (e> t) {var r = [t, e]; e = r [0], t = r [1]} return State.random () * (te) + e} rechamada de função (e, t) {if ("string"! = typeof e) throw new TypeError ("o parâmetro da chave de rechamada deve ser uma string (recebido:" + Util.getType (e) + ")"); return State.metadata.has (e)? State.metadata.get (e): t} tags de função () {if (0 === arguments.length) return Story.get (State.passage) .tags.slice ( 0); para (var e = Array.prototype.concat.apply ([], argumentos), t = [], r = 0, n = e.length; r <n; ++ r) t = t.concat (Story.get (e [r]). Tags); return t} função temporária () {return State.temporary} função time () {return null === Engine.lastPlay? 0: Util.now () - Engine .lastPlay} função turn () {return State.turns} função variables () {return State.variables} função visitado () {if (State.isEmpty ()) return 0; for (var e = Array.prototype.concat. aplicar ([], 0 === argumentos.comprimento? [State.passage]: argumentos), t = State.passages, r = State.turns, n = 0, a = e.length; n <a && r> 0; ++ n) r = Math.min (r , t.count (e [n])); return r} função visitadoTags () {if (0 === argumentos.length) lançar novo Error ("visitadoTags chamados com parâmetros insuficientes"); if (State.isEmpty () ) retorna 0; para (var e = Array.prototype.concat.apply ([], argumentos), t = e.length, r = State.passages, n = new Map, a = 0, i = 0, o = r.length; i <o; ++ i) {var s = r [i]; if (n.has (s)) n.get (s) && ++ a; else {var u = Story.get ( s) .tags; if (u.length> 0) {for (var l = 0, c = 0; c <t; ++ c) u.includes (e [c]) && ++ l; l == = t? (++ a, n.set (s,! 0)): n.set (s,! 1)}}} return a} function evalJavaScript (code, output, data) {return function (code, output , evalJavaScript $ Data $) {return eval (code)}. call (output? {output: output}: null, String (code), output, data)} function evalTwineScript (code, output, data) {return function (code ,resultado,evalTwineScript $ Data $) {return eval (code)}. call (output? {output: output}: null, parse (String (code)), output, data)} var _ref8 = function () {function e (e) {return Util.parseUrl (e) .path.replace (/ ^ [^ \ w] + | [^ \ w] + $ / g, ""). replace (/ [^ \ w] + / g, "- ") .toLocaleLowerCase ()} function t (t) {return new Promise (function (r, n) {jQuery (document.createElement (" script ")). one (" load abort error ", function (e) {jQuery (e.target) .off (), "load" === e.type? r (e.target): n (new Error ('importScripts falhou ao carregar o script "' + t + '".'))} ) .appendTo (document.head) .attr ({id: "script-importado -" + e (t), digite: "text / javascript", src: t})})} function r (t) {return new Promise (function (r, n) {jQuery (document.createElement ("link")). One ("load abort error", function (e) {jQuery (e.target) .off (), "load" == = e.digite? r (e.target): n (new Error ('importStyles falhou ao carregar a folha de estilo "' + t + '".'))}). appendTo (document.head) .attr ({id: "style-importado - "+ e (t), rel:" folha de estilo ", href: t})})} função n (e) {return e.reduce (function (e, t) {return e = e.then (t)} , Promise.resolve ())} função a () {para (var e = argumentos.comprimento, r = Matriz (e), a = 0; a <e; a ++) r [a] = argumentos [a]; retornar Promise.all (r.map (function (e) {return Array.isArray (e)? N (e.map (function (e) {return function () {return t (e)}})): t (e) )}))} função i () {para (var e = argumentos.comprimento, t = Matriz (e), a = 0; a <e; a ++) t [a] = argumentos [a]; retornar Promise.all (t.map (function (e) {return Array.isArray (e)? n (e.map (function (e) {return function () {return r (e)}})): r (e)}) )} return {importScripts: a, importStyles: i}} (), importScripts = _ref8.importScripts, importStyles = _ref8.importStyles, parse = function () {function e (e) {if (0!== r.lastIndex) throw new RangeError ("Scripting.parse último índice é diferente de zero no início"); for (var s = e, u = void 0; null! == (u = r.exec (s) );) if (u [5]) {var l = u [5]; if ("$" === l || "_" === l) continuar; if (a.test (l)) l = l [0]; else if ("é" === l) {var c = r.lastIndex, d = s.slice (c); o.test (d) && (s = s.splice (c, d.search (n)), l = "isnot")} else {var f = s.slice (r.lastIndex); if (i.test (f)) continue} t [l] && (s = s. splice (u.index, l.length, t [l]), r.lastIndex + = t [l] .length-l.length)} return s} var t = Util.toEnum ({$: "State.variables. ", _:" State.temporary. ", To:" = ", eq:" == ", neq:"! = ", Is:" === ", isnot:"! == ", gt:" > ", gte:"> = ", lt:" <", lte:" <= ", e:" && ", ou:" || ", não:"! ", def: '" indefinido "!== typeof ', ndef:' "undefined" === typeof '}), r = new RegExp (["(\" \ "|' ')",' ("(?: \\\\. | [ ^ "\\\\]) +") ', "(' (?: \\\\. | [^ '\\\\]) +')", "([= + \\ - * \\ /% <> & \\ | \\ ^ ~!?:,; \\ (\\) \\ [\\] {}] +) "," ([^ \ "'= + \\ - * \ \ /% <> & \\ | \\ ^ ~!?:,; \\ (\\) \\ [\\] {} \\ s] +) "]. join (" | ")," g "), n = / \ S /, a = novo RegExp (" ^ "+ Patterns.variable), i = / ^ \ s *: /, o = / ^ \ s + não \ b /; return e} ( ); retornar Object.freeze (Object.defineProperties ({}, {parse: {value: parse}, evalJavaScript: {value: evalJavaScript}, evalTwineScript: {value: evalTwineScript}}))} (), _ ref9 = function () {return {EOF: -1, Lexer: function () {function e (t, r) {if (_classCallCheck (this, e), arguments.length <2) lançar novo Error ("Construtor Lexer chamado com poucos parâmetros ( fonte: string, initialState:function) "); Object.defineProperties (this, {source: {value: t}, initial: {value: r}, state: {gravável:! 0, value: r}, start: {gravável:! 0, value : 0}, pos: {gravável:! 0, valor: 0}, profundidade: {gravável:! 0, valor: 0}, itens: {gravável:! 0, valor: []}, dados: {gravável :! 0, valor: {}}})} return _createClass (e, [{key: "reset", value: function () {this.state = this.initial, this.start = 0, this.pos = 0, this .depth = 0, this.items = [], this.data = {}}}, {key: "run", value: function () {for (; null! == this.state;) this.state = this.state (this); return this.items}}, {key: "nextItem", value: function () {for (; 0 === this.items.length && null! == this.state;) this.state = this.state (this); return this.items.shift ()}}, {key: "next", value: function () {return this.pos> = this.source.length? -1: this.source [this.pos ++]}}, {key: "peek", value: function () {return this.pos> = this.source.length? -1:this.source [this.pos]}}, {key: "backup", value: function (e) {this.pos- = e || 1}}, {key: "forward", value: function (e) {this.pos + = e || 1}}, {key: "ignore", value: function () {this.start = this.pos}}, {key: "accept", value: function (e) {var t = this.next (); return-1! == t && (!! e.includes (t) || (this.backup () ,! 1))}}, {chave: "acceptRe", valor: função (e) {var t = this.next (); return-1! == t && (!! e.test (t) || (this.backup () ,! 1))}}, {key: "acceptRun ", valor: function (e) {for (;;) {var t = this.next (); if (-1 === t) return; if (! e.includes (t)) break} this.backup ()}}, {key: "acceptRunRe", valor: function (e) {for (;;) {var t = this.next (); if (-1 === t) return; if (! e. test (t)) break} this.backup ()}}, {key: "emit", value: function (e) {this.items.push ({type: e, text: this.source.slice (this. start, this.pos), start: this.start, pos: this.pos}), this.start = this.pos}}, {key: "error", value: function (e, t) {if (arguments.length <2) throw new Error ("Lexer.prototype.error chamado com poucos parâmetros (tipo: número, mensagem: string) "); return this.items.push ({type: e, message: t, text: this.source.slice (this.start, this.pos), start: this.start, pos: this.pos} ), nulo}}], [{chave: "enumFromNames", valor: função (e) {var t = e.reduce (função (e, t, r) {return e [t] = r, e}, { }); retornar Object.freeze (Object.assign (Object.create (null), t))}}]), e} ()}} (), EOF = _ref9.EOF, Lexer = _ref9.Lexer, Wikifier = function () {var e = 0, t = function () {function t (r, n, a) {_ classCallCheck (this, t), t.Parser.Profile.isEmpty () && t.Parser.Profile.compile () , Object.defineProperties (this, {source: {value: String (n)}, options: {gravável:! 0, value: Object.assign ({profile: "all"}, a)}, nextMatch: {gravável: ! 0, valor: 0}, saída: {gravável:! 0, valor: nulo},_rawArgs: {gravável:! 0, valor: ""}}), null == r? this.output = document.createDocumentFragment (): r.jquery? this.output = r [0]: this.output = r; tente {++ e, this.subWikify (this.output), 1 === e && Config.cleanupWikifierOutput && convertBreaks (this.output)} finalmente {- e}} return _createClass (t, [{key: "subWikify", valor: função (e, r, n) {var a = this.output; this.output = e; var i = void 0, o = void 0; t.Option.length> 0 && (i = Object.assign (i || {}, t.Option.options)), null! == n && "objeto" === (void 0 === n? "undefined": _ typeof (n)) && (i = Object.assign (i || {}, n)), i && (o = this.options, this.options = Object.assign ({}, this.options, i)); var s = t.Parser.Profile.get (this.options.profile ), u = r? new RegExp ("(?:" + r + ")", this.options.ignoreTerminatorCase? "gim": "gm"): null, l = void 0, c = void 0; faça {if (s.parserRegExp.lastIndex = this.nextMatch, u && (u.lastIndex = this.nextMatch), c = s.parserRegExp.exec (this.source), (l = u? u.exec (this.source): null) && ( ! c || l.index <= c.index)) return l.index> this.nextMatch && this.outputText (this.output, this.nextMatch, l.index), this.matchStart = l.index, this.matchLength = l [0] .length, this.matchText = l [0], this.nextMatch = u.lastIndex, this.output = a, void (o && (this.options = o)); if (c) {c.index > this.nextMatch && this.outputText (this.output, this.nextMatch, c.index), this.matchStart = c.index, this.matchLength = c [0] .length, this.matchText = c [0], this. nextMatch = s.parserRegExp.lastIndex; for (var d = vazio 0, f = 1, p = c.length; f <p; ++ f) if (c [f]) ​​{d = f-1; intervalo} if (s.parsers [d] .handler (this), null! = TempState.break) break}} while (l || c); null == TempState.break? this.nextMatch <this.source.length && (this .outputText (this.output,this.nextMatch, this.source.length), this.nextMatch = this.source.length): this.output.lastChild && this.output.lastChild.nodeType === Node.ELEMENT_NODE && "BR" === this.output.lastChild .nodeName.toUpperCase () && jQuery (this.output.lastChild) .remove (), this.output = a, o && (this.options = o)}}, {chave: "outputText", valor: função (e, t , r) {jQuery (e) .append (document.createTextNode (this.source.substring (t, r)))}}, {key: "rawArgs", value: function () {return this._rawArgs}}, {chave: "fullArgs", valor: função () {retornar Scripting.parse (this._rawArgs)}}], [{chave: "wikifyEval", valor: função (e) {var r = document.createDocumentFragment (); new t (r, e); var n = r.querySelector (". error"); if (null! == n) lançar novo Error (n.textContent.replace (errorPrologRegExp, "")); retornar r}} , {chave: "createInternalLink",valor: função (e, t, r, n) {var a = jQuery (document.createElement ("a")); retornar nulo! = t && (a.attr ("passagem de dados", t), Story.has (t)? (a.addClass ("link-internal"), Config.addVisitedLinkClass && State.hasPlayed (t) && a.addClass ("link-visitado")): a.addClass ("link-quebrado"), a.ariaClick ({one:! 0}, function () {"function" == typeof n && n (), Engine.play (t)})), r && a.append (document.createTextNode (r)), e && a.appendTo (e) , a [0]}}, {key: "createExternalLink", value: function (e, t, r) {var n = jQuery (document.createElement ("a")). attr ("target", "_ blank" ) .addClass ("link-external"). text (r) .appendTo (e); return null! = t && n.attr ({href: t, tabindex: 0}), n [0]}}, {key: "isExternalLink", valor: function (e) {return! Story.has (e) &&(novo RegExp ("^" + Patterns.url, "gim"). test (e) || /[/.?#]/. test (e))}}]), t} (); retornar Objeto. defineProperty (t, "Option", {value: function () {function e () {return o.length} function t () {return Object.assign.apply (Object, [{}]. concat (_toConsumableArray (o) ))} função r () {o = []} função n (e) {return o [e]} função a () {return o.pop ()} função i (e) {if ("objeto"! = = (void 0 === e? "undefined": _ typeof (e)) || null === e) throw new TypeError ("O parâmetro de opções Wikifier.Option.push deve ser um objeto (recebido:" + Util.getType (e) + ")"); retornar o.push (e)} var o = []; retornar Object.freeze (Object.defineProperties ({}, {comprimento: {obter: e}, opções: {obter: t }, limpar: {valor: r}, obter: {valor: n}, pop: {valor: a}, empurrar: {valor: i}}))} ()}), Object.defineProperty (t, "Parser ", {valor: função () {função e () {retorno d} função t (e) {se ("objeto "! == (void 0 === e?" undefined ": _ typeof (e))) throw new Error (" Wikifier.Parser.add parser parameter must be an object "); if (! e.hasOwnProperty (" nome ")) lançar novo Erro ('objeto analisador ausente propriedade" nome "obrigatória'); if (" string "! = tipo de e.nome) lançar novo Erro ('objeto analisador" propriedade "nome" deve ser uma string'); if (! e.hasOwnProperty ("match")) lança novo Error ('objeto analisador ausente "propriedade" match "obrigatória'); if (" string "! = typeof e.match) lança novo Error ('objeto analisador" match " propriedade deve ser uma string '); if (! e.hasOwnProperty ("handler")) lançar novo Erro (' objeto analisador ausente propriedade "manipulador" necessária '); if ("função"! = typeof e.handler) lançar novo Erro ('objeto analisador "a propriedade do manipulador "deve ser uma função '); if (e.hasOwnProperty (" perfis ") &&! Array.isArray (e.profiles)) lança um novo erro (a propriedade' analisador do objeto" perfis "deve ser uma matriz '); se (a (e.name)) lançar um novo Erro ('não é possível alterar o analisador existente "' + e.name + '"'); d.push (e)} função r (e) {var t = d.find (função ( t) {return t.name === e}); t && d.delete (t)} função n () {return 0 === d.length} função a (e) {return !! d.find (function ( t) {return t.name === e})} função i (e) {return d.find (function (t) {return t.name === e}) || null} função o () {return f} função s () {var e = d, t = e.filter (function (e) {return! Array.isArray (e.profiles) || e.profiles.includes ("core")}); return f = Object.freeze ({all: {parsers: e, parserRegExp: new RegExp (e.map (function (e) {return "(" + e.match + ")"}). Join ("|"), "gm ")}, core: {parsers: t, parserRegExp: new RegExp (t.map (function (e) {return" ("+ e.match +") "}). join (" | ")," gm " )}})} function u () {return "object"! == (void 0 === f? "undefined": _ typeof (f)) || 0 === Object.keys (f) .length} função l (e) {if ("objeto"! == (void 0 === f? "undefined": _ typeof (f)) ||! f.hasOwnProperty (e)) lançar novo Error ('perfil de analisador inexistente "' + e + '"'); return f [e]} função c (e) {return" object "=== (void 0 === f?" undefined ": _ typeof (f)) && f.hasOwnProperty (e)} var d = [], f = void 0; return Object.freeze (Object.defineProperties ({}, {parsers: {get: e}, add: {value: t}, delete: {value: r}, isEmpty: {valor: n}, tem: {valor: a}, obter: {valor: i}, Perfil: {valor: Object.freeze (Object.defineProperties ({}, {perfis: {obter: o}, compilar: { valor: s}, isEmpty: {valor: u}, tem: {valor:c}, get: {value: l}}))}}))} ()}), Object.defineProperties (t, {helpers: {value: {}}, getValue: {value: State.getVar}, setValue : {value: State.setVar}, parse: {value: Scripting.parse}, evalExpression: {value: Scripting.evalTwineScript}, evalStatements: {value: Scripting.evalTwineScript}, textPrimitives: {value: Patterns}}), Object .defineProperties (t.helpers, {inlineCss: {valor: função () {função e (e) {var n = {classes: [], id: "", estilos: {}}, a = void 0; fazer { t.lastIndex = e.nextMatch; var i = t.exec (e.source); if (a = i && i.index === e.nextMatch) {if (i [1]) n.styles [Util.fromCssProperty ( i [1])] = i [2] .trim (); else if (i [3]) n.styles [Util.fromCssProperty (i [3])] = i [4] .trim (); else if (i [5]) {var o = void 0; for (r.lastIndex = 0; null! == (o = r.exec (i [5]));) "." === o [1] ? n.classes.push (o [2]): n.id = o [2]} e.nextMatch = t.lastIndex}} while (a); retornar n} var t = novo RegExp (Patterns.inlineCss, " gm "),r = new RegExp ("(" + Patterns.cssIdOrClassSigil + ") (" + Patterns.anyLetter + "+)", "g"); return e} ()}, evalText: {value: function (e) {var t = void 0; tente {switch (t = Scripting.evalTwineScript (e), void 0 === t? "undefined": _ typeof (t)) {case "string": "" === t.trim () && ( t = e); break; case "número": t = String (t); break; default: t = e}} catch (r) {t = e} return t}}, evalPassageId: {value: function (e ) {return null == e || Story.has (e)? e: t.helpers.evalText (e)}}, hasBlockContext: {value: function (e) {for (var t = "function" == typeof window.getComputedStyle, r = e.length-1; r> = 0; - r) {var n = e [r]; switch (n.nodeType) {case Node.ELEMENT_NODE: var a = n.nodeName.toUpperCase (); if ("BR" === a) return! 0; var i = t? window.getComputedStyle (n, null): n.currentStyle; if (i && i.display) {if ("none" === i.display) continue;return "block" === i.display} switch (a) {case "ADDRESS": case "ARTICLE": case "ASIDE": case "BLOCKQUOTE": case "CENTER": case "DIV": case "DL" : case "FIGURA": case "FOOTER": case "FORM": case "H1": case "H2": case "H3": case "H4": case "H5": case "H6": case "HEADER" : case "HR": case "MAIN": case "NAV": case "OL": case "P": case "PRE": case "SECTION": case "TABLE": case "UL": return! 0} return! 1; case Node.COMMENT_NODE: continue; default: return! 1}} return! 0}}, createShadowSetterCallback: {value: function () {function e () {if (! a &&! (a = t.Parser. get ("macro"))) lançar new Error ('não foi possível encontrar o analisador "macro"');return a} função r () {for (var t = a || e (), r = new Set, n = t.context; null! == n; n = n.parent) n._shadows && n._shadows.forEach (função (e) {retornar r.add (e)}); retornar []. concat (_toConsumableArray (r))} função n (e) {var t = {}; retornar r (). forEach (função (e) ) {var r = e.slice (1), n ​​= "$" === e [0]? State.variables: State.temporary; t [e] = n [r]}), function () {var r = Object.keys (t), n = r.length> 0? {}: null; tente {return r.forEach (function (e) {var r = e.slice (1), a = "$" = == e [0]? State.variables: State.temporary; a.hasOwnProperty (r) && (n [r] = a [r]), a [r] = t [e]}), Scripting.evalJavaScript ( e)} finalmente {r.forEach (function (e) {var r = e.slice (1), a = "$" === e [0]? State.variables: State.temporary; t [e] = a [r], n.hasOwnProperty (r)? a [r] = n [r]: excluir a [r]})}}} var a = null; retornar n} ()}, parseSquareBracketedMarkup: {value: function () {função e (e, t) {e: para (;;) switch (e.next ()) {case "\\":var r = e.next (); if (r! == EOF && "\ n"! == r) break; case EOF: case "\ n": return EOF; case t: break e} return e.pos} função t (e) {if (! e.accept ("[")) return e.error (o.Error, "marcação incorreta entre colchetes"); if (e.accept ("[")) e.data .isLink =! 0, e.emit (o.LinkMeta); else {if (e.accept ("<>"),! (e.accept ("Ii") && e.accept ("Mm") && e.accept ("Gg") && e.accept ("["))) return e.error (o.Error, "marcação incorreta entre colchetes"); e.data.isLink =! 1, e.emit (o.ImageMeta) } return e.depth = 2, r} função r (t) {for (var r = t.data.isLink? "link": "imagem", i = s.Nenhum ;;) switch (t.next () ) {case EOF: case "\ n": return t.error (o.Error, "unterminated" + r + "markup"); case '"': if (e (t, '"') === EOF) return t.erro (o.Error, "string não terminada com aspas duplas em" + r + "marcação"); quebra; case "|": i === s.Nenhum && (i = s.LTR, t.backup (), t.emit (o.Text), t.forward (), t.emit (o.DelimLTR)); break; case "-": i === s.None && ">" === t.peek () && (i = s.LTR, t.backup (), t.emit (o.Text), t.forward (2), t.emit (o.DelimLTR)); quebrar; case "<": i === s. Nenhum && "-" === t.peek () && (i = s.RTL, t.backup (), t.emit (t.data.isLink? O.Link: o.Source), t.forward (2 ), t.emit (o.DelimRTL)); break; case "[": ++ t.depth; break; case "]": if (1 === - t.depth) switch (t.peek ( )) {case "[": return ++ t.depth, t.backup (), i === s.RTL? t.emit (o.Text): t.emit (t.data.isLink? o. Link: o.Source), t.forward (2), t.emit (o.InnerMeta), t.data.isLink? A: n; case "]": return - t.depth, t.backup () , i === s.RTL? t.emit (o.Text): t.emit (t.data.isLink? o.Link: o.Source), t.forward (2), t.emit (o.RightMeta), nulo; padrão: return t.error (o.Error, "malformado" + r + "marcação")} }} função n (t) {for (var r = t.data.isLink? "link": "imagem" ;;) switch (t.next ()) {case EOF: case "\ n": return t. erro (o.Error, "não terminada" + r + "marcação"); case '"': if (e (t, '"') === EOF) return t.error (o.Error, "string entre aspas duplas não terminada em "+ r +" componente de link de marcação "); break; case" [": ++ t.depth; break; case"] ": if (1 === - t.depth) switch (t.peek () ) {case "[": return ++ t.depth, t.backup (), t.emit (o.Link), t.forward (2), t.emit (o.InnerMeta), a; case "] ": return - t.depth, t.backup (), t.emit (o.Link), t.forward (2), t.emit (o.RightMeta), nulo; padrão: return t.error (o .Erro, "malformado" + r + "marcação")}}} função a (t) {for (var r = t.data.isLink? "link": "imagem" ;;) switch (t.next ()) {case EOF: case "\ n": return t.error (o.Error, "não terminado" + r + "marcação"); caso '"': if (e (t, '"') === EOF) return t.error (o.Error, "duplo não terminado string entre aspas em "+ r +" componente configurador de marcação "); quebra; case" '": if (e (t,"' ") === EOF) return t.error (o.Error," string entre aspas simples não terminada em "+ r +" componente configurador de marcação "); break; case" [": ++ t.depth; break; case"] ": if (1 === - t.depth) return"] "! == t .peek ()? t.error (o.Error, "malformado" + r + "marcação"): (- t.depth, t.backup (), t.emit (o.Setter), t.forward (2 ), t.emit (o.RightMeta), null)}} função i (e) {var r = new Lexer (e.source, t); r.start = r.pos = e.matchStart; var n = { },a = r.run (), i = a.last (); return i && i.type === o.Error? n.error = i.message: a.forEach (function (e) {var t = e.text .trim (); switch (e.type) {case o.ImageMeta: n.isImage =! 0, "<" === t [1]? n.align = "left": ">" === t [1] && (n.align = "right"); break; case o.LinkMeta: n.isLink =! 0; break; case o.Link:"~"===t[0]?(n.forceInternal =! 0, n.link = t.slice (1)): n.link = t; break; case o.etter: n.setter = t; break; case o.Fonte: n.source = t; break; case o.Text: n.text = t}}), n.pos = r.pos, n} var o = Lexer.enumFromNames (["Error", "DelimLTR", "DelimRTL", "InnerMeta", "ImageMeta "," LinkMeta "," Link "," RightMeta "," Setter "," Source "," Text "]), s = Lexer.enumFromNames ([" None "," LTR "," RTL "]); retornar isto}();!function () {function e (e) {this.lookahead.lastIndex = e.matchStart; var t = this.lookahead.exec (e.source); t && t.index === e.matchStart && (e.nextMatch = this. lookahead.lastIndex, jQuery (document.createDocumentFragment ()). append (t [1]). appendTo (e.output))} Wikifier.Parser.add ({name: "quoteByBlock", profiles: ["block"], correspondência: "^ <<< \\ n", terminador: "^ <<< \\ n", manipulador: função (e) {if (! Wikifier.helpers.hasBlockContext (e.output.childNodes)) return void jQuery (e.output) .append (document.createTextNode (e.matchText)); e.subWikify (jQuery (document.createElement ("blockquote")). appendTo (e.output) .get (0), this.terminator) }}), Wikifier.Parser.add ({name: "quoteByLine", profiles: ["block"], match: "^> +", lookahead: / ^> + / gm, terminator: "\\ n", manipulador: função (e) {if (! Wikificador.helpers.hasBlockContext (e.output.childNodes)) return void jQuery (e.output) .append (document.createTextNode (e.matchText)); var t = [e.output], r = 0, n = e.matchLength , a = vazio 0, i = vazio 0; fazer {
if (n> r) for (i = r; i <n; ++ i) t.push (jQuery (document.createElement ("blockquote")). appendTo (t [t.length-1]). get ( 0)); else if (n <r) para (i = r; i> n; - i) t.pop (); r = n, e.subWikify (t [t.length-1], isso. terminator), jQuery (document.createElement ("br")). appendTo (t [t.length-1]), this.lookahead.lastIndex = e.nextMatch; var o = this.lookahead.exec (e.source) ; a = o && o.index === e.nextMatch, a && (n = o [0] .length, e.nextMatch + = o [0] .length)} while (a)}}), Wikifier.Parser.add ( {name: "macro", profiles: ["core"], match: "<<", lookahead: new RegExp ("<< (/?" + Patterns.macroName + ") (?: \\ s *) (( ? :( ?: `(?: \\\\. | [^` \\\\]) * `) | (?: \" (?: \\\\. | [^ \ "\\\\ ]) * \ ") | (?: '(?: \\\\. | [^' \\\\]) * ') | (?: \\ [(?: [<>]? [Ii] [Mm] [Gg])? \\ [[^ \\ r \\ n] *? \\] \\] +) | [^>] | (?:> (?!>))) *)> > "," gm "), trabalhando: {fonte: "", nome: "", argumentos: "", índice: 0}, contexto: nulo, manipulador: função (e) {var t = this.lookahead.lastIndex = e.matchStart; if (this.parseTag (e)) {var r = e.nextMatch, n = this.working.name, a = this.working.arguments, i = void 0; tente {if (! (i = Macro.get (n ))) {if (Macro.tags.has (n)) {var o = Macro.tags.get (n); return throwError (e.output, "tag filho <<" + n + ">> foi encontrada fora de uma chamada para sua macro pai "+ (1 === o.length?" ":" s ") +" << "+ o.join (" >>, << ") +" >> ", e. source.slice (t, e.nextMatch))} return throwError (e.output, "macro <<" + n + ">> não existe", e.source.slice (t, e.nextMatch))} var s = null; if (void 0! == i.tags &&! (s = this.parseBody (e, i))) return e.nextMatch = r, throwError (e.output, "não é possível encontrar uma tag de fechamento para macro << "+ n +" >> ", e.source.slice (t, e.nextMatch) +"… "); if (" função "! = typeof i.handler) return throwError ( e.output, "macro <<" + n + ">> função de manipulador" + (void 0 === i.handler? "não existe": "não é uma função"), e.source.slice (t, e.nextMatch)); var u = s? s [0] .args: this.createArgs (a, this.skipArgs (i, i.name)); if (vazio 0! == i._MACRO_API) {this. context = new MacroContext ({macro: i, name: n, args: u, payload: s, source: e.source.slice (t, e.nextMatch), parent: this.context, parser: e}); tente {i.handler.call (this.context)} finalmente {this.context = this.context.parent}} else {var l = e._rawArgs; e._rawArgs = a; tente {i.handler (e.output, n, u, e, s)} finalmente {e._rawArgs = l}}} catch (r) {return throwError (e.output, "não pode executar" + (i && i.isWidget? "widget": "macro ") +" << "+ n +" >>: "+ r.message, e.source.slice (t, e.nextMatch))} finalmente {this.working.source =" ", this.working.name = "", this.working.arguments = "", this.working.index = 0}} else e.outputText (e.output, e.matchStart, e.nextMatch)}, parseTag: function (e) {var t = this.lookahead.exec (e.source); return! (! t || t.index! == e.matchStart ||! t [1]) && (e.nextMatch = this.lookahead.lastIndex, isto. working.source = e.source.slice (t.index, this.lookahead.lastIndex), this.working.name = t [1], this.working.arguments = t [2], this.working.index = t .index,! 0)}, parseBody: function (e, t) {for (var r = this.working.name, n = "/" + r, a = "end" + r, i = !! Array. isArray (t.tags) && t.tags, o = [], s = -1, u = 1, l = this.working.source, c = this.working.name, d = this.working.arguments, f = e.nextMatch; -1! == (e.matchStart = e.source.indexOf (this.match, e.nextMatch));) if (this.parseTag (e)) {var p = this.working.source, h = this.working.name, g = this.working.arguments, m = this.working.index, v = e.nextMatch, y = ""! == g.trim (); switch (h) {case r: ++ u; break; case a: case n: if (y) throw e.nextMatch = m + 2 + h.length, new Error ('tag de fechamento malformada: "' + p + '"'); - u; break; padrão: if (y && (h.startsWith ("/") || h.startsWith ("end" ))) {this.lookahead.lastIndex = e.nextMatch = m + 2 + h.length; continue} if (1 === u && i) para (var b = 0, w = i.length; b <w; + + b) h === i [b] && (o.push ({fonte: l, nome: c, argumentos: d, args: this.createArgs (d, this.skipArgs (t, c)), conteúdo: e.source.slice (f, m)}), l = p, c = h, d = g, f = v)} if (0 === u) {o.push ({fonte: l, nome: c, argumentos: d, args: this.createArgs (d, this.skipArgs (t, c)), conteúdo: e.source.slice (f, m)}), s = v; quebrar}} else this.lookahead .lastIndex = e.nextMatch = e.matchStart + isso.match.length; return-1! == s? (e.nextMatch = s, o): null}, createArgs: function (e, t) {var r = t? []: this.parseArgs (e); return Object.defineProperties (r, {raw: {value: e}, full: {value: Scripting.parse (e)}}), r}, skipArgs: function (e, t) {if (void 0! == e .skipArgs) {var r = e.skipArgs; return "boolean" == typeof r && r || Array.isArray (r) && r.includes (t)} return void 0! == e.skipArg0 && (e.skipArg0 && e.name = == t)}, parseArgs: function () {function e (e, t) {e: for (;;) switch (e.next ()) {case "\\": var r = e.next () ; if (r! == EOF && "\ n"! == r) break; case EOF: case "\ n": return EOF; case t: break e} return e.pos} função t (e) {var t = e.source.slice (e.pos) .search (c); if (t === EOF) retorna nulo; switch (0! == t && (e.pos + = t, e.ignore ()), e .next ()) {case "` ": return r; case '"': return n; case "'": return a; case "[":return i; default: return o}} função r (r) {return e (r, "` ") === EOF? r.error (u.Error," expressão de verso não terminada ") :( r.emit (u .Expressão), t)} função n (r) {return e (r, '"') === EOF? R.error (u.Error," string não terminada com aspas duplas ") :( r.emit (u. String), t)} função a (r) {return e (r, "'") === EOF? R.error (u.Error, "string entre aspas simples não terminada") :( r.emit (u.String ), t)} função i (e) {var r = void 0; if (e.accept ("<> IiMmGg")? (r = "imagem", e.acceptRun ("<> IiMmGg")): r = "link",! e.accept ("[")) return e.error (u.Error, "malformado" + r + "marcação"); e.depth = 2; e: for (;;) switch (e .next ()) {case "\\": var n = e.next (); if (n! == EOF && "\ n"! == n) break; case EOF: case "\ n": return e .error (u.Error, "não terminado "+ r +" marcação "); case" [": ++ e.depth; break; case"] ": if (- e.depth <0) return e.error (u.Error," inesperado quadrado direito colchete ']' "); if (1 === e.depth) {if ("] "=== e.next ()) {- e.depth; break e} e.backup ()}} return e.emit (u.SquareBracket), t} função o (e) {var r = e.source.slice (e.pos) .search (l); return e.pos = r === EOF? e.source .comprimento: e.pos + r, e.emit (u.Bareword), r === EOF? null: t} função s (e) {var r = novo Lexer (e, t), n = []; return r.run (). forEach (function (e) {var t = e.text; switch (e.type) {case u.Error: throw new Error ('não foi possível analisar o argumento macro "' + t + '": '+ e.message); case u.Bareword: if (d.test (t)) t = State.getVar (t); else if (/ ^ (?: settings | setup) [. [] /. test ( t)) tente {t = Scripting.evalTwineScript (t)} catch (e) {throw new Error ('não é possível analisar o argumento macro "' + t + '":'+ e.message)} else if ("null" === t) t = null; else if ("undefined" === t) t = undefined; else if ("true" === t) t = ! 0; else if ("falso" === t) t =! 1; else if ("NaN" === t) t = NaN; else {var r = Número (t); Número.isNaN (r) || (t = r)} quebra; caso u.Expressão: if ("" === (t = t.slice (1, -1) .trim ())) t = indefinido; caso contrário, tente {t = Scripting .evalTwineScript ("(" + t + ")")} catch (e) {throw new Error ('não é possível analisar a expressão do argumento macro "' + t + '":' + e.message)} break; case u.String: tente {t = Scripting.evalJavaScript (t)} catch (e) {lance novo Erro ('não foi possível analisar a string do argumento macro "' + t + '":' + e.message)} break; case u.SquareBracket: var a = Wikifier.helpers.parseSquareBracketedMarkup ({source: t, matchStart: 0}); if (a.hasOwnProperty ("error")) lançar novo Error ('incapaz de analisar o argumento da macro "'+ t +'": '+ a.error); if (a.pos <t.length) lançar novo Erro (' incapaz de analisar o argumento da macro "'+ t +'": caractere (s) inesperado (s ) "'+ t.slice (a.pos) +'" (pos: '+ a.pos + ")"); a.isLink? (t = {isLink:! 0}, t.count = a.hasOwnProperty ( "text")? 2: 1, t.link = Wikifier.helpers.evalPassageId (a.link), t.text = a.hasOwnProperty ("text")? Wikifier.helpers.evalText (a.text): t. link, t.external =! a.forceInternal && Wikifier.isExternalLink (t.link), t.setFn = a.hasOwnProperty ("setter")? Wikifier.helpers.createShadowSetterCallback (Scripting.parse (a.setter)): null): a.isImage && (t = function (e) {var t = {source: e, isImage:! 0}; if ("data:"! == e.slice (0,5) && Story.has (e)) { var r = Story.get (e); r.tags.includes ("Twine.image") && (t.source = r.text, t.passage = r.title)} return t} (Wikifier.helpers.evalPassageId (a.source)), a.hasOwnProperty ("align") && (t.align = a.align), a.hasOwnProperty ("text") && (t.title = Wikifier.helpers.evalText (a.text)), a.hasOwnProperty ("link") && (t.link = Wikifier.helpers.evalPassageId (a.link) , t.external =! a.forceInternal && Wikifier.isExternalLink (t.link)), t.setFn = a.hasOwnProperty ("setter")? Wikifier.helpers.createShadowSetterCallback (Scripting.parse (a.setter)): null)} n.push (t)}), n} var u = Lexer.enumFromNames (["Error", "Bareword", "Expression", "String", "SquareBracket"]), l = novo RegExp (Patterns.space) , c = new RegExp (Patterns.notSpace), d = new RegExp ("^" + Patterns.variable); return s} ()}), Wikifier.Parser.add ({name: "link", profiles: [" essencial"], corresponder: "\\ [\\ [[^ []", manipulador: função (e) {var t = Wikifier.helpers.parseSquareBracketedMarkup (e); if (t.hasOwnProperty ("error")) return void e .outputText (e.output, e.matchStart, e.nextMatch); e.nextMatch = t.pos; var r = Wikifier.helpers.evalPassageId (t.link), n = t.hasOwnProperty ("text")? Wikificador .helpers.evalText (t.text): r, a = t.hasOwnProperty ("setter")? Wikifier.helpers.createShadowSetterCallback (Scripting.parse (t.setter)): null, i = (Config.debug? new DebugView (e.output, "link-markup", "[[link]]", e.source.slice (e.matchStart, e.nextMatch)): e) .output; t.forceInternal ||! Wikifier.isExternalLink ( r)? Wikifier.createInternalLink (i, r, n, a): Wikifier.createExternalLink (i, r, n)}}), Wikifier.Parser.add ({name: "urlLink", profiles: ["core"] , corresponder: Patterns.url, manipulador: função (e) {e.outputText (Wikificador.createExternalLink (e.output, e.matchText), e.matchStart, e.nextMatch)}}), Wikifier.Parser.add ({name: "image", profiles: ["core"], match: "\\ [ [<>]? [Ii] [Mm] [Gg] \\ [", manipulador: função (e) {var t = Wikifier.helpers.parseSquareBracketedMarkup (e); if (t.hasOwnProperty (" error ")) return void e.outputText (e.output, e.matchStart, e.nextMatch); e.nextMatch = t.pos; var r = void 0; Config.debug && (r = new DebugView (e.output, "image-markup" , t.hasOwnProperty ("link")? "[img [] [link]]": "[img []]", e.source.slice (e.matchStart, e.nextMatch)), r.modes ({ bloquear:! 0})); var n = t.hasOwnProperty ("setter")? Wikifier.helpers.createShadowSetterCallback (Scripting.parse (t.setter)): null, a = (Config.debug? r: e). saída, i = vazio 0; if (t.hasOwnProperty ("link")) {var o = Wikifier.helpers.evalPassageId (t.link); a = t.forceInternal ||! Wikifier.isExternalLink (o)? Wikifier.createInternalLink (a, o, null, n): Wikifier.createExternalLink (a, o), a.classList.add ("link-imagem")} if (a = jQuery (document.createElement ("img")). appendTo (a) .get (0), i = Wikifier.helpers.evalPassageId (t.source), "data:"! == i.slice (0,5) && Story.has (i)) {var s = Story.get (i); s.tags.includes ("Twine.image") && (a.setAttribute ("data-passage", s.title), i = s .text.trim ())} a.src = i, t.hasOwnProperty ("text") && (a.title = Wikifier.helpers.evalText (t.text)), t.hasOwnProperty ("align") && ( a.align = t.align)}}), Wikifier.Parser.add ({name: "monospacedByBlock", profiles: ["block"], match: "^ \\ {\\ {\\ {\\ n" , lookahead: / ^ \ {\ {\ {\ n ((?: ^ [^ \ n] * \ n) +?) (^ \} \} \} $ \ n?) / gm, handler: function ( e) {this.lookahead.lastIndex = e.matchStart;var t = this.lookahead.exec (e.source); if (t && t.index === e.matchStart) {var r = jQuery (document.createElement ("pre")); código jQuery (document.createElement ("code ")). text (t [1]). appendTo (r), r.appendTo (e.output), e.nextMatch = this.lookahead.lastIndex}}}), Wikifier.Parser.add ({name:" formatByChar ", profiles: [" core "], match:" '' | // | __ | \\ ^ \\ ^ | ~~ | == | \\ {\\ {\\ {", handler: function ( e) {switch (e.matchText) {case "''": e.subWikify (jQuery (document.createElement ("strong")). appendTo (e.output) .get (0), "''"); break; case "//": e.subWikify (jQuery (document.createElement ("em")). appendTo (e.output) .get (0), "//"); break; case "__": e .subWikify (jQuery (document.createElement ("u")). appendTo (e.output) .get (0), "__"); break; case "^^": e.subWikify (jQuery (document.createElement ("sup")). appendTo (e.output) .get (0), "\\ ^ \\ ^"); break; case "~~": e.subWikify (jQuery ( document.createElement ("sub")). appendTo (e.output) .get (0), "~~"); break; case "==": e.subWikify (jQuery (document.createElement ("s") ) .appendTo (e.output) .get (0), "=="); break; case "{{{": var t = / \ {\ {\ {((?:. | \ n) *? ) \} \} \} / gm; t.lastIndex = e.matchStart; var r = t.exec (e.source); r && r.index === e.matchStart && (jQuery (document.createElement ("código") ) .text (r [1]). appendTo (e.output), e.nextMatch = t.lastIndex)}}}), Wikifier.Parser.add ({name: "customStyle", profiles: ["core"] , corresponder: "@@", terminador: "@@", blockRe: / \ s * \ n / gm, manipulador: função (e) {var t = Wikifier.helpers.inlineCss (e); this.blockRe.lastIndex = e.nextMatch;var r = this.blockRe.exec (e.source), n = r && r.index === e.nextMatch, a = jQuery (document.createElement (n? "div": "span")). appendTo (e. output); 0 === t.classes.length && "" === t.id && 0 === Object.keys (t.styles) .length? a.addClass ("marcado") :( t.classes.forEach ( function (e) {return a.addClass (e)}), ""! == t.id && a.attr ("id", t.id), a.css (t.styles)), n? (e. nextMatch + = r [0] .length, e.subWikify (a [0], "\\ n?" + this.terminator)): e.subWikify (a [0], this.terminator)}}), Wikificador. Parser.add ({name: "verbatimText", profiles: ["core"], match: '"{3} | <[Nn] [Oo] [Ww] [Ii] [Kk] [Ii]>', lookahead : / (?: "{3} ((?:. | \ N) *?)" {3}) | (?: <[Nn] [Oo] [Ww] [Ii] [Kk] [Ii]> ((?:. | \ n) *?) <\ / [Nn] [Oo] [Ww] [Ii] [Kk] [Ii]>) / gm, manipulador: função (e) {this.lookahead.lastIndex = e.matchStart;var t = this.lookahead.exec (e.source); t && t.index === e.matchStart && (e.nextMatch = this.lookahead.lastIndex, jQuery (document.createElement ("span")). addClass ("literalmente ") .text (t [1] || t [2]). appendTo (e.output))}}), Wikifier.Parser.add ({name:" horizontalRule ", profiles: [" core "], match : "^ ---- + $ \\ n? | <[Hh] [Rr] \\ s * /?> \\ n?", manipulador: function (e) {jQuery (document.createElement ("hr")). appendTo (e.output)}}), Wikifier.Parser.add ({name: "emdash", profiles: ["core"], match: "-", handler: function ( e) {jQuery (document.createTextNode ("-")). appendTo (e.output)}}), Wikifier.Parser.add ({name: "doubleDollarSign", profiles: ["core"], match: "\ \ $ {2} ", manipulador: function (e) {jQuery (document.createTextNode (" $ ")). AppendTo (e.output)}}), Wikifier.Parser.add ({name:" nakedVariable ", perfis : ["core"], corresponder: Patterns.variable + "(?: (?: \\." + Patterns.identifier + ") | (?: \\ [\\ d + \\]) | (?: \\ [ \ "(?: \\\\. | [^ \" \\\\]) + \ "\\]) | (?: \\ ['(?: \\\\. | [^' \\ \\]) + '\\]) | (?: \\ ["+ Patterns.variable +" \\])) * ", manipulador: função (e) {var t = State.getVar (e.matchText); null == t? jQuery (document.createTextNode (e.matchText)). appendTo (e.output): new Wikifier ((Config.debug? new DebugView (e.output, "variable", e.matchText, e.matchText): e) .output, stringFrom (t))}}), Wikifier.Parser.add ({nome: "template", profiles: ["core"], match: "\\?" + Patterns.templateName, handler: function (e) {var t = e.matchText.slice (1), r = Template .get (t), n = null; switch (r instanceof Array && (r = r.random ()), void 0 === r? "undefined": _ typeof (r)) {case "function": try {n = stringFrom (r.call ({name: t}))} catch (r) {return throwError (e.output, "não pode executar o modelo de função?" + t + ":" + r.message, e.source.slice ( e.matchStart, e.nextMatch))} break; case "string": n = r} null === n? jQuery (document.createTextNode (e.matchText)). appendTo (e.output): novo Wikificador (( Config.debug? New DebugView (e.output, "template", e.matchText, e.matchText): e) .output, n)}}), Wikificador.Parser.add ({name: "header", profiles: ["block"], match: "^! {1,6}", terminator: "\\ n", handler: function (e) {if (! Wikifier .helpers.hasBlockContext (e.output.childNodes)) return void jQuery (e.output) .append (document.createTextNode (e.matchText)); e.subWikify (jQuery (document.createElement ("h" + e.matchLength )). appendTo (e.output) .get (0), this.terminator)}}), Wikifier.Parser.add ({name: "table", profiles: ["block"], match: "^ \\ | (?: [^ \\ n] *) \\ | (?: [fhck]?) $ ", lookahead: / ^ \ | ([^ \ n] *) \ | ([fhck]?) $ / gm, rowTerminator: "\\ | (?: [cfhk]?) $ \\ n?", cellPattern: "(?: \\ | ([^ \\ n \\ |] *) \\ |) | ( \\ | [cfhk]? $ \\ n?) ", cellTerminator:" (?: \\ u0020 *) \\ | ", rowTypes: {c:" caption ", f:" tfoot ", h:" thead "," ":" tbody "}, manipulador: função (e) {if (! Wikifier.helpers.hasBlockContext (e.output.childNodes)) return void jQuery (e.output) .append (document.createTextNode (e.matchText)); var t = jQuery (document.createElement ("table")). appendTo (e.output ) .get (0), r = [], n = nulo, a = nulo, i = 0, o = void 0; e.nextMatch = e.matchStart; faça {this.lookahead.lastIndex = e.nextMatch; var s = this.lookahead.exec (e.source); if (o = s && s.index === e.nextMatch) {var u = s [2]; "k" === u? (t.className = s [1], e.nextMatch + = s [0] .length + 1) :( u! == n && (n = u, a = jQuery (document.createElement (this.rowTypes [u])). AppendTo (t) ), "c" === n? (a.css ("caption-side", 0 === i? "top": "bottom"), e.nextMatch + = 1, e.subWikify (a [0] , this.rowTerminator)): this.rowHandler (e, jQuery (document.createElement ("tr")). appendTo (a) .get (0), r), ++ i)}} while (o)}, rowHandler: função (e, t, r) {var n = this, a = new RegExp (this.cellPattern, "gm"),i = 0, o = 1, s = void 0; faça {a.lastIndex = e.nextMatch; var u = a.exec (e.source); if (s = u && u.index === e.nextMatch) { if ("~" === u [1]) {var l = r [i]; l && (++ l.rowCount, l. $ element.attr ("rowspan", l.rowCount) .css ("vertical -align "," middle ")), e.nextMatch = u.index + u [0] .length-1} else if ("> "=== u [1]) ++ o, e.nextMatch = u .index + u [0] .length-1; else {if (u [2]) {e.nextMatch = u.index + u [0] .length; break}! function () {++ e.nextMatch; for (var a = Wikifier.helpers.inlineCss (e), s =! 1, u =! 1, l = void 0; "" === e.source.substr (e.nextMatch, 1);) s = ! 0, ++ e.nextMatch; "!" === e.source.substr (e.nextMatch, 1)? (L = jQuery (document.createElement ("th")). AppendTo (t), ++ e.nextMatch): l = jQuery (document.createElement ("td")). appendTo (t), r [i] = {rowCount: 1, $ element: l}, o> 1 && (l.attr ("colspan ", o), o = 1), e.subWikify (l [0], n.cellTerminator), "" === e.matchText.substr (e.matchText.length-2,1) && (u =! 0), a.classes.forEach (function (e) {return l.addClass (e) }), ""! == a.id && l.attr ("id", a.id), s && u? a.styles ["text-align"] = "center": s? a.styles ["text-align "] =" direita ": u && (a.styles [" text-align "] =" esquerda "), l.css (a.styles), e.nextMatch = e.nextMatch-1} ()} ++ i }} while (s)}}), Wikifier.Parser.add ({name: "list", profiles: ["block"], match: "^ (?: (?: \\ * +) | (?: # +)) ", antecipação: / ^ (?: (\ * +) | (# +)) / gm, terminador:" \\ n ", manipulador: função (e) {if (! Wikifier.helpers.hasBlockContext (e.output.childNodes)) return void jQuery (e.output) .append (document.createTextNode (e.matchText)); e.nextMatch = e.matchStart; var t = [e.output], r = null, n = 0, a = vazio 0, i = vazio 0; faça {this.lookahead.lastIndex = e.nextMatch; var o = this.lookahead.exec (e.source); if (a = o && o.index === e.nextMatch) {var s = o [2]? "ol": "ul" , u = o [0] .length; if (e.nextMatch + = o [0] .length, u> n) for (i = n; i <u; ++ i) t.push (jQuery (document.createElement (s)). appendTo (t [t.length-1]). get (0)); else if (u <n) para (i = n; i> u; - i) t.pop (); else u === n && s! == r && (t.pop (), t.push (jQuery (document.createElement (s)). appendTo (t [t.length-1]). get (0))); n = u, r = s, e.subWikify (jQuery (document.createElement ("li")). appendTo (t [t.length-1]). get (0), this.terminator)}} while (a )}}), Wikifier.Parser.add ({name: "commentByBlock", profiles: ["core"], match: "(?: / (?:% | \\ *)) | (?: \ X3c! -) ", lookahead: / (?: \ / (% | \ *) (?: (?:. | \ n) *?) \ 1 \ /) | (?: <! - (? :( ?:. | \ n) *?) ->) / gm, manipulador: função (e) {this.lookahead.lastIndex = e.matchStart; var t = this.lookahead.exec (e.source); t && t.index === e.matchStart && (e.nextMatch = this.lookahead.lastIndex)}}), Wikifier.Parser.add ({name: "lineContinuation", profiles: ["core"], match: "\\\\" + Patterns.spaceNoTerminator + "* \\ n | \\ n" + Patterns.spaceNoTerminator + "* \\\\ | \\ n? \\\\" + Patterns.spaceNoTerminator + "* $ | ^" + Patterns.spaceNoTerminator + "* \\\\\\ n?", Manipulador: função (e) {e.nextMatch = e.matchStart + e.matchLength}}), Wikifier.Parser.add ({nome: "lineBreak" , profiles: ["core"], match: "\\ n | <[Bb] [Rr] \\ s * /?>", manipulador: function (e) {e.options.nobr || jQuery (document. createElement ("br")). appendTo (e.output)}}), Wikifier.Parser.add ({name: "htmlCharacterReference", profiles: ["core"], match: "(?: (?: & # ? [0-9A-Za-z] {2,8}; |.) (?: & #? (?: x0 * (?:3 [0-6] [0-9A-Fa-f] | 1D [C-Fc-f] [0-9A-Fa-f] | 20 [D-Fd-f] [0-9A-Fa-f ] | FE2 [0-9A-Fa-f]) | 0 * (?: 76 [89] | 7 [7-9] [0-9] | 8 [0-7] [0-9] | 761 [ 6-9] | 76 [2-7] [0-9] | 84 [0-3] [0-9] | 844 [0-7] | 6505 [6-9] | 6506 [0-9] | 6507 [0-1]));) + | & #? [0-9A-Za-z] {2,8};) ", manipulador: função (e) {jQuery (document.createDocumentFragment ()). Append (e.matchText) .appendTo (e.output)}}), Wikifier.Parser.add ({name: "xmlProlog", profiles: ["core"], match: "<\\? [Xx] [Mm] [Ll] [^>] * \\?> ", Manipulador: function (e) {e.nextMatch = e.matchStart + e.matchLength}}), Wikifier.Parser.add ({name:" verbatimHtml ", perfis : ["core"], corresponda: "<[Hh] [Tt] [Mm] [Ll]>", lookahead: / <[Hh] [Tt] [Mm] [Ll]> ((?:. | \ n) *?) <\ / [Hh] [Tt] [Mm] [Ll]> / gm, handler: e}), Wikifier.Parser.add ({name: "verbatimScriptTag", profiles: ["core"] , corresponder: "<[Ss] [Cc] [Rr] [Ii] [Pp] [Tt] [^>] *> ", lookahead: / (<[Ss] [Cc] [Rr] [Ii] [Pp] [Tt] * > (?:. | \ n) *? <\ / [Ss] [Cc] [Rr] [Ii] [Pp] [Tt]>) / gm, handler: e}), Wikifier.Parser.add ({ nome: "styleTag", profiles: ["core"], match: "<[Ss] [Tt] [Yy] [Ll] [Ee] [^>] *>", lookahead: / (<[Ss] [ Tt] [Yy] [Ll] [Ee] *>) ((?:. | \ N) *?) (<\ / [Ss] [Tt] [Yy] [Ll] [Ee]>) / gm, imageMarkup: new RegExp (Patterns.cssImage, "g"), hasImageMarkup: new RegExp (Patterns.cssImage), manipulador: function (e) {this.lookahead.lastIndex = e.matchStart; var t = this.lookahead.exec ( e.source); if (t && t.index === e.matchStart) {e.nextMatch = this.lookahead.lastIndex; var r = t [2]; this.hasImageMarkup.test (r) && (this.imageMarkup. lastIndex = 0, r = r.replace (this.imageMarkup, função (e) {var t = Wikifier.helpers.parseSquareBracketedMarkup ({source: e, matchStart: 0}); if (t.hasOwnProperty ("erro ") || t.pos <e.length) return e; var r = t.source; if (" data: "! == r.slice (0,5) && Story.has (r)) {var n = Story.get (r); n.tags.includes ("Twine.image") && (r = n.text)} return'url ("'+ r.replace (/" / g, "% 22") + '")'})), jQuery (document.createDocumentFragment ()). append (t [1] + r + t [3]). appendTo (e.output)}}}), Wikifier.Parser.add ( {nome: "svgTag", perfis: ["core"], corresponder: "<[Ss] [Vv] [Gg] [^>] *>", lookahead: / (<[Ss] [Vv] [Gg] [^>] *> (?:. | \ n) *? <\ / [Ss] [Vv] [Gg]>) / gm, namespace: "http://www.w3.org/2000/svg" , manipulador: function (e) {var t = this; this.lookahead.lastIndex = e.matchStart; var r = this.lookahead.exec (e.source); if (r && r.index === e.matchStart) { e.nextMatch = this.lookahead.lastIndex; var n = jQuery (document.createDocumentFragment ()). append (r [1]); n.find ("a [passagem de dados], imagem [passagem de dados]"). each (função (r, n) {var a = n.tagName.toLowerCase (); tente {t.processAttributeDirectives (n)} catch ( t) {return throwError (e.output, "svg | <" + a + ">:" + t.message, e.matchText + "…")} n.hasAttribute ("data-passage") && t.processDataAttributes (n, a)}), n.appendTo (e.output)}}, processAttributeDirectives: function (e) {[]. concat (_toConsumableArray (e.attributes)). forEach (function (t) {var r = t.name, n = t.value, a = "@" === r [0]; if (a || r.startsWith ("sc-eval:")) {var i = r.slice (a? 1: 8) ; if ("data-setter" === i) throw new Error ('diretiva de avaliação não é permitida no atributo setter de dados: "' + r + '"'); var o = void 0; try {o = Scripting .evalTwineScript (n)} catch (e) {throw new Error ('avaliação ruim da diretiva de atributo "' + r + '": '+ e.message)} try {e.setAttribute (i, o), e.removeAttribute (r)} catch (e) {throw new Error (' não é possível transformar a diretiva de atributo" '+ r +' "em atributo" '+ i +' "')}}})}, processDataAttributes: function (e, t) {var r = e.getAttribute (" data-passage "); if (null! = r) {var n = Wikifier.helpers .evalPassageId (r); if (n! == r && (r = n, e.setAttribute ("passagem de dados", n)), ""! == r) if ("imagem" === t) " dados: "! == r.slice (0,5) && Story.has (r) && (r = Story.get (r), r.tags.includes (" Twine.image ") && e.setAttribute (" href " , r.text.trim ())); else {var a = e.getAttribute ("data-setter"), i = void 0; null! = a && ""! == (a = String (a) .trim ()) && (i = Wikifier.helpers.createShadowSetterCallback (Scripting.parse (a))), Story.has (r)? (e.classList.add ("link-internal"), Config.addVisitedLinkClass && State.hasPlayed (r) && e.classList.add ("link-visitado")): e.classList.add ("link-quebrado"), jQuery (e) .ariaClick ({one:! 0}, function () {"function" == typeof i && i.call (this), Engine.play (r)})}}}}), Wikifier.Parser.add ({name: "htmlTag ", perfis: [" core "], corresponder:" <"+ Patterns.htmlTagName +" (?: \\ s + [^ \\ u0000 - \\ u001F \\ u007F - \\ u009F \\ s \ "'> \ \ / =] + (?: \\ s * = \\ s * (?: \ "[^ \"] *? \ "| '[^'] *? '| [^ \\ s \"' = <> `] +))?) * \\ s * \\ /?>", tagRe: new RegExp ("^ <(" + Patterns.htmlTagName + ")"), mediaTags: ["audio", "img" , "source", "track", "video"], nobrTags: ["audio", "colgroup", "datalist", "dl","figure", "meter", "ol", "optgroup", "picture", "progress", "ruby", "select", "table", "tbody", "tfoot", "thead", "tr "," ul "," video "], voidTags: [" area "," base "," br "," col "," embed "," hr "," img "," input "," keygen ", "link", "item de menu", "meta", "param", "fonte", "faixa", "wbr"], manipulador: função (e) {var t = this.tagRe.exec (e.matchText), r = t && t [1], n = r && r.toLowerCase (); if (n) {var a = this.voidTags.includes (n) || e.matchText.endsWith ("/>"), i = this.nobrTags .inclui (n), o = vazio 0, s = vazio 0; if (! a) {o = "<\\ /" + n + "\\ s *>"; var u = novo RegExp (o,"gim"); u.lastIndex = e.matchStart, s = u.exec (e.source)} if (! a &&! s) return throwError (e.output, "não consegue encontrar uma tag de fechamento para HTML <" + r + ">", e.matchText + "…"); var l = e.output, c = document.createElement (e.output.tagName), d = void 0; for (c.innerHTML = e.matchText; c.firstChild ;) c = c.firstChild; tente {this.processAttributeDirectives (c)} catch (t) {return throwError (e.output, "<" + n + ">:" + t.message, e.matchText + "…") } if (c.hasAttribute ("data-passage") && (this.processDataAttributes (c, n), Config.debug && (d = new DebugView (e.output, "html -" + n, n, e.matchText) , d.modes ({block: "img" === n, nonvoid: s}), l = d.output)), s) {try {Wikifier.Option.push ({nobr: i}), e. subWikify (c, o, {ignoreTerminatorCase:! 0})} finalmente {Wikifier.Option.pop ()} d && jQuery (c) .find (". debug.block "). length> 0 && d.modes ({block:! 0})} l.appendChild (" track "=== n? c.cloneNode (! 0): c)}}, processAttributeDirectives: function (e) { [] .concat (_toConsumableArray (e.attributes)). forEach (function (t) {var r = t.name, n = t.value, a = "@" === r [0]; if (a | | r.startsWith ("sc-eval:")) {var i = r.slice (a? 1: 8); if ("configurador de dados" === i) lançar novo Error ('diretiva de avaliação não é permitida no atributo configurador de dados: "'+ r +'" '); var o = void 0; tente {o = Scripting.evalTwineScript (n)} catch (e) {lance novo Erro (' avaliação ruim da diretiva de atributo "' + r + '":' + e.message)} try {e.setAttribute (i, o), e.removeAttribute (r)} catch (e) {throw new Error ('não pode transformar a diretiva de atributo"' + r + '" no atributo "'+ i +'" ')}}})}, processDataAttributes: function (e,t) {var r = e.getAttribute ("passagem de dados"); if (null! = r) {var n = Wikifier.helpers.evalPassageId (r); if (n! == r && (r = n, e .setAttribute ("data-passage", n)), ""! == r) if (this.mediaTags.includes (t)) {if ("data:"! == r.slice (0,5) && Story .has (r)) {r = Story.get (r); var a = void 0, i = void 0; switch (t) {case "audio": case "video": i = "Twine." + t ; break; case "img": i = "Twine.image"; break; case "track": i = "Twine.vtt"; break; case "source": var o = $ (e) .closest ("audio , imagem, vídeo "); o.length && (a = o.get (0) .tagName.toLowerCase (), i =" Twine. "+ (" imagem "=== a?" imagem ": a))} r.tags.includes (i) && (e ["imagem" === a? "srcset": "src"] = r.text.trim ())}} else {var s = e.getAttribute ("data -normatizador"),u = void 0; null! = s && ""! == (s = String (s) .trim ()) && (u = Wikifier.helpers.createShadowSetterCallback (Scripting.parse (s))), Story.has (r )? (e.classList.add ("link-interno"), Config.addVisitedLinkClass && State.hasPlayed (r) && e.classList.add ("link-visitado")): e.classList.add ("link-quebrado") , jQuery (e) .ariaClick ({one:! 0}, function () {"function" == typeof u && u.call (this), Engine.play (r)})}}}})} (); var Template = function () {function e (e, t) {if (! (S (t) || t instanceof Array && t.length> 0 && t.every (s))) throw new TypeError ("tipo de modelo inválido (" + e + "); os modelos devem ser: funções, strings ou uma matriz de"); (e instância de Array? e: [e]). forEach (função (e) {if (! o.test (e)) lançar novo Erro ('nome de modelo inválido "' + e + '"'); se (i.has (e)) throw new Error ("não é possível sobrepor o modelo existente?" + e); i.set (e, t)})} função t (e) {(e instanceof Array? e: [e]). forEach (função (e) {return i.delete (e)})} função r (e) {return i.has (e)? i.get (e): null} função n (e) {return i.has ( e)} função a () {return i.size} var i = new Map, o = new RegExp ("^ (?:" + Patterns.templateName + ") $"), s = function (e) {var t = void 0 === e? "undefined": _ typeof (e); return "function" === t || "string" === t}; return Object.freeze (Object.defineProperties ({}, {add: {value: e}, delete: {value: t}, get: {value: r}, has: {value: n}, size: {get: a}}))} (), Macro = function () { função e (t, r) {if (Array.isArray (t)) return void t.forEach (function (t) {return e (t, r)}); if (! f.test (t)) jogar novo Erro ('nome de macro inválido "' + t + '"'); if (n (t)) lançar novo Erro ("não pode eliminar macro existente <<"+ t +" >> "); if (u (t)) lançar um novo Error (" não é possível sobrepor a tag filho << "+ t +" >> da macro pai "+ (1 === d [t] .length? "": "s") + "<<" + d [t] .join (">>, <<") + ">>"); tente {if ("objeto" === (vazio 0 == = r? "undefined": _ typeof (r))) c [t] = Object.assign (Object.create (null), r, {_ MACRO_API:! 0}); else {if (! n (r)) jogue new Error ("não é possível criar um alias de macro inexistente <<" + r + ">>"); c [t] = Object.create (c [r], {_ ALIAS_OF: {enumerable:! 0, value: r}}) } Object.defineProperty (c, t, {gravável:! 1})} catch (e) {throw "TypeError" === e.name?new Error ("não é possível sobrepor a macro protegida <<" + t + ">>" ): novo erro ("erro desconhecido ao tentar adicionar macro <<" + t + ">>: [" + e.nome + "]" + e.message)} if (void 0! == c [t] .tags) if (null == c [t] .tags) o (t); else {if (! Array.isArray ( c [t] .tags)) lançar um novo Error ('valor ruim para a propriedade "tags" da macro <<' + t + ">>"); o (t, c [t] .tags)}} função t (e ) {if (Array.isArray (e)) return void e.forEach (function (e) {return t (e)}); if (n (e)) {void 0! == c [e] .tags && s ( e); tente {Object.defineProperty (c, e, {gravável:! 0}), exclua c [e]} catch (t) {throw new Error ("erro desconhecido removendo macro <<" + e + ">>: "+ t.message)}} else if (u (e)) throw new Error (" não é possível remover a tag filho << "+ e +" >> da macro pai << "+ d [e] +" >> ") } function r () {return 0 === Object.keys (c) .length} função n (e) {return c.hasOwnProperty (e)} função a (e) {var t = null; return n (e) && "função" == typeof c [e] .handler? t = c [e]:macros.hasOwnProperty (e) && "função" == tipo de macros [e] .handler && (t = macros [e]), t} função i () {var e = argumentos.length> 0 && argumentos [0]! == indefinido ? argumentos [0]: "init"; Object.keys (c) .forEach (function (t) {"function" == typeof c [t] [e] && c [t] [e] (t)}), Object.keys (macros) .forEach (function (t) {"function" == typeof macros [t] [e] && macros [t] [e] (t)})} function o (e, t) {if ( ! e) lançar um novo Erro ("nenhum pai especificado"); para (var r = ["/" + e, "fim" + e], a = []. concat (r, Array.isArray (t)? t : []), i = 0; i <a.length; ++ i) {var o = a [i]; if (n (o)) lançar novo Erro ("não é possível registrar a tag para uma macro existente"); u (o)? d [o] .inclui (e) || (d [o]. empurrar (e), d [o] .sort ()): d [o] = [e]}} função s ( e) {if (! e) lançar novo Error ("nenhum pai especificado"); Object.keys (d) .forEach (function (t) {var r = d [t].indexOf (e); - 1! == r && (1 === d [t] .length? delete d [t]: d [t] .splice (r, 1))})} função u (e) { return d.hasOwnProperty (e)} função l (e) {return u (e)? d [e]: null} var c = {}, d = {}, f = new RegExp ("^ (?:" + Patterns.macroName + ") $"); return Object.freeze (Object.defineProperties ({}, {add: {value: e}, delete: {value: t}, isEmpty: {value: r}, has: {value : n}, obter: {valor: a}, init: {valor: i}, tags: {valor: Object.freeze (Object.defineProperties ({}, {registrar: {valor: o}, cancelar o registro: {valor: s}, tem: {valor: u}, obter: {valor: l}}))}, evalStatements: {valor: função () {retornar Scripting.evalJavaScript.apply (Scripting, argumentos)}}}))} ( ), MacroContext = function () {return function () {function e (t) {_ classCallCheck (this, e); var r = Object.assign ({parent: null, macro: null, name: "", displayName: " ", args: null, payload: null, parser: null, source:" "}, t); if (null === r.macro ||" "=== r.name || null === r.parser) throw new TypeError ("objeto de contexto sem propriedades obrigatórias"); Object.defineProperties (this, {self: {value: r.macro}, name: {value : void 0 === r.macro._ALIAS_OF? r.name: r.macro._ALIAS_OF}, displayName: {value: r.name}, args: {value: r.args}, payload: {value: r. carga útil}, fonte: {valor: r.source}, pai: {valor: r.parent}, analisador: {valor: r.parser}, _ saída: {valor: r.parser.output}, _ sombras: {gravável: ! 0, valor: nulo}, _ debugView: {gravável:! 0, valor: nulo}, _ debugViewEnabled: {gravável:! 0, valor: Config.debug}})} return _createClass (e, [{chave: "contextHas" , valor: function (e) {for (var t = this; null! == (t = t.parent);) if (e (t)) return! 0; return! 1}}, {key: "contextSelect ", valor: function (e) {for (var t = this; null! == (t = t.parent);) if (e (t)) return t; return null}}, {key:" contextSelectAll " , valor: function (e) {for (var t = [], r = this; null! == (r = r.parent);) e (r) && t.push (r); retornar t}}, {chave: "addShadow", valor: function () {var e = this; this._shadows || (this._shadows = new Set); para (var t = new RegExp ("^" + Patterns.variable + "$"), r = argumentos.comprimento, n = Matriz (r), a = 0; a <r; a ++) n [a] = argumentos [a ]; n.flat (1/0) .forEach (function (r) {if ("string"! = typeof r) throw new TypeError ("o nome da variável deve ser uma string; digite:" + (vazio 0 === r? "indefinido": _ typeof (r))); if (! t.test (r)) lançar novo Erro ('nome de variável inválido "' + r + '"'); e._shadows.add (r)}) }}, {chave: "createShadowWrapper", value: function (e, t, r) {var n = this, a = void 0; return "function" == typeof e && (a = {}, this.shadowView.forEach (função (e) {var t = e.slice (1), r = "$" === e [0]? State.variables: State.temporary; a [e] = r [t]})), função () {para (var i = argumentos.comprimento, o = Matriz (i), s = 0;s <i; s ++) o [s] = argumentos [s]; if ("função" == tipo de r && r.apply (este, o), "função" == tipo de e) {var u = Object.keys (a ), l = u.length> 0? {}: null, c = Wikifier.Parser.get ("macro"), d = void 0; tente {u.forEach (function (e) {var t = e.slice (1), r = "$" === e [0]? State.variables: State.temporary; r.hasOwnProperty (t) && (l [t] = r [t]), r [t] = a [e]}), d = c.context, c.context = n, e.apply (this, o)} finalmente {d! == undefined && (c.context = d), u.forEach (function (e) {var t = e.slice (1), r = "$" === e [0]? State.variables: State.temporary; a [e] = r [t], l.hasOwnProperty (t)? r [t] = l [t]: excluir r [t]})}} "function" == typeof t && t.apply (this, o)}}}, {key: "createDebugView", value: function (e, t ) {return this._debugView = new DebugView (this._output, "macro", e || this.displayName, t || this.source), null! == this.payload && this.payload.length> 0 && this._debugView.modes ({nonvoid:! 0}), this._debugViewEnabled =! 0, this._debugView}}, {key: "removeDebugView", value: function () {null! == this._debugView && ( this._debugView.remove (), this._debugView = null), this._debugViewEnabled =! 1}}, {key: "error", value: function (e, t) {return throwError (this._output, "<< "+ this.displayName +" >>: "+ e, t || this.source)}}, {key:" output ", get: function () {return this._debugViewEnabled? this.debugView.output: this._output }}, {chave: "sombras", get: function () {return []. concat (_toConsumableArray (this._shadows))}}, {key: "shadowView", get: function () {var e = new Set ; retornar this.contextSelectAll (function (e) {return e._shadowsvalor: function () {null! == this._debugView && (this._debugView.remove (), this._debugView = null), this._debugViewEnabled =! 1}}, {key: "error", value: function (e , t) {return throwError (this._output, "<<" + this.displayName + ">>:" + e, t || this.source)}}, {key: "output", get: function () { retornar this._debugViewEnabled? this.debugView.output: this._output}}, {chave: "sombras", get: function () {return []. concat (_toConsumableArray (this._shadows))}}, {key: " shadowView ", get: function () {var e = new Set; return this.contextSelectAll (function (e) {return e._shadowsvalor: function () {null! == this._debugView && (this._debugView.remove (), this._debugView = null), this._debugViewEnabled =! 1}}, {key: "error", value: function (e , t) {return throwError (this._output, "<<" + this.displayName + ">>:" + e, t || this.source)}}, {key: "output", get: function () { retornar this._debugViewEnabled? this.debugView.output: this._output}}, {chave: "sombras", get: function () {return []. concat (_toConsumableArray (this._shadows))}}, {key: " shadowView ", get: function () {var e = new Set; return this.contextSelectAll (function (e) {return e._shadowst || this.source)}}, {key: "output", get: function () {return this._debugViewEnabled? this.debugView.output: this._output}}, {key: "sombras", get: function () {return []. concat (_toConsumableArray (this._shadows))}}, {key: "shadowView", get: function () {var e = new Set; return this.contextSelectAll (function (e) {return e ._shadowst || this.source)}}, {key: "output", get: function () {return this._debugViewEnabled? this.debugView.output: this._output}}, {key: "sombras", get: function () {return []. concat (_toConsumableArray (this._shadows))}}, {key: "shadowView", get: function () {var e = new Set; return this.contextSelectAll (function (e) {return e ._shadows
}). forEach (function (t) {return t._shadows.forEach (function (t) {return e.add (t)})}), []. concat (_toConsumableArray (e))}}, {chave: "debugView", get: function () {return this._debugViewEnabled? null! == this._debugView? this._debugView: this.createDebugView (): null}}]), e} ()} () ;! function ( ) {if (Macro.add ("capture", {skipArgs:! 0, tags: null, tsVarRe: new RegExp ("(" + Patterns.variable + ")", "g"), manipulador: function () {if (0 === this.args.raw.length) return this.error ("nenhuma história / lista de variável temporária especificada"); var e = {}; try {for (var t = this.self.tsVarRe, r = void 0; null! == (r = t.exec (this.args.raw));) {var n = r [1], a = n.slice (1), i = "$" === n [0]? State.variables: State.temporary; i.hasOwnProperty (a) && (e [a] = i [a]), this.addShadow (n)} novo Wikificador (this.output, this.payload [0 ]. conteúdos)} finalmente {this.shadows.forEach (function (t) {var r = t.slice (1), n ​​= "$" === t [0]? State.variables: State.temporary; e.hasOwnProperty (r)? n [r] = e [r]: delete n [r]}) }}}), Macro.add ("set", {skipArgs:! 0, handler: function () {if (0 === this.args.full.length) return this.error ("nenhuma expressão especificada") ; tente {Scripting.evalJavaScript (this.args.full)} catch (e) {return this.error ("avaliação ruim:" + ("objeto" === (void 0 === e? "undefined": _ typeof (e))? e.message: e))} Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("unset", {skipArgs:! 0, jsVarRe: new RegExp ("Estado \\. (Variáveis ​​| temporário) \\. (" + Patterns.identifier + ")", "g"), manipulador: function () {if (0 === this.args.full.length) return this.error ("nenhuma história / lista de variável temporária especificada"); for (var e = this.self.jsVarRe, t = void 0; null! == (t = e.exec (this.args.full));) {var r = State [t [1]], n = t [2]; r.hasOwnProperty (n) && delete r [n]} Config.debug && this.debugView.modes ({oculto:! 0})}}) , Macro.add ("lembrar", {skipArgs:! 0, jsVarRe: new RegExp ("Estado \\. Variáveis ​​\\. (" + Patterns.identifier + ")", "g"), handler: function () { if (0 === this.args.full.length) return this.error ("nenhuma expressão especificada"); tente {Scripting.evalJavaScript (this.args.full)} catch (e) {return this.error (" avaliação ruim: "+ (" objeto "=== (void 0 === e?" undefined ": _ typeof (e))? e.message: e))} for (var e = storage.get (" lembrar " ) || {}, t = this.self.jsVarRe, r = void 0; null! == (r = t.exec (this.args.full));) {var n = r [1]; e [ n] = State.variables [n]} if (! storage.set ("lembrar", e)) retornar this.error ("erro desconhecido, não consigo lembrar:" + this.args.raw); Config.debug && this.debugView.modes ({oculto:! 0})}, init: function () {var e = storage.get ("lembrar"); e && Object.keys (e) .forEach (function (t) {return State.variables [ t] = e [t]})}}), Macro.add ("esquecer", {skipArgs:! 0, jsVarRe: new RegExp ("Estado \\. variáveis ​​\\. (" + Patterns.identifier + ")" , "g"), manipulador: function () {if (0 === this.args.full.length) return this.error ("nenhuma lista de variáveis ​​de história especificada"); for (var e = storage.get (" lembre-se "), t = this.self.jsVarRe, r = void 0, n =! 1; null! == (r = t.exec (this.args.full));) {var a = r [1] ; State.variables.hasOwnProperty (a) && delete State.variables [a], e && e.hasOwnProperty (a) && (n =! 0, delete e [a])} if (n) if (0 === Object.keys (e) .length) {if (! storage.delete ("lembrar")) return this.error ("erro desconhecido, não é possível atualizar o armazenamento de lembretes")} else if (! storage.set ("lembrar ", e)) retornar this.error (" erro desconhecido, não é possível atualizar o armazenamento de lembretes "); Config.debug && this.debugView.modes ({oculto:! 0})}}), Macro.add (" executar "," set "), Macro.add (" script ", {skipArgs:! 0, tags: null, manipulador: function () {var e = document.createDocumentFragment (); tente {Scripting.evalJavaScript (this.payload [0]. conteúdo, e)} catch (e) {return this.error ("avaliação ruim:" + ("objeto" === (void 0 === e? "undefined": _ typeof (e))? e.message: e))} Config.debug && this.createDebugView (), e.hasChildNodes () && this.output.appendChild (e)}}), Macro.add ("incluir", {handler: function () {if (0 === this.args.length) return this.error ("nenhuma passagem especificada"); var e = void 0; if (e = "objeto" === _ typeof (this.args [0])? this.args [0] .link: this.args [0] ,! Story.has (e)) return this.error ('passagem "'+ e +'" não existe '); Config.debug && this.debugView.modes ({block:! 0}), e = Story.get (e); var t = void 0; t = this.args [ 1]? JQuery (document.createElement (this.args [1])). AddClass (e.domId + "macro -" + this.name) .attr ("data-passage", e.title) .appendTo (this. output): jQuery (this.output), t.wiki (e.processText ())}}), Macro.add ("nobr", {skipArgs:! 0, tags: null, handler: function () {novo Wikificador (this.output, this.payload [0] .contents.replace (/ ^ \ n + | \ n + $ / g, ""). replace (/ \ n + / g, ""))}}), Macro.add (["print", "=", "-"], {skipArgs:! 0, handler: function () {if (0 === this.args.full.length) return this.error ("nenhuma expressão especificada "); tente {var e = stringFrom (Scripting.evalJavaScript (this.args.full)); null! == e && novo Wikificador (this.output," - "=== this.name?Util.escape (e): e)} catch (e) {return this.error ("avaliação ruim:" + ("objeto" === (void 0 === e? "undefined": _ typeof (e))? e .mensagem: e))}}}), Macro.add ("silenciosamente", {skipArgs:! 0, tags: nulo, manipulador: função () {var e = document.createDocumentFragment (); if (novo Wikificador (e , this.payload [0] .contents.trim ()), Config.debug) this.debugView.modes ({block:! 0, hidden:! 0}), this.output.appendChild (e); else {var t = []. concat (_toConsumableArray (e.querySelectorAll (". error"))). map (function (e) {return e.textContent}); if (t.length> 0) return this.error ("error "+ (1 === t.length?" ":" S ") +" dentro do conteúdo ("+ t.join ("; ") +") ")}}}), Macro.add (" tipo " , {isAsync:! 0, tags: null, typeId: 0, handler: function () {if (0 === this.args.length) return this.error ("nenhuma velocidade especificada"); var e = Util.fromCssTime (this.args [0]); if (e <0) retornar this.error ("valor de tempo de velocidade deve ser não negativo (recebido:" + this.args [0] + ")"); para (var t = void 0, r = "", n = "", a = "div", i = Config.macros.typeSkipKey, o = 400, s = this.args.slice (1); s.length> 0; ) {var u = s.shift (); switch (u) {case "classe": if (0 === s.length) return this.error ("opção de classe sem nome (s) de classe obrigatório (s)"); se ("" === (r = s.shift ())) lançar novo Erro ('opção de classe nome (s) de classe deve (m) ser não vazio (recebido: "")'); quebra; case "elemento": se (0 === s.length) return this.error ("opção de elemento sem nome de tag de elemento obrigatório"); if ("" === (a = s.shift ())) lançar novo Error ('tag de opção de elemento o nome não deve estar vazio (recebido: "") '); break; case "id": if (0 === s.length) retorna isso.erro ("opção de id sem ID obrigatório"); if ("" === (n = s.shift ())) lançar novo Erro ('ID de opção de id não deve estar vazio (recebido: "")'); break; case "keep": t = "keep"; break; case "none": t = "none"; break; case "skipkey": if (0 === s.length) return this.error ("skipkey opção ausente do valor da chave obrigatório "); if (" "=== (i = s.shift ())) lançar novo erro ('o valor da chave da opção skipkey não deve estar vazio (recebido:" ")'); case "start": if (0 === s.length) retorna this.error ("opção de início sem valor de tempo necessário"); var l = s.shift (); if ((o = Util.fromCssTime (l) ) <0) lançar um novo erro ("o valor do tempo da opção inicial deve ser não negativo (recebido:" + l + ")"); quebrar; padrão: retornar este.error ("opção desconhecida:" + u)}} var c = this.payload [0].conteúdo; if (""! == c.trim ()) {Config.debug && this.debugView.modes ({block:! 0}); var d = "macro -" + this.name, f = "." + d, p = jQuery (document.createElement (a)). addClass (d + "" + d + "- target"). appendTo (this.output); TempState.macroTypeQueue || (TempState.macroTypeQueue = [], $ (document ) .off (f) .one (": passageinit" + f, function () {return $ (document) .off (f)})); var h = 0 === TempState.macroTypeQueue.length, g = + + this.self.typeId; TempState.macroTypeQueue.push ({id: g, handler: function () {var s = jQuery (document.createElement (a)). addClass (d); n && s.attr ("id", n), r && s.addClass (r), novo Wikificador (s, c); var u = State.passage, l = State.turns; if (! Config.macros.typeVisitedPassages && State.passages.slice (0, -1). some (function (e) {return e === u}) || s.find (". error"). length> 0) return p.replaceWith (s), TempState.macroTypeQueue.shift (), void (TempState.macroTypeQueue.length> 0 && TempState.macroTypeQueue.first (). handler ()); var h = new NodeTyper ({targetNode: s.get (0), classNames: "none" == = t? null: d + "- cursor"}); p.replaceWith (s); var m = "keydown" + f, v = ": typestop" + f; $ (document) .off (m) .on ( m, função (e) {Util.scrubEventKey (e.key)! == i || e.target! == document.body && e.target! == document.documentElement || (e.preventDefault (), $ (document ) .off (m), h.finish ())}). one (v, function () {TempState.macroTypeQueue && (0 === TempState.macroTypeQueue.length? jQuery.event.trigger (": typingcomplete"): TempState.macroTypeQueue.first (). Handler ())}); var y = function () {var r = function (e) {State.passage === u && State.turns === l && h.type () || ( e && clearInterval (e), TempState.macroTypeQueue && TempState.macroTypeQueue.length> 0 && TempState.macroTypeQueue.first (). id === g && TempState.macroTypeQueue.shift (), s.trigger (": typingstop"), s.addClass (d + "- done"), "keep" === t && s .addClass (d + "- cursor"))}; s.trigger (": typestart"), r (); var n = setInterval (function () {return r (n)}, e)}; o? setTimeout ( y, o): y ()}}), h && (Engine.isPlaying ()? $ (document) .one (": passageend" + f, function () {return TempState.macroTypeQueue.first (). handler () }): TempState.macroTypeQueue.first (). Handler ())}}}), Macro.add ("display", "include"), Macro.add ("if", {skipArgs:! 0, tags: [ "elseif", "else"], elseifWsRe: / ^ \ s * if \ b / i, ifAssignRe: / [^! = & ^ | <> * /% + -] = [^ =>] /, manipulador: function () {var e = void 0; tente {var t = this.payload.length, r = this.self.elseifWsRe, n = this.self.ifAssignRe; for (e = 0; e <t;++ e) switch (this.payload [e] .name) {case "else": if (this.payload [e] .args.raw.length> 0) retorna r.test (this.payload [e]. args.raw)? this.error ('espaços em branco não são permitidos entre "else" e "if" na cláusula <<elseif>>' + (e> 0? "(#" + e + ")": "") ): this.error ("<<else>> não aceita uma expressão condicional (talvez você quisesse usar <<elseif>>), inválido:" + this.payload [e] .args.raw); if (e +1! == t) return this.error ("<<else>> deve ser a cláusula final"); break; default: if (0 === this.payload [e] .args.full.length) return this.error ("nenhuma expressão condicional especificada para <<" + this.payload [e] .name + ">> cláusula" + (e> 0? "(#" + e + ")": "")); if ( Config.macros.ifAssignmentError && n.test (this.payload [e] .args.full)) return this.error ("operador de atribuição encontrado em <<" + this.payload [e] .name + ">> cláusula" + (e> 0? "(# "+ e +") ":" ") +" (talvez você quisesse usar um operador de igualdade: ==, ===, eq, é), inválido: "+ this.payload [e] .args.raw)} var a = Scripting.evalJavaScript, i =! 1; for (e = 0; e <t; ++ e) {if (Config.debug && this.createDebugView (this.payload [e] .name, this.payload [e] .source) .modes ({nonvoid:! 1}), "else" === this.payload [e] .name || a (this.payload [e] .args.full)) {i =! 0, novo Wikificador (this.output, this.payload [e] .contents); break} Config.debug && this.debugView.modes ({hidden:! 0, invalid:! 0})} if (Config.debug) {for (+ + e; e <t; ++ e) this.createDebugView (this.payload [e] .name, this.payload [e] .source) .modes ({nonvoid:! 1, oculto:! 0, inválido :! 0}); this.createDebugView ("/"+this.name,"<</"+this.name+">>").modes({nonvoid:!1,hidden:!i,invalid:!i})}}catch(t){return this .error ("má expressão condicional em <<" + (0 === e? "if": "elseif") + ">> cláusula" + (e> 0? "(#" + e + ")": " ") +": "+ (" objeto "=== (void 0 === t?" undefined ": _ typeof (t))? t.message: t))}}}), Macro.add (" switch ", {skipArgs: [" switch "], tags: [" case "," default "], handler: function () {if (0 === this.args.full.length) return this.error (" não expressão especificada "); var e = this.payload.length; if (1 === e) retornar this.error (" nenhum caso especificado "); var t = void 0; para (t = 1; t <e; ++ t) switch (this.payload [t] .name) {case "default": if (this.payload [t] .args.length> 0) return this.error ("<<default>> não aceita valores, inválido: "+ this.payload [t] .args.raw); if (t + 1! == e) return this.error (" <<default>> deve ser o final case "); break; padrão: if (0 === this.payload [t] .args.length) retorna this.error (" nenhum valor (es) especificado (s) para << "+ this.payload [t] .name + ">> (#" + t + ")")} var r = void 0; tente {r = Scripting.evalJavaScript (this.args.full)} catch (e) {return this.error ("avaliação ruim:" + ("objeto" === (void 0 === e? "undefined": _ typeof (e))? e.message: e))} var n = this.debugView, a =! 1; for (Config.debug && n .modes ({nonvoid:! 1, hidden:! 0}), t = 1; t <e; ++ t) {if (Config.debug && this.createDebugView (this.payload [t] .name, this.payload [ t] .source) .modes ({nonvoid:! 1}), "default" === this.payload [t] .name || this.payload [t] .args.some (function (e) {return e === r})) {a =! 0, novo Wikificador (this.output, this.payload [t] .contents); break} Config.debug && this.debugView.modes ({ oculto:! 0, inválido:! 0})} if (Config.debug) {para (++ t; t <e; ++ t) this.createDebugView (this.payload [t] .name, this.payload [ t] .source) .modes ({nonvoid:! 1, hidden:! 0, invalid:! 0}); n.modes ({nonvoid:! 1, hidden:! 0, invalid:! a}), this. createDebugView ("/" + this.name, "<< /" + this.name + ">>"). modes ({nonvoid:! 1, hidden:! 0, invalid:! a})}}}), Macro .add ("para", {skipArgs:! 0, tags: null, hasRangeRe: novo RegExp ("^ \\ S" + Patterns.anyChar + "*? \\ s + range \\ s + \\ S" + Padrões. anyChar + "*? $"), rangeRe: new RegExp ("^ (?: Estado \\. (variáveis ​​| temporário) \\. (" + Patterns.identifier + ") \\ s *, \\ s *)? Estado \\. (variáveis ​​| temporário) \\. ("+ Patterns.identifier +") \\ s + range \\ s + (\\ S "+ Patterns.anyChar + "*?) $"), ThreePartRe: / ^ ([^;] *?) \ S *; \ s * ([^;] *?) \ S *; \ s * ([^; ] *?) $ /, forInRe: / ^ \ S + \ s + in \ s + \ S + / i, forOfRe: / ^ \ S + \ s + of \ s + \ S + / i, manipulador: função () {var e = this.args.full.trim (), t = this.payload [0] .contents.replace (/ \ n $ /, ""); if (0 === e.length) this.self.handleFor.call (this, t, null,! 0, null); else if (this.self.hasRangeRe.test (e)) {var r = e.match (this.self.rangeRe); if (null === r) retornar this.error ("sintaxe de formulário de intervalo inválido, formato: [índice,] coleção de intervalo de valor"); this.self.handleForRange.call (this, t, {type: r [1], name: r [2]} , {tipo: r [3], nome: r [4]}, r [5])} else {var n = vazio 0, a = vazio 0, i = vazio 0; if (-1 === e. indexOf (";")) {if (this.self.forInRe.test (e)) return this.error ("sintaxe inválida, para ... em não é suportado; consulte: para ... intervalo"); if (this.self .forOfRe.test (e)) return this.error ("sintaxe inválida, para ... de não é suportada;consulte: para… intervalo "); a = e} else {var o = e.match (this.self.threePartRe); if (null === o) retorna this.error (" sintaxe de forma condicional de 3 partes inválida, formato: [init]; [condição]; [post] "); n = o [1], a = o [2] .trim (), i = o [3], 0 === a.length && (a =! 0)} this.self.handleFor.call (this, t, n, a, i)}}, handleFor: function (e, t, r, n) {var a = Scripting.evalJavaScript, i =! 0 , o = Config.macros.maxLoopIterations; Config.debug && this.debugView.modes ({block:! 0}); try {if (TempState.break = null, t) try {a (t)} catch (e) {return this.error ("expressão inicial incorreta:" + ("objeto" === (void 0 === e? "undefined": _ typeof (e))? e.message: e))} for (; a (r );) {if (- o <0) return this.error ("excedeu as iterações máximas configuradas do loop (" + Config.macros.maxLoopIterations + ")"); if (novo Wikificador (this.output, i? e.replace (/ ^ \ n /, ""): e), i && (i =! 1), nulo!= TempState.break) if (1 === TempState.break) TempState.break = null; else if (2 === TempState.break) {TempState.break = null; break} if (n) tente {a (n )} catch (e) {return this.error ("bad post expression:" + ("object" === (void 0 === e? "undefined": _ typeof (e))? e.message: e) )}}} catch (e) {return this.error ("má expressão condicional:" + ("objeto" === (void 0 === e? "undefined": _ typeof (e))? e.message: e))} finalmente {TempState.break = null}}, handleForRange: function (e, t, r, n) {var a =! 0, i = void 0; tente {i = this.self.toRangeList (n) } catch (e) {return this.error (e.message)} Config.debug && this.debugView.modes ({block:! 0}); try {TempState.break = null; for (var o = 0; o <i .length; ++ o) if (t.name && (State [t.type] [t.name] = i [o] [0]), State [r.type] [r.name] = i [o] [1], novo Wikificador (this.output, a? E.replace (/ ^ \ n /, ""): e), a && (a =! 1), nulo!= TempState.break) if (1 === TempState.break) TempState.break = null; else if (2 === TempState.break) {TempState.break = null; break}} catch (e) {retornar isso. error ("object" === (void 0 === e? "undefined": _ typeof (e))? e.message: e)} finalmente {TempState.break = null}}, toRangeList: function (e) { var t = Scripting.evalJavaScript, r = void 0; tente {r = t ("{" === e [0]? "(" + e + ")": e)} catch (e) {if ("objeto "! == (void 0 === e?" undefined ": _ typeof (e))) throw new Error (" expressão de intervalo ruim: "+ e); lance e.message =" expressão de intervalo ruim: "+ e. mensagem, e} var n = void 0; switch (void 0 === r? "undefined": _ typeof (r)) {case "string": n = []; for (var a = 0; a <r. comprimento;) {var i = Util.charAndPosAt (r, a); n.push ([a, i.char]), a = 1 + i.end} quebra; case "objeto": if (Array.isArray ( r)) n = r.map (função (e, t) {return [t, e]});else if (r instanceof Set) n = []. concat (_toConsumableArray (r)). map (function (e, t) {return [t, e]}); else if (r instanceof Map) n = []. concat (_toConsumableArray (r.entries ())); else {if ("Object"! == Util.toStringTag (r)) lança novo Error ("tipo de expressão de intervalo não suportado:" + Util.toStringTag (r)); n = Object.keys (r) .map (function (e) {return [e, r [e]]})} break; default: throw new Error ("tipo de expressão de intervalo não suportado:" + (void 0 === r ? "undefined": _ typeof (r)))} return n}}), Macro.add (["break", "continue"], {skipArgs:! 0, handler: function () {if (! this.contextHas (function (e) {return "for" === e.name})) return this.error ("só deve ser usado em conjunto com sua macro pai <<for>>"); TempState.break = "continue" === this.name?1:2,Config.debug&&this.debugView.modes({hidden:!0})}}}),Macro.add (["botão", "link"], {isAsync:! 0, tags: nulo, manipulador: função () {var e = this; if (0 === this.args.length) return this.error ( "no" + ("botão" === this.name?"button":"link")+ "texto especificado"); var t = jQuery (document.createElement ("botão" === this.name? " botão ":" a ")), r = void 0; if (" objeto "=== _ tipo (this.args [0])) if (this.args [0] .isImage) {var n = jQuery (documento .createElement ("img")). attr ("src", this.args [0] .source) .appendTo (t); this.args [0] .hasOwnProperty ("passage") && n.attr ("data- passagem ", this.args [0] .passage), this.args [0] .hasOwnProperty (" título ") && n.attr (" título ", this.args [0] .title), this.args [0] .hasOwnProperty ("alinhar") && n.attr ("alinhar", this.args [0] .align),r = this.args [0] .link} else t.append (document.createTextNode (this.args [0] .text)), r = this.args [0] .link; else t.wikiWithOptions ({profile: "core"}, this.args [0]), r = this.args.length> 1? this.args [1]: undefined; null! = r? (t.attr ("passagem de dados", r) , Story.has (r)? (T.addClass ("link-interno"), Config.addVisitedLinkClass && State.hasPlayed (r) && t.addClass ("link-visitado")): t.addClass ("link-quebrado") ): t.addClass ("link-internal"), t.addClass ("macro -" + this.name) .ariaClick ({namespace: ". macros", one: null! = r}, this.createShadowWrapper (" "! == this.payload [0] .contents? function () {return Wikifier.wikifyEval (e.payload [0] .contents.trim ())}: null, null! = r? function () {return Engine .play (r)}: null)). appendTo (this.output)}}), Macro.add ("checkbox", {isAsync:! 0, handler: function () {if (this.args.length <3) {var e = []; retornar this.args.length <1 && e.push ("nome da variável"), this.args.length <2 && e.push ("valor não verificado"), this.args. comprimento <3 && e.push ("valor verificado"), this.error ("não" + e.join ("ou") + "especificado")} if ("string"! = typeof this.args [0]) return this.error ("o argumento do nome da variável não é uma string"); var t = this.args [0] .trim (); if ("$"! == t [0] && "_"! == t [ 0]) retornar this.error ('nome da variável "' + this.args [0] + '" está sem seu sigilo ($ ou _)'); var r = Util.slugify (t), n = this.args [1], a = this.args [2], i = document.createElement ("input"); switch (jQuery (i) .attr ({id: this.name + "-" + r, nome: this.name + "-" + r, digite: "checkbox", tabindex: 0}). addClass ("macro-"+ this.name) .on ("change.macros", this.createShadowWrapper (function () {State.setVar (t, this.checked? a: n)})). appendTo (this.output), this.args [3]) {case "autocheck": State.getVar (t) === a? I.checked =! 0: State.setVar (t, n); break; case "verificado": i.checked =! 0 , State.setVar (t, a); break; padrão: State.setVar (t, n)}}}), Macro.add (["ciclo", "caixa de listagem"], {isAsync:! 0, skipArgs: [ "optionsfrom"], tags: ["option", "optionsfrom"], manipulador: function () {var e = this; if (0 === this.args.length) retornar this.error ("nenhum nome de variável especificado "); if (" string "! = typeof this.args [0]) retorna this.error (" argumento do nome da variável não é uma string "); var t = this.args [0] .trim (); if ( "$"! == t [0] && "_"! == t [0]) retorna this.error ('nome da variável "' + this.args [0] + '"está faltando seu sigilo ($ ou _) '); var r = Util.slugify (t), n = this.payload.length; if (1 === n) retorna this.error ("nenhuma opção especificada"); for (var a = this.args.length> 1 && "autoselect" === this.args [1], i = [], o = {option: 0, optionsfrom: 0}, s = -1, u = 1 ; u <n; ++ u) {var l = this.payload [u]; if ("opção" === l.name) {if (++ o.option, 0 === l.args.length ) retorna this.error ("nenhum argumento especificado para <<" + l.name + ">> (#" + o.option + ")"); if (i.push ({label: String (l.args [0] ), valor: 1 === l.args.length? l.args [0]: l.args [1]}), l.args.length> 2 && "selecionado" === l.args [2]) {if (a) return this.error ("não é possível especificar a seleção automática e as palavras-chave selecionadas"); if (-1! == s) return this.error ("várias palavras-chave selecionadas especificadas para <<" + l.name + " >> (# "+ (s + 1) +"  "+ o.option +") "); s = i.length-1}} else {var c = function () {if (++ o.optionsfrom, 0 === l.args.full.length) return {v: e.error ("nenhuma expressão especificada para <<" + l.name + ">> (#" + o.optionsfrom + ")")}; var t = void 0; tente {var r = l.args. full; t = Scripting.evalJavaScript ("{" === r [0]? "(" + r + ")": r)} catch (t) {return {v: e.error ("avaliação ruim:" + ("objeto" === (vazio 0 === t? "indefinido": _ typeof (t))? t.message: t))}} if ("objeto"! == (vazio 0 === t? "undefined": _ typeof (t)) || null === t) return {v: e.error ("expression deve produzir uma coleção com suporte ou objeto genérico (type:" + (null === t? "null" : void 0 === t? "undefined": _ typeof (t)) + ")")}; if (t instanceof Array || t instanceof Set) t.forEach (function (e) {return i.push ({ rótulo: String (e), valor:e})}); else if (t instanceof Map) t.forEach (function (e, t) {return i.push ({label: String (t), value: e})}); else {var n = Util.toStringTag (t); if ("Objeto"! == n) return {v: e.error ("a expressão deve produzir uma coleção com suporte ou objeto genérico (tipo de objeto:" + n + ")")}; Objeto. keys (t) .forEach (function (e) {return i.push ({label: e, value: t [e]})})}} (); if ("objeto" === (void 0 == = c? "undefined": _ typeof (c))) return cv}} if (-1 === s) if (a) {var d = Util.sameValueZero, f = State.getVar (t), p = i .findIndex (function (e) {return d (e.value, f)}); s = -1 === p? 0: p} else s = 0; if ("ciclo" === this.name) {var h = s; jQuery (document.createElement ("a")). wikiWithOptions ({profile: "core"}, i [s] .label) .attr ("id", this.name + "-" + r ) .addClass ("macro -" + this.name) .ariaClick ({namespace: ". macros"}, isso.createShadowWrapper (function () {h = (h + 1)% i.length, $ (this) .empty (). wikiWithOptions ({profile: "core"}, i [h] .label), State.setVar (t , i [h] .value)})). appendTo (this.output)} else {var g = jQuery (document.createElement ("select")); i.forEach (function (e, t) {jQuery (document .createElement ("opção")). val (t) .text (e.label) .appendTo (g)}), g.attr ({id: this.name + "-" + r, nome: this.name + " - "+ r, tabindex: 0}). addClass (" macro - "+ this.name) .val (s) .on (" change.macros ", this.createShadowWrapper (function () {State.setVar (t, i [Number (this.value)]. value)})). appendTo (this.output)} State.setVar (t, i [s] .value)}}), Macro.add (["linkappend", " linkprepend "," linkreplace "], {isAsync:! 0, tags: null, t8nRe: / ^ (?: transição | t8n) $ /, handler: function () {var e = this; if (0 === this .args.length) return this.error ("nenhum texto de link especificado "); var t = jQuery (document.createElement (" a ")), r = jQuery (document.createElement (" span ")), n = this.args.length> 1 && this.self.t8nRe. test (this.args [1]); t.wikiWithOptions ({profile: "core"}, this.args [0]). addClass ("macro link-internal -" + this.name) .ariaClick ({namespace: ".macros", um:! 0}, this.createShadowWrapper (function () {if ("linkreplace" === e.name?t.remove():t.wrap('<span class = "macro- ' + e.name + '"> </span>') .replaceWith (function () {return t.html ()})," "! == e.payload [0] .contents) {var a = document.createDocumentFragment (); novo Wikificador (a, e.payload [0] .contents), r.append (a)} n && setTimeout (function () {return r.removeClass ("macro -" + e.name + "- in")} , Engine.minDomActionDelay)})). AppendTo (this.output), r.addClass ("macro -" + this.name + "- insert"), n && r.addClass ("macro -" + this.name + "- in"), "linkprepend" === this.name?r.insertBefore(t) : r.insertAfter (t)}}), Macro.add (["numberbox", "textbox"], {isAsync:! 0, handler: function () {if (this.args.length <2) {var e = []; retornar this.args.length <1 && e.push ("nome da variável"), this.args.length <2 && e.push ("valor padrão"), this.error ("não" + e.join (" ou ") +" especificado ")} if (" string "! = typeof this.args [0]) return this.error (" argumento do nome da variável não é uma string "); var t = this.args [0]. trim (); if ("$"! == t [0] && "_"! == t [0]) retorna this.error ('nome da variável "' + this.args [0] + '" está faltando seu sigilo ($ ou _) '); Config.debug &&this.debugView.modes ({block:! 0}); var r = "numberbox" === this.name, n = r? Número (this.args [1]): this.args [1]; if ( r && Number.isNaN (n)) retorna this.error ('valor padrão "' + this.args [1] + '" não é um número nem pode ser analisado em um número'); var a = Util.slugify (t ), i = document.createElement ("input"), o =! 1, s = void 0; this.args.length> 3? (s = this.args [2], o = "autofocus" === this .args [3]): this.args.length> 2 && ("autofocus" === this.args [2]? o =! 0: s = this.args [2]), "objeto" === ( void 0 === s? "undefined": _ typeof (s)) && (s = s.link), jQuery (i) .attr ({id: this.name + "-" + a, name: this.name + " - "+ a, digite: r?" número ":" text ", tabindex: 0}). addClass (" macro - "+ this.name) .on (" change.macros ", this.createShadowWrapper (function () {Estado.setVar (t, r? Number (this.value): this.value)})). on ("keypress.macros", this.createShadowWrapper (function (e) {13 === e.which && (e.preventDefault ( ), State.setVar (t, r? Number (this.value): this.value), null! = S && Engine.play (s))})). AppendTo (this.output), r && (i.step = " qualquer "), State.setVar (t, n), i.value = n, o && (i.setAttribute (" autofocus "," autofocus "), postdisplay [" # autofocus: "+ i.id] = function (e ) {delete postdisplay [e], setTimeout (function () {return i.focus ()}, Engine.minDomActionDelay)})}}), Macro.add ("radiobutton", {isAsync:! 0, handler: function ( ) {if (this.args.length <2) {var e = []; retornar this.args.length <1 && e.push ("nome da variável"), this.args.length <2 && e.push ("valor verificado" ), this.error ("não" + e.join ("ou") + "especificado")} if ("string"! = typeof this.args [0]) retorna this.error ("argumento do nome da variável não é uma string"); var t = this.args [0] .trim (); if (" $ "! == t [0] &&" _ "! == t [0]) return this.error ('variable name"' + this.args [0] + '"está faltando seu sigilo ($ ou _) '); var r = Util.slugify (t), n = this.args [1], a = document.createElement ("input"); switch (TempState.hasOwnProperty (this.name) || (TempState [this. nome] = {}), TempState [this.name] .hasOwnProperty (r) || (TempState [this.name] [r] = 0), jQuery (a) .attr ({id: this.name + "-" + r + "-" + TempState [this.name] [r] ++, name: this.name + "-" + r, digite: "radio", tabindex: 0}). addClass ("macro -" + this. name) .on ("change.macros", this.createShadowWrapper (function () {this.checked && State.setVar (t, n)})). appendTo (this.output), this.args [2]) {case "autocheck": State.getVar (t) === n && (a.checked =! 0); break; case "verificado": a.checked =! 0, State.setVar (t, n)}}}), Macro.add ("textarea", {isAsync:! 0, manipulador: function () {if (this.args.length <2) {var e = []; retornar this.args.length <1 && e.push ("nome da variável"), this.args.length <2 && e.push ("valor padrão"), this.error ("no" + e.join ("ou") + "especificado")} se ("string"! = typeof this.args [0]) return this.error ("argumento do nome da variável não é uma string"); var t = this.args [0] .trim (); if ("$"! == t [0] && "_"! == t [0]) return this.error ('nome da variável "' + this.args [0] + '" está faltando seu sigilo ($ ou _)'); Config.debug && this.debugView.modes ({bloco:! 0}); var r = Util.slugify (t), n = this.args [1], a = "autofocus "=== this.args [2], i = document.createElement (" textarea "); jQuery (i) .attr ({id: this.name +" - "+ r, nome: this.name +" - " + r, linhas: 4, tabindex: 0}). addClass ("macro -" + this.name) .on ("change.macros", this.createShadowWrapper (function () {State.setVar (t, this.value )})). appendTo (this.output), State.setVar (t, n), i.textContent = n, a && (i.setAttribute ("autofocus", "autofocus"), postdisplay ["# autofocus:" + i.id] = function (e) {delete postdisplay [e], setTimeout (function () {return i.focus ()}, Engine.minDomActionDelay)})}}), Macro.add ("clique", "link "), Macro.add (" actions ", {handler: function () {for (var e = jQuery (document.createElement (" ul ")). AddClass (this.name) .appendTo (this.output), t = 0; t <this.args.length; ++ t) {var r = vazio 0, n = vazio 0, a = vazio 0, i = vazio 0; "objeto "=== _ typeof (this.args [t])? this.args [t] .isImage? (a = jQuery (document.createElement (" img ")). attr (" src ", this.args [t ] .source), this.args [t] .hasOwnProperty ("passage") && a.attr ("data-passage", this.args [t] .passage), this.args [t] .hasOwnProperty ("title" ) && a.attr ("título", this.args [t] .title), this.args [t] .hasOwnProperty ("alinhar") && a.attr ("alinhar", this.args [t] .align), r = this.args [t] .link, i = this.args [t] .setFn) :( n = this.args [t] .text, r = this.args [t] .link, i = this. args [t] .setFn): n = r = this.args [t], State.variables.hasOwnProperty ("# ​​ações") && State.variables ["# ações"]. hasOwnProperty (r) && State.variables ["# ações "] [r] || jQuery (Wikifier.createInternalLink (jQuery (document.createElement (" li ")). appendTo (e), r, null,function (e, t) {return function () {State.variables.hasOwnProperty ("# ​​actions") || (State.variables ["# actions"] = {}), State.variables ["# actions"] [ e] =! 0, "função" == typeof t && t ()}} (r, i))). addClass ("macro -" + this.name) .append (a || document.createTextNode (n))} }}), Macro.add (["back", "return"], {handler: function () {if (this.args.length> 1) return this.error ("muitos argumentos especificados, verifique a documentação para detalhes "); var e = -1, t = vazio 0, r = vazio 0, n = vazio 0; if (1 === this.args.length && (" objeto "=== _ tipo de (this.args [0 ])? this.args [0] .isImage? (n = jQuery (document.createElement ("img")). attr ("src", this.args [0] .source), this.args [0]. hasOwnProperty ("passage") && n.attr ("data-passage", this.args [0] .passage), this.args [0].hasOwnProperty ("title") && n.attr ("title", this.args [0] .title), this.args [0] .hasOwnProperty ("align") && n.attr ("align", this.args [0 ] .align), this.args [0] .hasOwnProperty ("link") && (t = this.args [0] .link)): 1 === this.args [0] .count? t = this. args [0] .link: (r = this.args [0] .text, t = this.args [0] .link): 1 === this.args.length && (r = this.args [0]) ), nulo == t) {for (var a = State.length-2; a> = 0; - a) if (State.history [a] .title! == State.passage) {e = a, t = State.history [a] .title; break} if (null == t && "return" === this.name) for (var i = State.expired.length-1; i> = 0; - i ) if (State.expired [i]! == State.passage) {t = State.expired [i]; break}} else {if (! Story.has (t)) return this.error ('passage "' + t + '"não existe'); if (" voltar "=== this.name) {for (var o = State.length-2; o> = 0;--o) if (State.history [o] .title === t) {e = o; break} if (-1 === e) return this.error ('não é possível encontrar a passagem "' + t + '" no histórico da história atual ')}} if (null == t) return this.error ("não é possível encontrar a passagem"); var s = void 0; s = "voltar"! == this.name || -1! == e? jQuery (document.createElement ("a")). addClass ("link-internal"). ariaClick ({one:! 0}, "return" === this.name?function(){return Engine .play (t)}: function () {return Engine.goTo (e)}): jQuery (document.createElement ("span")). addClass ("link-disabled"), s.addClass ("macro-" + this.name) .append (n || document.createTextNode (r || L10n.get ("macro" + this.name.toUpperFirst () + "Text"))). appendTo (this.output)}}) , Macro.add ("escolha", {manipulador: função () {if (0 === this.args.length) return this.error ("nenhuma passagem especificada");var e = State.passage, t = void 0, r = void 0, n = void 0, a = void 0; if (1 === this.args.length? "objeto" === _ typeof (this.args [0])? This.args [0] .isImage? (N = jQuery (document.createElement ("img")). Attr ("src", this.args [0] .source), this.args [0 ] .hasOwnProperty ("passage") && n.attr ("data-passage", this.args [0] .passage), this.args [0] .hasOwnProperty ("title") && n.attr ("title", this .args [0] .title), this.args [0] .hasOwnProperty ("alinhar") && n.attr ("alinhar", this.args [0] .align), t = this.args [0] .link , a = this.args [0] .setFn) :( r = this.args [0] .text, t = this.args [0] .link, a = this.args [0] .setFn): r = t = this.args [0] :( t = this.args [0], r = this.args [1]), State.variables.hasOwnProperty ("# ​​escolha") && State.variables ["# escolha"]. hasOwnProperty (e) && State.variables ["#choice "] [e]) return void jQuery (document.createElement (" span ")). addClass (" macro com link desativado - "+ this.name) .attr (" tabindex ", - 1) .append (n || document.createTextNode (r)). appendTo (this.output); jQuery (Wikifier.createInternalLink (this.output, t, null, function () {State.variables.hasOwnProperty ("# ​​choice") || (State .variables ["# choice"] = {}), State.variables ["# choice"] [e] =! 0, "function" == typeof a && a ()})). addClass ("macro -" + this .name) .append (n || document.createTextNode (r))}}), Macro.add (["addclass", "toggleclass"], {handler: function () {if (this.args.length <2 ) {var e = []; retornar this.args.length <1 && e.push ("seletor"), this.args.length <2 && e.push ("nomes de classe"), this.error ("não" + e. junte-se ("ou") + "especificado ")} var t = jQuery (this.args [0]); if (0 === t.length) retorna this.error ('nenhum elemento corresponde ao seletor"' + this.args [0] + '" '); switch (this.name) {case "addclass": t.addClass (this.args [1] .trim ()); break; case "toggleclass": t.toggleClass (this.args [1] .trim ())} Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("removeclass", {handler: function () {if (0 === this.args.length) return this.error ("nenhum seletor especificado"); var e = jQuery (this.args [0]); if (0 === e.length) return this.error ('nenhum elemento corresponde ao seletor "' + this .args [0] + '"'); this.args.length> 1? e.removeClass (this.args [1] .trim ()): e.removeClass (), Config.debug && this.debugView.modes ({ oculto:! 0})}}), Macro.add ("copiar", {handler: function () {if (0 === this.args.length) retornar isso.erro ("nenhum seletor especificado"); var e = jQuery (this.args [0]); if (0 === e.length) retorna this.error ('nenhum elemento corresponde ao seletor "' + this.args [ 0] + '"'); jQuery (this.output) .append (e.html ()), Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ([" anexar "," prefixar "," substituir "], {tags: null, t8nRe: / ^ (?: transição | t8n) $ /, manipulador: função () {var e = this; if (0 === this.args .length) return this.error ("nenhum seletor especificado"); var t = jQuery (this.args [0]); if (0 === t.length) return this.error ('nenhum elemento corresponde ao seletor " '+ this.args [0] +' "'); if (" "! == this.payload [0] .contents) {var r = this.args.length> 1 && this.self.t8nRe.test (this. args [1]), n = void 0; switch (r? (n = jQuery (document.createElement ("span")), n.addClass ("macro -" + this.name + "- inserir macro -" + this.name + "- in"), setTimeout (function () {return n.removeClass ("macro -" + e.name + "- in")}, Engine.minDomActionDelay)): n = jQuery (document.createDocumentFragment ()), n.wiki (this.payload [0] .contents),
this.name) {case "substituir": t.empty (); case "append": t.append (n); break; case "prefixar": t.prepend (n)}} else "substituir" === this.name && t.empty (); Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("remover", {handler: function () {if (0 === this. args.length) return this.error ("nenhum seletor especificado"); var e = jQuery (this.args [0]); if (0 === e.length) return this.error ('nenhum elemento corresponde ao seletor "'+ this.args [0] +'" '); e.remove (), Config.debug && this.debugView.modes ({oculto:! 0})}}), Has.audio) {var e = function ( e, t) {return'apenas uma ação de reprodução permitida por invocação, "'+ e +'" não pode ser combinada com "'+ t +'" '}; Macro.add ("audio", {handler: function () {if (this.args.length <2) {var t = []; retornar this.args.length <1 && t.push ("IDs de faixa e / ou grupo"), this.args.length <2 && t.push ("ações"), this.error ("não" + t.join ("ou") + "especificado") } var r = void 0; tente {r = SimpleAudio.select (this.args [0])} catch (e) {return this.error (e.message)} para (var n = this.args.slice (1 ), a = vazio 0, i = 5, o = vazio 0, s = vazio 0, u = vazio 0, l = vazio 0, c = vazio 0, d = vazio 0; n.length> 0;) {var f = n.shift (), p = void 0; switch (f) {case "load": case "pause": case "play": case "stop": case "unload": if (a) retorna isto. erro (e (f, a)); a = f; quebra; caso "fadein": if (a) retorna this.error (e (f, a)); a = "fade", o = 1; quebra; case "fadeout": if (a) return this.error (e (f, a)); a = "fade", o = 0; break; case "fadeto": if (a) return this.error (e ( f, a)); if (0 === n.length) return this.error ("fadeto falta do valor de nível obrigatório "); if (a =" fade ", p = n.shift (), o = Number.parseFloat (p), Number.isNaN (o) ||! Number.isFinite (o)) return this.error ("não é possível analisar fadeto:" + p); quebra; case "fadeoverto": if (a) retorna this.error (e (f, a)); if (n.length <2) {var h = []; retornar n.length <1 && h.push ("segundos"), n.length <2 && h.push ("nível"), this.error ("fadeoverto ausente obrigatório" + h.join ("e") + " valor "+ (h.length> 1?" s ":" "))} if (a =" fade ", p = n.shift (), i = Number.parseFloat (p), Number.isNaN (i) ||! Number.isFinite (i)) return this.error ("não é possível analisar fadeoverto:" + p); if (p = n.shift (), o = Number.parseFloat (p), Number.isNaN (o) ||! Number.isFinite (o)) return this.error ("não pode analisar fadeoverto:" + p); break; case "volume": if (0 === n.comprimento) retornar this.error ("volume sem valor de nível obrigatório"); if (p = n.shift (), d = Number.parseFloat (p), Number.isNaN (d) ||! Number.isFinite (d) ) return this.error ("não é possível analisar o volume:" + p); break; case "mute": case "unmute": u = "mute" === f; break; case "time": if (0 == = n.length) return this.error ("tempo faltando valor de segundos necessários"); if (p = n.shift (), c = Number.parseFloat (p), Number.isNaN (c) ||! Number.isFinite (c)) return this.error ("não é possível analisar o tempo:" + p); break; case "loop": case "unloop": s = "loop" === f; break; case "goto": if ( 0 === n.length) return this.error ("ir para o título da passagem obrigatória ausente"); if (p = n.shift (), l = "objeto" === (vazio 0 === p? "Indefinido ": _tipo de (p))? p.link:p,!Story.has(l))retornar this.error ('passagem"' + l + '"não existe '); quebra; padrão: retorna this.error (" ação desconhecida: "+ f)}} tente {if (null! = d && r.volume (d), null! = c && r.time (c), null! = u && r.mute (u), null! = s && r.loop (s), null! = l) {var g = "ended.macros.macro -" + this.name + "_ goto"; r.off (g ) .one (g, function () {r.off (g), Engine.play (l)})} switch (a) {case "fade": r.fade (i, o); break; case "load ": r.load (); break; case" pause ": r.pause (); break; case" play ": r.playWhenAllowed (); break; case" stop ": r.stop (); break; case "unload": r.unload ()} Config.debug && this.debugView.modes ({hidden:! 0})} catch (e) {return this.error ("error executando action:" + e.message)}}} ), Macro.add ("cacheaudio", {handler: function () {var e = this; if (this.args.length <2) {var t = []; return this.args.length <1 && t.push ("track ID"), this.args.length <2 && t.push ("fontes"), this.error ("não" + t.join ("ou") + "especificado")} var r = String ( this.args [0]). trim (), n = / ^ formato: \ s * ([\ w -] +) \ s *; \ s * / i; tente {SimpleAudio.tracks.add (r, este .args.slice (1) .map (function (t) {if (n.test (t)) {if (Config.debug) return e.error ('track ID "' + r + '": migração do especificador de formato necessária , "format: formatId;" → "formatId |" '); t = t.replace (n, "$ 1 |")} return t}))} catch (e) {return this.error (e.message)} if (Config.debug &&! SimpleAudio.tracks.get (r) .hasSource ()) return this.error ('track ID "' + r + '": nenhuma fonte de áudio suportada encontrada'); Config.debug && this.debugView.modes ( {oculto:! 0})}}), Macro.add ("createaudiogroup", {tags: ["track"], manipulador:function () {if (0 === this.args.length) return this.error ("nenhum ID de grupo especificado"); if (1 === this.payload.length) return this.error ("nenhuma faixa definida via <<track>> "); Config.debug && this.debugView.modes ({nonvoid:! 1, hidden:! 0}); for (var e = String (this.args [0]). trim (), t = [], r = 1, n = this.payload.length; r <n; ++ r) {if (this.payload [r] .args.length <1) return this.error ("nenhum ID de faixa especificado "); t.push (String (this.payload [r] .args [0]). trim ()), Config.debug && this.createDebugView (this.payload [r] .name, this.payload [r] .source ) .modes ({nonvoid:! 1, hidden:! 0})} try {SimpleAudio.groups.add (e, t)} catch (e) {return this.error (e.message)} Config.debug && this.createDebugView ("/"+this.name,"<</"+this.name+">>").modes({nonvoid:!1,hidden:!0})}}}),Macro.add("createplaylist", {Tag:["track"], handler: function () {if (0 === this.args.length) return this.error ("nenhum ID de lista especificado"); if (1 === this.payload.length) return this.error ("nenhuma faixa definida via <<track>>"); var e = Macro.get ("playlist"); if (null! == e.from && "createplaylist"! == e.from) retornar isso .error ("uma lista de reprodução já foi definida com <<setplaylist>>"); Config.debug && this.debugView.modes ({nonvoid:! 1, oculto:! 0}); for (var t = String (this.args [0]). Trim (), r = [], n = 1, a = this.payload.length; n <a; ++ n) {if (0 === this.payload [n] .args. comprimento) retorna this.error ("nenhum ID de faixa especificado"); for (var i = {id: String (this.payload [n] .args [0]). trim ()}, o = this.payload [n ] .args.slice (1); o.length> 0;) {var s = o.shift (), u = void 0, l = void 0; switch (s) {case "copy": case "own" : i.own =! 0; quebrar;case "rate": o.length> 0 && o.shift (); break; case "volume": if (0 === o.length) retorna this.error ("volume sem valor de nível obrigatório"); if (u = o.shift (), l = Number.parseFloat (u), Number.isNaN (l) ||! Number.isFinite (l)) return this.error ("não é possível analisar o volume:" + u); i.volume = l; break; default: return this.error ("ação desconhecida:" + s)}} r.push (i), Config.debug && this.createDebugView (this.payload [n] .name, this.payload [n]. fonte) .modes ({nonvoid:! 1, hidden:! 0})} try {SimpleAudio.lists.add (t, r)} catch (e) {return this.error (e.message)} null === e.from && (e.from = "createplaylist"), Config.debug && this.createDebugView ("/" + this.name, "<< /" + this.name + ">>"). Modos ({nonvoid:! 1, oculto:! 0})}}), Macro.add ("masteraudio", {handler: function () {if (0 === this.args.comprimento) retorna this.error ("nenhuma ação especificada"); para (var t = this.args.slice (0), r = void 0, n = void 0, a = void 0, i = void 0; t. comprimento> 0;) {var o = t.shift (), s = void 0; switch (o) {case "load": case "stop": case "unload": if (r) return this.error (e (o, r)); r = o; break; case "mudo": case "unmute": n = "mudo" === o; break; case "muteonhide": case "nomuteonhide": a = "muteonhide" === o; break; case "volume": if (0 === t.length) retorna this.error ("volume sem valor de nível obrigatório"); if (s = t.shift (), i = Número. parseFloat (s), Number.isNaN (i) ||! Number.isFinite (i)) return this.error ("não é possível analisar o volume:" + s); break; default: return this.error ("ação desconhecida:" + o)}} tente {switch (null! = n && SimpleAudio.mute (n), null! = a && SimpleAudio.muteOnHidden (a), null! = i &&SimpleAudio.volume (i), r) {case "load": SimpleAudio.load (); break; case "stop": SimpleAudio.stop (); break; case "unload": SimpleAudio.unload ()} Config.debug && this .debugView.modes ({hidden:! 0})} catch (e) {return this.error ("erro ao executar a ação:" + e.message)}}}), Macro.add ("playlist", {from: null, manipulador: function () {var t = this.self.from; if (null === t) return this.error ("nenhuma lista de reprodução foi criada"); var r = void 0, n = void 0; if ("createplaylist" === t) {if (this.args.length <2) {var a = []; retornar this.args.length <1 && a.push ("ID da lista"), this.args.length <2 && a.push ("actions"), this.error ("no" + a.join ("or") + "especificado")} var i = String (this.args [0]). Trim (); se (! SimpleAudio.lists.has (i)) return this.error ('playlist "' + i + '"não existe '); r = SimpleAudio.lists.get (i), n = this.args.slice (1)} else {if (0 === this.args.length) return this.error (" não ações especificadas "); r = SimpleAudio.lists.get (" setplaylist "), n = this.args.slice (0)} para (var o = void 0, s = 5, u = void 0, l = void 0 , c = vazio 0, d = vazio 0, f = vazio 0; n.length> 0;) {var p = n.shift (), h = vazio 0; switch (p) {caso "carregar": caso " pause ": case" play ": case" skip ": case" stop ": case" unload ": if (o) return this.error (e (p, o)); o = p; break; case" fadein " : if (o) return this.error (e (p, o)); o = "fade", u = 1; break; case "fadeout": if (o) return this.error (e (p, o) ); o = "fade", u = 0; break; case "fadeto": if (o) retorna this.error (e (p, o)); if (0 === n.length) retorna this.error ("fadeto está faltando o valor de nível necessário"); if (o = "fade", h = n.shift (),u = Number.parseFloat (h), Number.isNaN (u) ||! Number.isFinite (u)) return this.error ("não é possível analisar fadeto:" + h); quebra; case "fadeoverto": if (o ) retorna this.error (e (p, o)); if (n.length <2) {var g = []; retorna n.length <1 && g.push ("segundos"), n.length <2 && g.push ("level"), this.error ("fadeoverto missing required" + g.join ("and") + "value" + (g.length> 1? "s": ""))} if (o = " fade ", h = n.shift (), s = Number.parseFloat (h), Number.isNaN (s) ||! Number.isFinite (s)) return this.error (" não é possível analisar fadeoverto: "+ h) ; if (h = n.shift (), u = Number.parseFloat (h), Number.isNaN (u) ||! Number.isFinite (u)) return this.error ("não é possível analisar esmaecimento:" + h) ; break; case "volume": if (0 === n.length) retorna this.error ("volume faltando valor de nível obrigatório"); if (h = n.shift (), f = Number.parseFloat (h), Number.isNaN (f) ||! Number.isFinite (f)) return this.error ("não é possível analisar o volume:" + h); break; case "mute" : case "unmute": c = "mute" === p; break; case "loop": case "unloop": l = "loop" === p; break; case "shuffle": case "unshuffle": d = "embaralhar" === p; quebrar; padrão: retornar this.error ("ação desconhecida:" + p)}} try {switch (null! = f && r.volume (f), null! = c && r.mute ( c), null! = l && r.loop (l), null! = d && r.shuffle (d), o) {case "fade": r.fade (s, u); break; case "load": r.load (); quebrar; caso "pausar": r.pause (); quebrar; caso "reproduzir": r.playWhenAllowed (); quebrar; caso "ignorar": r.skip (); quebrar; caso "parar": r .stop (); break; case "descarregar": r.unload ()} Config.debug && this.debugView.modes ({oculto:! 0})} catch (e) {return this.error ("erro ao executar a ação:" + e.message)}}}), Macro.add ("removeaudiogroup", {handler: function () {if (0 = == this.args.length) return this.error ("nenhum ID de grupo especificado"); var e = String (this.args [0]). trim (); if (! SimpleAudio.groups.has (e)) return this.error ('group "' + e + '" does not exist'); SimpleAudio.groups.delete (e), Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("removeplaylist", {handler: function () {if (0 === this.args.length) retorna this.error ("nenhum ID de lista especificado"); var e = String (this.args [0]). trim (); if (! SimpleAudio.lists.has (e)) retorna this.error ('playlist "' + e + '" não existe'); SimpleAudio.lists.delete (e), Config.debug && this.debugView. modos ({oculto:! 0})}}), Macro.add ("waitforaudio", {skipArgs:! 0,handler: function () {SimpleAudio.loadWithScreen ()}}), Macro.add ("setplaylist", {handler: function () {if (0 === this.args.length) return this.error ("sem faixa ID (s) especificado (s) "); var e = Macro.get (" playlist "); if (null! == e.from &&" setplaylist "! == e.from) return this.error (" playlists já foram definidas com <<createplaylist>> "); tente {SimpleAudio.lists.add (" setplaylist ", this.args.slice (0))} catch (e) {return this.error (e.message)} null === e.from && (e.from = "setplaylist"), Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("stopallaudio", {skipArgs:! 0, handler: function ( ) {SimpleAudio.select (": all"). Stop (), Config.debug && this.debugView.modes ({hidden:! 0})}})} else Macro.add (["audio", "cacheaudio", "createaudiogroup "," createplaylist "," masteraudio "," playlist "," removeaudiogroup "," removeplaylist "," waitforaudio "," setplaylist "," stopallaudio "], {skipArgs:! 0, handler: function () {Config. debug && this.debugView.modes ({hidden:! 0})}}); Macro.add ("goto", {handler: function () {if (0 === this.args.length) return this.error (" nenhuma passagem especificada "); var e = void 0; if (e =" objeto "=== _ typeof (this.args [0])? this.args [0] .link: this.args [0] ,! História .has (e)) return this.error ('passage "' + e + '" does not exist'); setTimeout (function () {return Engine.play (e)}, Engine.minDomActionDelay)}}), Macro. add ("repeat", {isAsync:! 0, tags: null, timers: new Set, t8nRe: / ^ (?: transição | t8n) $ /, handler: function () {var e = this; if (0 = == this.args.length) retornar isso.erro ("nenhum valor de tempo especificado"); var t = void 0; tente {t = Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0]))} catch (e) {return this.error (e.message)} Config.debug && this.debugView.modes ({block:! 0}); var r = this.args.length> 1 && this.self.t8nRe.test (this.args [1]), n = jQuery (document.createElement ("span")). addClass ("macro -" + this.name) .appendTo (this.output); this.self.registerInterval (this.createShadowWrapper (function () {var t = document.createDocumentFragment (); novo Wikificador (t, e.payload [0] .contents); var a = n; r && (a = jQuery (document.createElement ("span")). addClass ("macro-repetir-inserir macro-repetir -in "). appendTo (a)), a.append (t), r && setTimeout (function () {return a.removeClass (" macro-repeat-in ")}, Engine.minDomActionDelay)}), t)}, registerInterval: function (e, t) {var r = this;if ("function"! = typeof e) throw new TypeError ("parâmetro de retorno de chamada deve ser uma função"); var n = State.passage, a = State.turns, i = this.timers, o = null; o = setInterval (function () {if (State.passage! == n || State.turns! == a) return clearInterval (o), void i.delete (o); var t = void 0; tente {TempState.break = null, TempState.hasOwnProperty ("repeatTimerId") && (t = TempState.repeatTimerId), TempState.repeatTimerId = o, e.call (r)} finalmente {void 0! == t? TempState.repeatTimerId = t: excluir TempState. repeatTimerId, TempState.break = null}}, t), i.add (o), prehistory.hasOwnProperty ("# ​​repeat-timers-cleanup") || (prehistory ["# repeat-timers-cleanup"] = function ( e) {excluir pré-história [e], i.forEach (function (e) {return clearInterval (e)}), i.clear ()})}}), Macro.add ("parar", {skipArgs:! 0 , manipulador: function () {if (! TempState.hasOwnProperty ("repeatTimerId")) return this.error ("só deve ser usado em conjunto com sua macro pai <<repeat>>"); var e = Macro.get ("repeat"). timers, t = TempState.repeatTimerId; clearInterval (t) , e.delete (t), TempState.break = 2, Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("timed", {isAsync:! 0, tags: [ "próximo"], temporizadores: novo conjunto, t8nRe: / ^ (?: transição | t8n) $ /, manipulador: função () {if (0 === this.args.length) return this.error ("sem tempo valor especificado em <<timed>> "); var e = []; tente {e.push ({name: this.name, source: this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime ( this.args [0])), content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload .comprimento> 1) {var t = vazio 0; tente {var r = vsó deve ser usado em conjunto com sua macro pai <<repeat>> "); var e = Macro.get (" repetir "). timers, t = TempState.repeatTimerId; clearInterval (t), e.delete (t), TempState.break = 2, Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("timed", {isAsync:! 0, tags: ["next"], timers: novo Definir, t8nRe: / ^ (?: transição | t8n) $ /, manipulador: function () {if (0 === this.args.length) return this.error ("nenhum valor de tempo especificado em <<timed>> "); var e = []; tente {e.push ({name: this.name, source: this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0])) , content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload.length> 1) {var t = vazio 0; tente {var r = vsó deve ser usado em conjunto com sua macro pai <<repeat>> "); var e = Macro.get (" repetir "). timers, t = TempState.repeatTimerId; clearInterval (t), e.delete (t), TempState.break = 2, Config.debug && this.debugView.modes ({hidden:! 0})}}), Macro.add ("timed", {isAsync:! 0, tags: ["next"], timers: novo Definir, t8nRe: / ^ (?: transição | t8n) $ /, manipulador: function () {if (0 === this.args.length) return this.error ("nenhum valor de tempo especificado em <<timed>> "); var e = []; tente {e.push ({name: this.name, source: this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0])) , content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload.length> 1) {var t = vazio 0; tente {var r = vget ("repeat"). timers, t = TempState.repeatTimerId; clearInterval (t), e.delete (t), TempState.break = 2, Config.debug && this.debugView.modes ({hidden:! 0})}} ), Macro.add ("timed", {isAsync:! 0, tags: ["next"], timers: new Set, t8nRe: / ^ (?: transaction | t8n) $ /, handler: function () {if (0 === this.args.length) return this.error ("nenhum valor de tempo especificado em <<timed>>"); var e = []; tente {e.push ({name: this.name, source : this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0])), content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload.length> 1) {var t = void 0; tente {var r = vget ("repeat"). timers, t = TempState.repeatTimerId; clearInterval (t), e.delete (t), TempState.break = 2, Config.debug && this.debugView.modes ({hidden:! 0})}} ), Macro.add ("timed", {isAsync:! 0, tags: ["next"], timers: new Set, t8nRe: / ^ (?: transaction | t8n) $ /, handler: function () {if (0 === this.args.length) return this.error ("nenhum valor de tempo especificado em <<timed>>"); var e = []; tente {e.push ({name: this.name, source : this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0])), content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload.length> 1) {var t = void 0; tente {var r = vtimed ", {isAsync:! 0, tags: [" next "], timers: new Set, t8nRe: / ^ (?: transição | t8n) $ /, handler: function () {if (0 === this. args.length) return this.error ("nenhum valor de tempo especificado em <<timed>>"); var e = []; tente {e.push ({name: this.name, source: this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0])), content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "em < <timed>> ")} if (this.payload.length> 1) {var t = void 0; tente {var r = vtimed ", {isAsync:! 0, tags: [" next "], timers: new Set, t8nRe: / ^ (?: transição | t8n) $ /, handler: function () {if (0 === this. args.length) return this.error ("nenhum valor de tempo especificado em <<timed>>"); var e = []; tente {e.push ({name: this.name, source: this.source, delay: Math.max (Engine.minDomActionDelay, Util.fromCssTime (this.args [0])), content: this.payload [0] .contents})} catch (e) {return this.error (e.message + "em < <timed>> ")} if (this.payload.length> 1) {var t = void 0; tente {var r = vpayload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload.length> 1) {var t = void 0; tente {var r = vpayload [0] .contents})} catch (e) {return this.error (e.message + "in <<timed>>")} if (this.payload.length> 1) {var t = void 0; tente {var r = v| "+ Story.title), window.scroll (0,0), b = v.Playing, Story.has (" PassageDone ")) try {a = Wikifier.wikifyEval (Story.get (" PassageDone "). Text) } catch (e) {console.error (e), Alert.error ("PassageDone", e.message)} if (jQuery.event.trigger ({type: ": passagedisplay", content: u, passage: o} ), Object.keys (postdisplay) .forEach (function (e) {"function" == typeof postdisplay [e] && postdisplay [e] .call (o, e)}), null! == E? E.forEach ( function (e) {jQuery (e.element) .empty (), novo Wikificador (e.element, Story.get (e.passage) .processText (). trim ())}): Config.ui.updateStoryElements && UIBar.update (), Config.debug) {var c = void 0; null! = N && (c = new DebugView (document.createDocumentFragment (), "especial", "PassageReady", "PassageReady"), c.modes ({oculto: ! 0}), c.append (n), jQuery (u) .prepend (c.output)), nulo! = A &&
contém tags ilegais; inválido: "'+ e.tags.filter (function (e) {return n.includes (e)}). sort (). join ('", "') +'" ')} var n = ["widget "], a = [" PassageDone "," PassageFooter "," PassageHeader "," PassageReady "," StoryAuthor "," StoryBanner "," StoryCaption "," StoryInit "," StoryMenu "," StoryShare "," StorySubtitle "] , i = jQuery ("tw-storydata"), o = i.attr ("startnode") || ""; Config.passages.start = null, Config.debug = / \ bdebug \ b / .test (i. attr ("options")), i.children ("style"). each (function (e) {v.push (new Passage ("tw-user-style -" + e, this))}), i. children ("script"). each (function (e) {m.push (new Passage ("tw-user-script -" + e, this))}), i.children ('tw-passagedata:
; jQuery (document.createDocumentFragment ()). append ('<div id = "debug-bar"> <div id = "debug-bar-watch"> <div>' + L10n.get ("debugBarNoWatches") + ' </div>></div> <div> <button id = "debug-bar-watch-toggle" tabindex = "0" title = "'+ a +'" aria-label = "'+ a +'"> ' + L10n.get ("debugBarLabelWatch") + '</button> <label id = "debug-bar-watch-label" for = "debug-bar-watch-input">' + L10n.get ("debugBarLabelAdd") + '</label> <input id = "debug-bar-watch-input" name = "debug-bar-watch-input" type = "text" list = "debug-bar-watch-list" tabindex = "0 "> <datalist id =" debug-bar-watch-list "aria-hidden =" true "hidden = "hidden"> </datalist> <button id = "debug-bar-watch-add" tabindex = "0" title = "'+ t +'" aria-label = "'+ t +'"> </ botão > <button id = "debug-bar-watch-all" tabindex = "0" title = "'+ r +'" aria-label = "'+ r +'"> </button> <button id = "debug-bar -watch-none "tabindex =" 0 "title =" '+ n +' "aria-label =" '+ n +' "> </button> </div> <div> <button id =" debug-bar-views -toggle "tabindex =" 0 "title =" '+ l +' "aria-label =" '+ l +' "> '+ L10n.get (" debugBarLabelViews ") +' </button> <label id =" debug- bar-turn-label "for =" debug-bar-turn-select "> '+ L10n.get ("debugBarLabelTurn ") + '</label> <select id =" debug-bar-turn-select "tabindex =" 0 "> </select> </div> <button id =" debug-bar-toggle "tabindex =" 0 "title =" '+ e +' "aria-label =" '+ e +' "> </button> </div> <div id =" debug-bar-hint "> </div> ') .appendTo ( "body"), P = jQuery ("# ​​debug-bar"), _ = jQuery (P.find ("# debug-bar-watch"). get (0)), N = jQuery (P.find (" # debug-bar-watch-list "). get (0)), D = jQuery (P.find (" # debug-bar-turn-select "). get (0)); var c = jQuery (P. find ("# debug-bar-toggle"). get (0)), d = jQuery (P.find ("# debug-bar-watch-toggle"). get (0)), f = jQuery (P. find ("# debug-bar-watch-input"). get (0)), h = jQuery (P.find ("# debug-bar-watch-add"). get (0)), g = jQuery ( P.find ("# debug-bar-watch-all"). get (0)), m = jQuery (P.find ("# debug-bar-watch-none"). get (0)), v = jQuery ( P.find ("# debug-bar-views-toggle"). Get (0)); c.ariaClick (i), d.ariaClick (p), f.on (": addwatch", function () {o (this.value.trim ()), this.value = ""}). on ("keypress", função (e) {13 === e.which && (e.preventDefault (), f.trigger (": addwatch "))}), h.ariaClick (function () {return f.trigger (": addwatch ")}), g.ariaClick (s), m.ariaClick (u), D.on (" alterar ", function () {Engine.goTo (Number (this.value))}), v.ariaClick (function () {DebugView.toggle (), k ()}), jQuery (document) .on (": historyupdate.debug -bar ", x) .on (": passageend.debug-bar ", function () {E (), j ()}). on (": enginerestart.debug-bar ", y), b () | | DebugView.enable ()} função t () {w (), S (), x (), E (),j ()} função r () {return I} função n () {h (), I =! 0, k ()} função a () {g (), I =! 1, k ()} função i () {I? A (): n ()} função o (e) {O.test (e) && (A.pushUnique (e), A.sort (), E (), j (), k ( ))} função s () {Object.keys (State.variables) .map (function (e) {return A.pushUnique ("$" + e)}), Object.keys (State.temporary) .map (function (e) {return A.pushUnique ("_" + e)}), A.sort (), E (), j (), k ()} função u () {for (var e = A.length- 1; e> = 0; - e) A. pop (); E (), j (), k ()} função l (e) {A.delete (e), E (), j (), k ()} função c () {m (), k ()} função d () {v (), k ()} função f () {retornar! _. attr ("escondido")} função p () {_.attr ("hidden")? d (): c ()} função h () {P.css ("right", "-" + P.outerWidth () + "px")} função g () {P.css ("right", 0)} function m () {_. Attr ({"aria-hidden":! 0, hidden: "hidden"})} função v () {_. RemoveAttr ("aria-hidden hidden ")} função y () {session.delete (" debugState ")} função b () {return session.has (" debugState ")} função w () {if (! b ()) return! 1; var e = session.get ("debugState"); return I = e.stowed, A.push.apply (A, _toConsumableArray (e.watchList)), e.watchEnabled? V (): m (), e .viewsEnabled? DebugView.enable (): DebugView.disable () ,! 0} function k () {session.set ("debugState", {stowed: I, watchList: A, watchEnabled: f (), viewsEnabled: DebugView. isEnabled ()})} função S () {I? n (): a ()} função E () {if (0 === A.length) return void _.empty (). append ("<div> "+ L10n.get (" debugBarNoWatches ") +" </div> "); for (var e = L10n.get (" debugBarDeleteWatch "), t = jQuery (document.createElement (" table ")), r = jQuery (document.createElement ("tbody")), n = 0, a = A.length; n <a; ++ n)! função (t, n) {var a = A [t], i = a.slice (1), o = "$" === a [0]? State.variables: State.temporary, s = jQuery (document.createElement ("tr")), u = jQuery (document.createElement ("button ")), c = jQuery (document.createElement (" code ")); u.addClass (" watch-delete "). attr (" data-name ", a) .ariaClick ({one:! 0, label: e}, function () {return l (a)}), c.text (T (o [i])), jQuery (document.createElement ("td")). append (u) .appendTo (s), jQuery (document.createElement ("td")). text (a) .appendTo (s), jQuery (document.createElement ("td")). append (c) .appendTo (s), s.appendTo (r) } (n); t.append (r), _. empty (). append (t)} função j () {var e = Object.keys (State.variables), t = Object.keys (State.temporary) ; if (0 === e.length && 0 === t.length) return void N.empty (); var r = []. concat (_toConsumableArray (e.map (function (e) {return "$" + e })), _ toConsumableArray (t.map (função (e) {return "_" + e}))). sort (), n = document.createDocumentFragment (); r.delete (A); for (var a = 0, i = r.length; a <i; ++ a) jQuery (document.createElement ("opção")). val (r [a]). appendTo (n); N.empty (). append (n)} função x () {para (var e = State.size, t = State.expired.length, r = document.createDocumentFragment (), n = 0; n <e; ++ n) jQuery (document.createElement ("option")). val ( n) .text (t + n + 1 + "." + Util.escape (State.history [n] .title)). appendTo (r); D.empty (). ariaDisabled (e <2) .append ( r) .val (State.activeIndex)} função T (e) {if (null === e) return "null"; switch (void 0 === e? "undefined": _ typeof (e)) {case " número ": if (Number.isNaN (e)) retorna" NaN "; if (! Number.isFinite (e)) retorna" Infinity "; case" boolean ": case" symbol ": case" undefined ": return String ( e); caso "string":return JSON.stringify (e); case "function": return "Function"} var t = Util.toStringTag (e); if ("Date" === t) return "Date {" + e.toLocaleString () + "}"; if ("RegExp" === t) return "RegExp" + e.toString (); var r = []; if (e instanceof Array || e instanceof Set) {for (var n = e instanceof Array? E: Array.from (e), a = 0, i = n.length; a <i; ++ a) r.push (n.hasOwnProperty (a)? T (n [a]): "< vazio> "); return Object.keys (n) .filter (function (e) {return! C.test (e)}). forEach (function (e) {return r.push (T (e) +": "+ T (n [e]))}), t +" ("+ n.length +") ["+ r.join (", ") +"] "} return e instanceof Map? (E.forEach (function (e, t) {retorno r.push (T (t) + "→" + T (e))}), t + "(" + e.size + ") {" + r.join (",") + "}") :( Object.keys (e) .forEach (function (t) {return r.push (T (t) + ":" + T (e [t]))}), t + "{" + r.join (",") + "}")} var O = novo RegExp ("^" + Patterns.variable + "$"), C = / ^ \ d + $ /, A = [], P = null, _ = null, N = null, D = null, I =! 0; return Object.freeze (Object .defineProperties ({}, {init: {value: e}, isStowed: {value: r}, start: {value: t}, stow: {value: n}, toggle: {value: i}, unstow: { valor: a}, observe: {value: Object.freeze (Object.defineProperties ({}, {add: {value: o}, all: {value: s}, clear: {value: u}, delete: {value : l}, desativar: {valor: c}, ativar: {valor: d}, isEnabled: {valor: f}, alternar: {valor: p}}))}}))} (), LoadScreen = function ( ) {function e () {jQuery (document) .on ("readystatechange.SugarCube", function () {o.size> 0 || ("complete" === document.readyState? "carregando" === jQuery ( document.documentElement) .attr ("data-init") && (Config.loadDelay> 0? setTimeout (function () {0 === o.size && r ()}, Math.max (Engine.minDomActionDelay, Config.loadDelay)): r ()): n ())})} function t () {jQuery (document) .off ("readystatechange.SugarCube"), o.clear (), r ()} função r () {jQuery (document.documentElement) .removeAttr ("data-init")} função n () {jQuery (document.documentElement) .attr ("data-init" , "carregando")} função a () {return ++ s, o.add (s), n (), s} função i (e) {if (null == e) lançar novo Error ("LoadScreen.unlock chamado com um ID nulo ou indefinido "); o.has (e) && o.delete (e), 0 === o.size && jQuery (document) .trigger (" readystatechange ")} var o = new Set, s = 0 ; return Object.freeze (Object.defineProperties ({}, {init: {value: e}, clear: {value: t}, hide: {value: r}, show: {value: n}, lock: {value : a}, desbloquear: {value: i}}))} (), version = Object.freeze ({title: "SugarCube", major: 2, minor: 34, patch: 1, pré-lançamento: null, build:9589, data: nova Data ("2021-01-18T18: 31: 16.199Z"), extensões: {}, toString: function () {var e = this.prerelease? "-" + this.prerelease: ""; return this.major + "." + this.minor + "." + this.patch + e + "+" + this.build}, abreviação: function () {var e = this.prerelease? "-" + this.prerelease: ""; retornar this.title + "(v" + this.major + "." + this.minor + "." + this.patch + e + ")"}, long: function () {return this.title + "v" + this.toString () + "(" + this.date.toUTCString () + ")"}}), TempState = {}, macros = {}, pós-exibição = {}, pós-exibição = {}, pré-exibição = {}, prehistory = {}, prerender = {}, session = null, settings = {}, setup = {}, storage = null, browser = Browser, config = Config, has = Has, History = State, state = State, tale = Story, TempVariables = State.temporary; window.SugarCube = {},jQuery (function () {try {var e = LoadScreen.lock (); LoadScreen.init (), document.normalize && document.normalize (), Story.load (), storage = SimpleStore.create (Story.domId,! 0) , session = SimpleStore.create (Story.domId,! 1), Dialog.init (), UIBar.init (), Engine.init (), Story.init (), L10n.init (), session.has (" rcWarn ") ||" cookie "! == storage.name || (session.set (" rcWarn ", 1), window.alert (L10n.get (" warningNoWebStorage "))), Save.init (), Setting .init (), Macro.init (), Engine.start (), Config.debug && DebugBar.init (); var t = $ (janela), r = setInterval (function () {t.width () && (clearInterval ( r), UIBar.start (), Config.debug && DebugBar.start (), jQuery.event.trigger ({type: ": storyready"}), setTimeout (function () {return LoadScreen.unlock (e)}, 2 * Engine.minDomActionDelay))}, Engine.minDomActionDelay); Object.defineProperty (window, "SugarCube ", {value: Object.seal (Object.assign (Object.create (null), {Browser: Browser, Config: Config, Dialog: Dialog, Engine: Engine, Fullscreen: Fullscreen, Has: Has, L10n: L10n, Macro: Macro, Passage: Passage, Save: Save, Scripting: Scripting, Setting: Setting, SimpleAudio: SimpleAudio, State: State, Story: Story, UI: UI, UI, UIBar: UIBar, DebugBar: DebugBar, Util: Util, Visibility: Visibilidade, Wikificador: Wikificador, sessão: sessão, configurações: configurações, configuração: configuração, armazenamento: armazenamento, versão: versão}))})} catch (e) {return console.error (e), LoadScreen.clear (), Alert.fatal (null, e.message, e)}})} (janela, janela.document, jQuery);}História, UI: UI, UIBar: UIBar, DebugBar: DebugBar, Util: Util, Visibility: Visibility, Wikifier: Wikifier, session: session, settings: settings, setup: setup, storage: storage, version: version}))}) } catch (e) {return console.error (e), LoadScreen.clear (), Alert.fatal (null, e.message, e)}})} (window, window.document, jQuery);}História, UI: UI, UIBar: UIBar, DebugBar: DebugBar, Util: Util, Visibility: Visibility, Wikifier: Wikifier, session: session, settings: settings, setup: setup, storage: storage, version: version}))}) } catch (e) {return console.error (e), LoadScreen.clear (), Alert.fatal (null, e.message, e)}})} (window, window.document, jQuery);}
	</script>
</body>
</html>
